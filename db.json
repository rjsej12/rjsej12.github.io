{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/css/noscript.styl","path":"css/noscript.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/comments.js","path":"js/comments.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/config.js","path":"js/config.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/pjax.js","path":"js/pjax.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/rating.js","path":"js/third-party/rating.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/gitter.js","path":"js/third-party/chat/gitter.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/matomo.js","path":"js/third-party/analytics/matomo.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/Create-hexo-blog.md","hash":"6b29245524c9de55d308581d39194c0daaf3c208","modified":1664956340384},{"_id":"source/_posts/Don-t-be-sure-of-MDN-always.md","hash":"a69b61f498e57cb703e88bce0eefc536b5a6f600","modified":1665103094895},{"_id":"source/_posts/Image-Replacement.md","hash":"5091d0d7501eab531d1cf890c12de9cd6adce8b6","modified":1665321747530},{"_id":"source/_posts/Image-Sprite.md","hash":"42b2cbeff2558a5fc7527a509880337741a36c13","modified":1665412020103},{"_id":"source/_posts/Modern-Javascript-Deep-Dive-Chapter-11-Summary.md","hash":"0fc061f25af0bb59ddcf2e124bbc86b80351750b","modified":1666854248743},{"_id":"source/_posts/Modern-Javascript-Deep-Dive-Chapter-10-Summary.md","hash":"d935de1d3e563aab22466ddadc57a5108d1eb4f7","modified":1666355967462},{"_id":"source/_posts/Modern-Javascript-Deep-Dive-Chapter-5-Summary.md","hash":"d78e38775b10bd93f09729cece9aebccf484ea1a","modified":1666094072282},{"_id":"source/_posts/Modern-JavaScript-Deep-Dive-Chapter-4-Variable-Summary.md","hash":"a88242f58b506a831a9987463485ac2c4a5137e9","modified":1666092485128},{"_id":"source/_posts/Node-js-input-and-output-in-Baekjoon-Online-Judge.md","hash":"d4a51beafd7927cda03d82371bed7e43792d7d38","modified":1664957658767},{"_id":"source/_posts/Modern-Javascript-Deep-Dive-Chapter-7-Operator-Summary.md","hash":"803efbea54c9e7e4e0d0bdc5d98c66382fe235f8","modified":1666263069584},{"_id":"source/_posts/Modern-Javascript-Deep-Dive-Chapter-6-Data-Type-Summary.md","hash":"a2138005ce1b05371f05ae04f413b1acdeb3f736","modified":1666255022877},{"_id":"source/_posts/Retrospective-about-my-first-project.md","hash":"5317dad08e55608083ef1fa45e9e52842c2e3b94","modified":1665572227253},{"_id":"source/_posts/Modern-Javascript-Deep-Dive-Chapter-9-Summary.md","hash":"08a08105f161b469214a3ecfdebea8b972b63ee2","modified":1666351260027},{"_id":"source/_posts/pageYOffset-vs-scrollY-scroll-vs-scrollTo.md","hash":"7e99e2dbec35699da84bb6cd01640fee74606a98","modified":1669606334646},{"_id":"source/_posts/WCAG-2-1-organization.md","hash":"6f1457729a1cd1f159ae949f541a6882e97376a5","modified":1665230096113},{"_id":"source/_posts/Sass-Basic.md","hash":"9f5ba14cb94426a35f5b65d2d1ccdc5a40f986b8","modified":1665497211610},{"_id":"source/_posts/What-is-an-API.md","hash":"ac6471127b4a009750ef9121c07aa4bff08194fd","modified":1665052368149},{"_id":"source/tags/index.md","hash":"e480c7b7ea39d1c771b5b08bdd34402b784ea02a","modified":1666855628166},{"_id":"source/_posts/Modern-JavaScript-Deep-Dive-Chapter-8-Control-Flow-Statement.md","hash":"38464450e69594e406e6bf1461796505a267f7ec","modified":1666269312188},{"_id":"node_modules/hexo-theme-next/package.json","hash":"4cdf28232ac2e9f5aca6aac62edb7569a5a2905b","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/_config.yml","hash":"66d8d7c5d4fe4458b0f1ce7e22b039198aa7eb1b","modified":1664954488869},{"_id":"node_modules/hexo-theme-next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1664954488764},{"_id":"node_modules/hexo-theme-next/_vendors.yml","hash":"618ea653d36f4444a0768513788a3f11beaddd16","modified":1664954488869},{"_id":"node_modules/hexo-theme-next/README.md","hash":"56638e4978154a2f2a3f03ba84047b77b4a499cc","modified":1664954488764},{"_id":"node_modules/hexo-theme-next/LICENSE.md","hash":"68fc9a03d50fd4b5ea97092b05967d1819dea2c4","modified":1664954488764},{"_id":"node_modules/hexo-theme-next/languages/ar.yml","hash":"bca66db21c015dbd32970d8708b898518a773e1e","modified":1664954488869},{"_id":"node_modules/hexo-theme-next/docs/LICENSE.txt","hash":"f5b14f791b7cfa1d16da981d929152e088a5d1b8","modified":1664954488869},{"_id":"node_modules/hexo-theme-next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1664954488764},{"_id":"node_modules/hexo-theme-next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":1664954488764},{"_id":"node_modules/hexo-theme-next/languages/de.yml","hash":"4be7b8b76c81bf1853eb36d2e874b17546a0e792","modified":1664954488869},{"_id":"node_modules/hexo-theme-next/languages/bn.yml","hash":"fccbf2855392186e11daa8590121073594037b7b","modified":1664954488869},{"_id":"node_modules/hexo-theme-next/languages/en.yml","hash":"814d81c27fed736055ee300e0a6505b26ff4313c","modified":1664954488869},{"_id":"node_modules/hexo-theme-next/languages/es.yml","hash":"b813da5aed9d73b809133db4dfb08f90ec56afd9","modified":1664954488869},{"_id":"node_modules/hexo-theme-next/languages/fa.yml","hash":"6456d40dd42f44101d9d6e7054e9884e9163f948","modified":1664954488869},{"_id":"node_modules/hexo-theme-next/languages/it.yml","hash":"c1eeab4992c76bfd436bb205ce58b1cfeef55ee6","modified":1664954488869},{"_id":"node_modules/hexo-theme-next/languages/id.yml","hash":"14e794db4eca36b257994d81eb513e61d1edcbd6","modified":1664954488869},{"_id":"node_modules/hexo-theme-next/languages/fr.yml","hash":"b15dc05afdc94de02e5d3fee4f8d3dc5594dd37e","modified":1664954488869},{"_id":"node_modules/hexo-theme-next/languages/ja.yml","hash":"d48c4157e0e02e847aac7b513580d3364c81948c","modified":1664954488869},{"_id":"node_modules/hexo-theme-next/languages/pt-BR.yml","hash":"a1f27b3a592fc58f17d247f5563ff4a90a3da5f2","modified":1664954488869},{"_id":"node_modules/hexo-theme-next/languages/nl.yml","hash":"ecb8e39c6225f3c068a5fdd569ee7dafd5c41a1f","modified":1664954488869},{"_id":"node_modules/hexo-theme-next/languages/ko.yml","hash":"819c19eb9d142e5411f77cf3821d90f740ee114a","modified":1664954488869},{"_id":"node_modules/hexo-theme-next/languages/ru.yml","hash":"8c2b6361f2de17561c1a3eede2bf47b4e2ba6ce5","modified":1664954488869},{"_id":"node_modules/hexo-theme-next/languages/pt.yml","hash":"63a3e1e728ba5e6e22150de7331bb8a654f34960","modified":1664954488869},{"_id":"node_modules/hexo-theme-next/languages/si.yml","hash":"615d18d044f44df476d6bfbf73f7b0edc2632168","modified":1664954488869},{"_id":"node_modules/hexo-theme-next/languages/tk.yml","hash":"519239e35c3bda7b62b00ff5d34644f45b16fe6a","modified":1664954488869},{"_id":"node_modules/hexo-theme-next/languages/tr.yml","hash":"0bebba73d6f06c7dad61f80c0d7ad5f6f1791a01","modified":1664954488869},{"_id":"node_modules/hexo-theme-next/languages/vi.yml","hash":"c669c34da544a563ceae3e196addc9df6a78e024","modified":1664954488869},{"_id":"node_modules/hexo-theme-next/languages/uk.yml","hash":"7dd24580c0865c5a7bc4d391855045366a598936","modified":1664954488869},{"_id":"node_modules/hexo-theme-next/languages/zh-HK.yml","hash":"f195bb0502ffe66e850077a1af1033455ea65f93","modified":1664954488869},{"_id":"node_modules/hexo-theme-next/languages/zh-CN.yml","hash":"5a3ab21210304efef736e96bad254f789f42c567","modified":1664954488869},{"_id":"node_modules/hexo-theme-next/languages/zh-TW.yml","hash":"92256b90028de9a1e79c6bc0e5885b93e7fb4b17","modified":1664954488869},{"_id":"node_modules/hexo-theme-next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1664954488764},{"_id":"node_modules/hexo-theme-next/layout/_layout.njk","hash":"20e4160cd0deb4fa272cc3aed0f43520b3cf4a9c","modified":1664954488764},{"_id":"node_modules/hexo-theme-next/layout/tag.njk","hash":"9e16ba20c28a7f2c6bc75aa427f48122301a30aa","modified":1664954488799},{"_id":"node_modules/hexo-theme-next/layout/post.njk","hash":"6abeb85fb3e4c382ed4bb6049b12a807e6226e67","modified":1664954488799},{"_id":"node_modules/hexo-theme-next/layout/index.njk","hash":"dd63e488ae8cc144335a5958acedf6a16edd7a92","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/category.njk","hash":"c68b7343d0f8145010f93351908cc36ef6212ec1","modified":1664954488764},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/CONTRIBUTING.md","hash":"a089f7a8368ab0b7d7b9b7ec0ac3767a453435df","modified":1664954488764},{"_id":"node_modules/hexo-theme-next/layout/page.njk","hash":"6c40aa438c658eb7f0cd0f6a759f18b43e7e8f93","modified":1664954488797},{"_id":"node_modules/hexo-theme-next/docs/ru/README.md","hash":"6c82bfd2ec8248c248da701f091b548a7a133580","modified":1664954488764},{"_id":"node_modules/hexo-theme-next/scripts/helpers/engine.js","hash":"d292b78485e8e8055712b0ed6de7cf559c5fbdcd","modified":1664954488730},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7a06d443f374bd1e84294067a0ac796afd9fbe60","modified":1664954488764},{"_id":"node_modules/hexo-theme-next/scripts/helpers/font.js","hash":"3394185a7f0393c16ce52c8028f90da3e9239c55","modified":1664954488730},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-config.js","hash":"226fccbe9c93265e65a300e3cb4bf6f9065cfdd7","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-url.js","hash":"a11b71ba0c5012e2cdcab31c15439156b215563e","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1664954488727},{"_id":"node_modules/hexo-theme-next/scripts/helpers/navigation.js","hash":"78107021101553c3d23e89290f7530b60cf4aa86","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-vendors.js","hash":"afdd6a188a74c188f0dd154fac70efd4080ca262","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/scripts/events/index.js","hash":"3ce10d4cce94e3d4c482c2e18bb6f0f0ca380d3d","modified":1664954488730},{"_id":"node_modules/hexo-theme-next/scripts/filters/post.js","hash":"30e03a1d4828259f82d46e64cbfe2955b6cff9a9","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/scripts/filters/locals.js","hash":"9eb5310664759931287dd28ea39165dfb67f12ed","modified":1664954488730},{"_id":"node_modules/hexo-theme-next/scripts/filters/minify.js","hash":"f160e39943e39d7276da86adb47c3f08e5f22c7a","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1664954488711},{"_id":"node_modules/hexo-theme-next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1664954488711},{"_id":"node_modules/hexo-theme-next/scripts/tags/group-pictures.js","hash":"9ed799c329abf830f623689d7e136991256a24ca","modified":1664954488730},{"_id":"node_modules/hexo-theme-next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1664954488711},{"_id":"node_modules/hexo-theme-next/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":1664954488730},{"_id":"node_modules/hexo-theme-next/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":1664954488730},{"_id":"node_modules/hexo-theme-next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/scripts/tags/mermaid.js","hash":"4fb01ca650fa8b256b8d48f50dc1b18350bd3d6d","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1664954488730},{"_id":"node_modules/hexo-theme-next/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/source/css/_colors.styl","hash":"3c6798c10cc220d83481cb3f3782e78558cee789","modified":1664954488799},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/README.md","hash":"ccf27b9249524b9fec1c15497b4353c8d1748c6c","modified":1664954488764},{"_id":"node_modules/hexo-theme-next/source/css/main.styl","hash":"78ce791cc4ac95386cf6839ca72f5f7b51f86ee9","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1664954488711},{"_id":"node_modules/hexo-theme-next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1664954488799},{"_id":"node_modules/hexo-theme-next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1664954488799},{"_id":"node_modules/hexo-theme-next/source/css/_mixins.styl","hash":"32d31cb5a155681c19f5ad0bb56dcb08429f93ef","modified":1664954488814},{"_id":"node_modules/hexo-theme-next/source/css/noscript.styl","hash":"263eddabfae40e54c0591e7baa8403ade8cdd56d","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1664954488799},{"_id":"node_modules/hexo-theme-next/source/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1664954488868},{"_id":"node_modules/hexo-theme-next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1664954488868},{"_id":"node_modules/hexo-theme-next/source/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1664954488711},{"_id":"node_modules/hexo-theme-next/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1664954488711},{"_id":"node_modules/hexo-theme-next/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1664954488711},{"_id":"node_modules/hexo-theme-next/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1664954488727},{"_id":"node_modules/hexo-theme-next/source/js/next-boot.js","hash":"da0f07f9eaaa83de70128b0feaea3fdadb90457a","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/source/js/motion.js","hash":"f7c825cbff11885fa0dffa64824fd00e505d6a8d","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/source/js/pjax.js","hash":"919f5281c4a04d11cfd94573ecf57b3dbabd3cc8","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/source/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/layout/_macro/post.njk","hash":"434b3e76a040a816169e1929657e4176e7b8164c","modified":1664954488799},{"_id":"node_modules/hexo-theme-next/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":1664954488799},{"_id":"node_modules/hexo-theme-next/layout/_partials/comments.njk","hash":"d0c470b0f6690aa217e9ada848c5e2e73fb27c6f","modified":1664954488779},{"_id":"node_modules/hexo-theme-next/source/js/utils.js","hash":"200088bfd042f5304b2a04befab0829148845e0e","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/layout/_macro/sidebar.njk","hash":"eb786e8b35e354287cda345c524cd35ec955f692","modified":1664954488799},{"_id":"node_modules/hexo-theme-next/layout/_partials/footer.njk","hash":"19713f472972caac33ae5fbcfe9105da61257de4","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_partials/pagination.njk","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1664954488797},{"_id":"node_modules/hexo-theme-next/layout/_scripts/index.njk","hash":"6668878a0f9a1166c6a879755f54a08d942da870","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_partials/widgets.njk","hash":"852a750524decf1efa587cd52b09e387ed8315de","modified":1664954488799},{"_id":"node_modules/hexo-theme-next/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_scripts/vendors.njk","hash":"be80b9fe415a9a09d74c28e230995fd292dfc123","modified":1664954488799},{"_id":"node_modules/hexo-theme-next/layout/_third-party/fancybox.njk","hash":"844559f46e2ff1c8be234d5763703106e2072a7b","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_third-party/index.njk","hash":"d41eeb262978e34de4679d8971a9e7ac5d90ecbc","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":1664954488730},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/config.js","hash":"c8b59b404f5d2a0b3b5cd1a6c9a10af5f30e43b5","modified":1664954488727},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":1664954488730},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/vendors.js","hash":"64e4024376b51fe81be7ad80235abdf0a83853bd","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/navigation.js","hash":"dd3562686d95a50375e6fd32e717ccb0d99c1e3d","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1664954488727},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/changyan.js","hash":"5798cfc8f63665031dd3e01debed051628cec319","modified":1664954488711},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/utils.js","hash":"ec996d0673f766167c86df0966e9da1ae036e103","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/common.js","hash":"19a402a225c31edffc50f202a14e0d582d3db23e","modified":1664954488727},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":1664954488727},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/disqusjs.js","hash":"62faf6b0b0020066a0dec1f0123cf1fee3198e7e","modified":1664954488730},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":1664954488730},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":1664954488730},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1664954488730},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/layout/_third-party/pace.njk","hash":"d7ad5714079f7f65446f880baf14722435ca9061","modified":1664954488796},{"_id":"node_modules/hexo-theme-next/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":1664954488799},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Mist.styl","hash":"e1fbf169b9b6a194b518240cbd06ec3c48b83d61","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":1664954488830},{"_id":"node_modules/hexo-theme-next/layout/_third-party/rating.njk","hash":"1bcdbc7fde26d6d9ef4e7fa43ffcff5a9506b20e","modified":1664954488799},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"c65536a128b9bc9dbe2fbb1b235a3cded2891002","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/source/css/_variables/base.styl","hash":"163c7441d777bee87042d475e6ce0fde199add28","modified":1664954488814},{"_id":"node_modules/hexo-theme-next/source/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/source/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1664954488730},{"_id":"node_modules/hexo-theme-next/source/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/source/js/schemes/muse.js","hash":"9794bd4fc6a458322949d6a0ade89cd1026bc69f","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/index.njk","hash":"650de421a8ce4cf685428ffbe0087ff84cbd1356","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/brand.njk","hash":"aff4613756456be26415febc668860fdab8d33c5","modified":1664954488764},{"_id":"node_modules/hexo-theme-next/layout/_partials/head/head-unique.njk","hash":"8da52a144060db1a0a088ccb2e6cc8376d1fce70","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_partials/head/head.njk","hash":"0ba2bf0266f1fcb8edbd961869f8521b29685c56","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/sub-menu.njk","hash":"06480d8ec5f0b87eafd47f082f07968d7282dd5c","modified":1664954488799},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/breadcrumb.njk","hash":"89825e75cc45e9709fa6ba89883669eedaff6f46","modified":1664954488764},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1664954488796},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/menu.njk","hash":"ee6fc2f111572d3eeab0a2fecbb2d6b3e37ab26b","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1664954488764},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/menu-item.njk","hash":"41a8b0cc16f60fa085cb719d07216d86b6bc4bf8","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1664954488799},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/localsearch.njk","hash":"661f7acae43f0be694266323320f977d84119abe","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/algolia-search.njk","hash":"efb2b6f19df02ba5ae623a1f274fff52aed21e6f","modified":1664954488764},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/schedule.njk","hash":"0f4bc8e257da60f77c0c1738607b2bde55810684","modified":1664954488799},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/index.njk","hash":"8f6f256ab3b351ffc80f1f3f1d9834e9a7cfac31","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-copyright.njk","hash":"133942922e34abae9e4de7ea5591d77c0caa4b37","modified":1664954488799},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-followme.njk","hash":"154df0bb323c332d8c25343f258ee865e5553423","modified":1664954488799},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-meta.njk","hash":"9fa47e4fb342811da590ee4adc91cf81118c0a39","modified":1664954488799},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/gitter.njk","hash":"f8cc14b7aa949999a1faaeb7855e2f20b59a386d","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-reward.njk","hash":"002b51d0cae3f2e2e008bdc58be90c728282de5b","modified":1664954488799},{"_id":"node_modules/hexo-theme-next/layout/_partials/sidebar/site-overview.njk","hash":"3d8591bb92df77ceb9d5b07bc76da1ca89e5bd76","modified":1664954488799},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-footer.njk","hash":"bde2c7356d9362972bde41cc206d5816f8ed714d","modified":1664954488799},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/cloudflare.njk","hash":"a5b8297c2c383124dd6a56e256ecc0c0dcf489be","modified":1664954488779},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-related.njk","hash":"57eca76cfbbe9a65bc2a77f1deebf003ed335673","modified":1664954488799},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":1664954488799},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":1664954488764},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":1664954488764},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/index.njk","hash":"314805f0186e9f6208c845f0757fdb7891c540f6","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/matomo.njk","hash":"4e89648a8ec8194c5823064cbca39c938a799006","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/microsoft-clarity.njk","hash":"9dc00fcb0a05899f048eace9f9160b78956655d5","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":1664954488764},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_third-party/search/algolia-search.njk","hash":"24ed76e0c72a25ac152820c750a05826a706b6f4","modified":1664954488764},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_third-party/search/localsearch.njk","hash":"e45ea3542cdc9ed7ec8447b5e6f35df4c5e82758","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":1664954488799},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/katex.njk","hash":"1ebf658690468ea197bdd0416eb7cfa4bd0b083a","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1664954488764},{"_id":"node_modules/hexo-theme-next/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":1664954488797},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":1664954488780},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"4817e77577896ab5c0da434549917ee703a3f4cf","modified":1664954488814},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_header.styl","hash":"06080fd963c904d96c00eff098a284e337953013","modified":1664954488814},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"fb550935d374e0bdf1097fce187337dc05cad3e1","modified":1664954488814},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1664954488830},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_posts-expand.styl","hash":"be6cf377ae8f4a01ee76f9b3014e74161d4d5d17","modified":1664954488814},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"b7f48be3c43bfa393d62142544a5487a67871713","modified":1664954488814},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_layout.styl","hash":"5604ac1e161099a4d3e5657d53507268866dc717","modified":1664954488814},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"82a29572dd90451f75358a2ee2522b87304a0bb8","modified":1664954488814},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"6eee86c8f0175d6c09e434053516cd8556f78d44","modified":1664954488814},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1664954488814},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_sidebar.styl","hash":"944364893bd7160d954c10ba931af641c91515a4","modified":1664954488814},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"72dc825c50357402c342d62ab60fc0c478ab6bc1","modified":1664954488814},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_header.styl","hash":"b741ab96e73370711c63a6581159f2ea8b5bfa1b","modified":1664954488814},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1664954488814},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1664954488830},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d9141e6e14a56b5952488101e9a8388c2170e270","modified":1664954488814},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/index.styl","hash":"fe1868f47681e00a33a96199302be85377282f63","modified":1664954488830},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"bab653bcf226311381e8411a0492202f1bf1fce9","modified":1664954488814},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/reading-progress.styl","hash":"90a86045a33c1bae49fc2f6fa1e1b53170c7f77b","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/index.styl","hash":"8e34df131830d4fa3725e4590a672ba1cf1903e5","modified":1664954488830},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/mobile.styl","hash":"64775c729512b30b144ab5ae9dc4a4dfd4e13f35","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"d0a7c99095f490b0d2ed6b1be43d435960798cec","modified":1664954488814},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Gemini/index.styl","hash":"fd49b521d67eaccc629f77b4e095cb7310327565","modified":1664954488830},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1664954488814},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/pagination.styl","hash":"b5c7782368889fa9fd93807d28ff2daf270e3703","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1664954488830},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1664954488814},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1664954488864},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/toggles.styl","hash":"572a41499391677d84b16d8dbd6a996a3d5ce041","modified":1664954488867},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1664954488711},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1664954488730},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1664954488730},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1664954488746},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqusjs.js","hash":"33a82207a15aad9d1c8fb2251f9e3eba50452932","modified":1664954488730},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1664954488711},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1664954488730},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1664954488730},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1664954488730},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1664954488730},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1664954488711},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/matomo.js","hash":"c6a25b26a1443caa70b47fd3dfa282271574deb5","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1664954488730},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/mermaid.js","hash":"f27d817b0c2138dd3215b1f46af0753f60a008f3","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1664954488747},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/firestore.js","hash":"411a72df581f5b21317dc28633c7993207eb9e1c","modified":1664954488730},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/lean-analytics.js","hash":"835cbf54c49ef1327f47df70ff2636ad36b6f57d","modified":1664954488730},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1664954488730},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1664954488711},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":1664954488814},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1664954488730},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1664954488814},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1664954488866},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1664954488830},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/index.styl","hash":"d0805a763176b3c0003967401644f41dfe3bc9e8","modified":1664954488830},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-followme.styl","hash":"fc1a7bac6493f24aa50665574f37f3dd954f210c","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-body.styl","hash":"d757768a58743601d0d84158ba955eb15d4c3c01","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-footer.styl","hash":"1d284f3ea03ba9b4feb76b375e539a8e0bccf1c3","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"ec37a36e94ba791663607a5022f763915778578f","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-widgets.styl","hash":"b6677dc2a2368084ab82bb4f145ac79e5966c150","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"07cff69f2d57e6321595f64c16d8b763dc88df6a","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/disqusjs.styl","hash":"c2326ee3e8b724d99c24a818ddee32813ea5bf89","modified":1664954488830},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-header.styl","hash":"010c901e4ef49a606f8a350efbf09044e76d2ff3","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/gitter.styl","hash":"35104dc6883a61c31e0e368dac8ac2f697be62fe","modified":1664954488830},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/gitalk.styl","hash":"070737d101e7cd58e997e8c7af09958268c43a21","modified":1664954488830},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/math.styl","hash":"9d995eb4871a6c273d9d51558676a1fdabf69e72","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/index.styl","hash":"979486a41a81f2a9fd8b0b87c4f87d6416c68c7d","modified":1664954488830},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/search.styl","hash":"e72799ce3f9b79753e365b2f8c8ef6c310668d4a","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/related-posts.styl","hash":"41ed817e1eb64078074e245e771446ee041e5790","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/utterances.styl","hash":"56d90ae0559caa55b75f3c300ff2711f9ed65fc4","modified":1664954488867},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/footer/index.styl","hash":"8b9407e5cfd0571ef8de7df19022b268f962fa2f","modified":1664954488830},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/bookmark.styl","hash":"e74f4bb47a101b014ee2a1783c87f3b87323f9a0","modified":1664954488814},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/github-banner.styl","hash":"38c64c2d04e46848382bfa246a0e9c508294767b","modified":1664954488830},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/index.styl","hash":"ff642130354a0b3be0d708c43044ed4d710b5e83","modified":1664954488830},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"670fc109b56a010b166b86b616823a1aae97a738","modified":1664954488814},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/menu.styl","hash":"392fd53a8dd4e3f33a853ebb24290a622300e0ff","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/highlight/index.styl","hash":"f2328caa94645836e06fb39a6a9c9a84ed68a8b5","modified":1664954488830},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/index.styl","hash":"cee43480eba028c37d51cb620c2d81486aa24e01","modified":1664954488830},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"52fc98b1435129eb3edb9293ced9e507741f1350","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/site-meta.styl","hash":"759e582d34d08e3386c55d87a835a9523608619f","modified":1664954488862},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"b926e368f702f8686aaa2eb98d3d2e533418958c","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":1664954488863},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"9950c3188a28e1c63b5498b7bdcd14b12ace3e28","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"ee94a1a27090ad24e3ed579093088d97ff96d77d","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"fbdb63c6a8887d19b7137325ba7d6806f728139c","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1664954488830},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"021a37cf178440cc341940a299d3bca359996c6b","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/index.styl","hash":"3f76c73a891bbc10679753e702feba9e8a5ffdd2","modified":1664954488830},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"3103b81fc76b59e1e2c161e2c484625c770ed66f","modified":1664954488862},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"d6418fd2bbfba7b73ddf11ec62db9637fdf5d8af","modified":1664954488814},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/site-state.styl","hash":"26dd0adfcb1db6df29c6090c8d7e9b5a43583fb0","modified":1664954488863},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7f8a7345e6537a62cd9e9a94c8f7065b541d9b04","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"48d35dba575a7c9e8845b16652e76b7d4a4646de","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/note.styl","hash":"d27fbf7799695295dd5860a161a13ac4d90c5ba4","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b6654a1d7cf82577d8263faffee8af3ad4a5c0e8","modified":1664954488846},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/tabs.styl","hash":"7a39bcce7274284e87388743db62afc847fe6897","modified":1664954488865},{"_id":"public/search.xml","hash":"32b76adf30763e7136a5ee22585f0d15008e4b03","modified":1669606360593},{"_id":"public/tags/index.html","hash":"68950d3a2ec10db54d82cb9dd0f07bde145d3fb2","modified":1669606360593},{"_id":"public/2022/Create-hexo-blog/index.html","hash":"5c7272e5373833b48dbb074162c9f4467ceff47b","modified":1669606360593},{"_id":"public/2022/Image-Sprite/index.html","hash":"0ded8324a40fcc04775e5e98efb5a5f8e4170f36","modified":1669606360593},{"_id":"public/2022/pageYOffset-vs-scrollY-scroll-vs-scrollTo/index.html","hash":"31132a041c7d84649abe27d76b2c32fd75d9ea6f","modified":1669606360593},{"_id":"public/2022/Modern-Javascript-Deep-Dive-Chapter-11-Summary/index.html","hash":"6eeea376321c9e26892d811049deb8dab1fc1c4d","modified":1669606360593},{"_id":"public/2022/Modern-Javascript-Deep-Dive-Chapter-10-Summary/index.html","hash":"ae7ac0b9a49279ce7e3e062899c2d39e93186ff6","modified":1669606360593},{"_id":"public/2022/Modern-Javascript-Deep-Dive-Chapter-9-Summary/index.html","hash":"938d410291e9dcabbbe2d1424e9a27aca8702ab4","modified":1669606360593},{"_id":"public/2022/Modern-JavaScript-Deep-Dive-Chapter-8-Control-Flow-Statement/index.html","hash":"4b615f881969ae6e15bd7e19febe674c5a40dfb6","modified":1669606360593},{"_id":"public/2022/Modern-Javascript-Deep-Dive-Chapter-7-Operator-Summary/index.html","hash":"369b33c13f3a75e70c795bd5cc98211a5ad02019","modified":1669606360593},{"_id":"public/2022/Modern-Javascript-Deep-Dive-Chapter-6-Data-Type-Summary/index.html","hash":"40f1178d26c58a736454a967e8690e787a7d349c","modified":1669606360593},{"_id":"public/2022/Modern-Javascript-Deep-Dive-Chapter-5-Summary/index.html","hash":"6fd57db778c4ebf324d20cbda117a6b73c12ae41","modified":1669606360593},{"_id":"public/2022/Modern-JavaScript-Deep-Dive-Chapter-4-Variable-Summary/index.html","hash":"8c0e1daf4ea6c8e7b547cc8ed5f68c5f8e56e56f","modified":1669606360593},{"_id":"public/2022/Retrospective-about-my-first-project/index.html","hash":"601e3a1a21d0e670df5e7881230a6855fa90b2a8","modified":1669606360593},{"_id":"public/2022/Sass-Basic/index.html","hash":"14bffa00f98ac924335659404bd46767353da11d","modified":1669606360593},{"_id":"public/2022/Image-Replacement/index.html","hash":"b6218058b80c75881eeb25f883efdabb9f3a8956","modified":1669606360593},{"_id":"public/2022/WCAG-2-1-organization/index.html","hash":"b773cc6e357435bc5f75af86573775571b02d338","modified":1669606360593},{"_id":"public/2022/Don-t-be-sure-of-MDN-always/index.html","hash":"28aa84006e1da8924a1a4062ea7f3d2aa0443b14","modified":1669606360593},{"_id":"public/archives/page/2/index.html","hash":"114df4ee4f3d78c521249f6d3954edc733a16a1a","modified":1669606360593},{"_id":"public/archives/page/3/index.html","hash":"f13299ec35c3c1815d15d14414d8e1941cb8f577","modified":1669606360593},{"_id":"public/archives/index.html","hash":"beb4e177fc11cabc9f67a095088cfae8b737aca0","modified":1669606360593},{"_id":"public/archives/page/4/index.html","hash":"9e5be9c539f6cb0a73a5bfb1bfbd7eb1da6596c8","modified":1669606360593},{"_id":"public/archives/2022/index.html","hash":"64faa57432fa33b578c4ef176130cd8b6edfd9d8","modified":1669606360593},{"_id":"public/archives/2022/page/2/index.html","hash":"b857cb96e93472931349ba0c228c2df14754aaaf","modified":1669606360593},{"_id":"public/archives/2022/page/3/index.html","hash":"0d71feb01f9100065187a32d36ffe88fe6da2ae0","modified":1669606360593},{"_id":"public/archives/2022/page/4/index.html","hash":"144013454d1c7e0d879c62fdf655224c4abb3f9a","modified":1669606360593},{"_id":"public/archives/2022/08/index.html","hash":"45a9d5e96b53475be90afb4b1b5d0739f6b0b6d0","modified":1669606360593},{"_id":"public/archives/2022/09/index.html","hash":"2c6827d15c4766cbc29836fb60c90eb076051e55","modified":1669606360593},{"_id":"public/archives/2022/10/index.html","hash":"47df04f6271632b21bb92072e9e2118e9dc48a4e","modified":1669606360593},{"_id":"public/archives/2022/11/index.html","hash":"780cef6ee812ef2a2e6a275bf82d53bab90145bb","modified":1669606360593},{"_id":"public/archives/2022/10/page/2/index.html","hash":"71b730be4f1b7ad74036fe32c2724d719bed35e8","modified":1669606360593},{"_id":"public/tags/일상/index.html","hash":"b6010e737544c859008b91a880b8ea3c6605a27c","modified":1669606360593},{"_id":"public/tags/개발/index.html","hash":"38d0aa02156bb94f3ed6237e62107b723ccb44e9","modified":1669606360593},{"_id":"public/tags/개발/page/2/index.html","hash":"69ea28360ebd56b24bc80ac10185792351ac9cc5","modified":1669606360593},{"_id":"public/tags/개발/page/3/index.html","hash":"b0c922cef015a8f38b388df0ac91f519ecf3fd75","modified":1669606360593},{"_id":"public/tags/개발/page/4/index.html","hash":"a4e51c670f75c39e5f0263f4e4651e763c19c41d","modified":1669606360593},{"_id":"public/tags/MDN/index.html","hash":"be486eec6273d510670e6a2cb7517238da197749","modified":1669606360593},{"_id":"public/tags/CSS/index.html","hash":"da3a33ac8ef5a5ed937fb6f4bb812a4b3cddaee5","modified":1669606360593},{"_id":"public/tags/IR/index.html","hash":"3fb25aad64c037e5a8b2fb35f9ce8c05739cb69b","modified":1669606360593},{"_id":"public/tags/자바스크립트/index.html","hash":"16ead60c0780204da4688d4c437c860943ba6c58","modified":1669606360593},{"_id":"public/tags/모던-자바스크립트-Deep-Dive/index.html","hash":"bd374b064dd6e7e993f27336d98e4f95c54c45e0","modified":1669606360593},{"_id":"public/tags/자바스크립트/page/2/index.html","hash":"0e44eb399cdc9b614fe6c4bb376b9c9170351869","modified":1669606360593},{"_id":"public/tags/모던-자바스크립트-Deep-Dive/page/2/index.html","hash":"04d82d2fd28af2447269ab759d28cb78a784f2f4","modified":1669606360593},{"_id":"public/tags/JavaScript/index.html","hash":"c58beaa6d5db299e0cac0002ab84dad0e30c6fd3","modified":1669606360593},{"_id":"public/tags/코딩테스트/index.html","hash":"f918f80c9724d1f089cf8a5635db5722ca3c89fb","modified":1669606360593},{"_id":"public/tags/Sass/index.html","hash":"607ca467d8b587e29160ed0b8723d5631ccbd08c","modified":1669606360593},{"_id":"public/tags/회고/index.html","hash":"587717a8b96bf9ca911463b0f8ccd54ca5775cbb","modified":1669606360593},{"_id":"public/tags/JS/index.html","hash":"c150c87dee63e326de8a5c7e8312ae531e5bda34","modified":1669606360593},{"_id":"public/tags/WCAG/index.html","hash":"45f7213467deeb87ac90f8f2ac0ceebb8923c6db","modified":1669606360593},{"_id":"public/tags/용어정리/index.html","hash":"d4757c4e5238d062bfebd672435e5c66c741c55d","modified":1669606360593},{"_id":"public/2022/What-is-an-API/index.html","hash":"2f2daf5cf43deaab887fa9de9418e36cf796392e","modified":1669606360593},{"_id":"public/2022/Node-js-input-and-output-in-Baekjoon-Online-Judge/index.html","hash":"9f5999abe20b07ef2feaac2b3ad34eb8d321d622","modified":1669606360593},{"_id":"public/index.html","hash":"ec8a8294df969e729f4e13b60c1bfead11d6bf8d","modified":1669606360593},{"_id":"public/page/3/index.html","hash":"7e97ce7042a5888cf39b1c69d13afb63dc26ec96","modified":1669606360593},{"_id":"public/page/2/index.html","hash":"497b6376637103c2b89c0b2a2c6fca733021f423","modified":1669606360593},{"_id":"public/page/4/index.html","hash":"fb7a85df3db688a20d6c745f7e2190af7d74c5f8","modified":1669606360593},{"_id":"public/page/5/index.html","hash":"bc8d891439ebf8d799651a08017e80a470890311","modified":1669606360593},{"_id":"public/page/6/index.html","hash":"244446486d0367872b53e68338f87a998d6e1272","modified":1669606360593},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1669606360593},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1669606360593},{"_id":"public/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1669606360593},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1669606360593},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1669606360593},{"_id":"public/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1669606360593},{"_id":"public/css/noscript.css","hash":"ec89b3425fbce20863d554c6fd495ea29c3c303d","modified":1669606360593},{"_id":"public/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1669606360593},{"_id":"public/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1669606360593},{"_id":"public/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1669606360593},{"_id":"public/js/next-boot.js","hash":"da0f07f9eaaa83de70128b0feaea3fdadb90457a","modified":1669606360593},{"_id":"public/js/motion.js","hash":"f7c825cbff11885fa0dffa64824fd00e505d6a8d","modified":1669606360593},{"_id":"public/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1669606360593},{"_id":"public/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1669606360593},{"_id":"public/js/pjax.js","hash":"919f5281c4a04d11cfd94573ecf57b3dbabd3cc8","modified":1669606360593},{"_id":"public/js/utils.js","hash":"200088bfd042f5304b2a04befab0829148845e0e","modified":1669606360593},{"_id":"public/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1669606360593},{"_id":"public/js/schemes/muse.js","hash":"9794bd4fc6a458322949d6a0ade89cd1026bc69f","modified":1669606360593},{"_id":"public/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1669606360593},{"_id":"public/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1669606360593},{"_id":"public/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1669606360593},{"_id":"public/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1669606360593},{"_id":"public/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1669606360593},{"_id":"public/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1669606360593},{"_id":"public/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1669606360593},{"_id":"public/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1669606360593},{"_id":"public/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1669606360593},{"_id":"public/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1669606360593},{"_id":"public/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1669606360593},{"_id":"public/js/third-party/comments/disqusjs.js","hash":"33a82207a15aad9d1c8fb2251f9e3eba50452932","modified":1669606360593},{"_id":"public/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1669606360593},{"_id":"public/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1669606360593},{"_id":"public/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1669606360593},{"_id":"public/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1669606360593},{"_id":"public/js/third-party/analytics/matomo.js","hash":"c6a25b26a1443caa70b47fd3dfa282271574deb5","modified":1669606360593},{"_id":"public/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1669606360593},{"_id":"public/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1669606360593},{"_id":"public/js/third-party/tags/mermaid.js","hash":"f27d817b0c2138dd3215b1f46af0753f60a008f3","modified":1669606360593},{"_id":"public/js/third-party/statistics/firestore.js","hash":"411a72df581f5b21317dc28633c7993207eb9e1c","modified":1669606360593},{"_id":"public/js/third-party/statistics/lean-analytics.js","hash":"835cbf54c49ef1327f47df70ff2636ad36b6f57d","modified":1669606360593},{"_id":"public/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1669606360593},{"_id":"public/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1669606360593},{"_id":"public/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1669606360593},{"_id":"public/css/main.css","hash":"1a27acdd09233899c556de5e2dded8a0813a4715","modified":1669606360593}],"Category":[],"Data":[],"Page":[{"title":"tags","date":"2022-10-27T07:25:44.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2022-10-27 16:25:44\ntype: 'tags'\ncomments: false\n---\n","updated":"2022-10-27T07:27:08.166Z","path":"tags/index.html","layout":"page","_id":"clb08iq5x0000e4vk38gd43qx","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"헥소로 블로그 옮기기","date":"2022-10-05T07:45:29.000Z","_content":"\n커넥to git 수업동안 hexo와 Github pages를 이용해 블로그를 만들어보았다.\n\n원래는 velog를 통해 여러 글들을 포스팅 하고 있었는데 디자인에 대한 커스텀이나 지속적인 관리가 (특히 github 잔디를 지속해서 심을 수 있다는 점) 수월해 보여 블로그를 옮겨보기로 결정했다.\n\n\n그동안 썼던 글들도 차근차근 옮기며 잘 관리해봐야겠다!\n","source":"_posts/Create-hexo-blog.md","raw":"---\ntitle: 헥소로 블로그 옮기기\ndate: 2022-10-05 16:45:29\ntags:\n- 일상\n- 개발\n---\n\n커넥to git 수업동안 hexo와 Github pages를 이용해 블로그를 만들어보았다.\n\n원래는 velog를 통해 여러 글들을 포스팅 하고 있었는데 디자인에 대한 커스텀이나 지속적인 관리가 (특히 github 잔디를 지속해서 심을 수 있다는 점) 수월해 보여 블로그를 옮겨보기로 결정했다.\n\n\n그동안 썼던 글들도 차근차근 옮기며 잘 관리해봐야겠다!\n","slug":"Create-hexo-blog","published":1,"updated":"2022-10-05T07:52:20.384Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb08iq5z0001e4vk6oilfq1h","content":"<p>커넥to git 수업동안 hexo와 Github pages를 이용해 블로그를 만들어보았다.</p>\n<p>원래는 velog를 통해 여러 글들을 포스팅 하고 있었는데 디자인에 대한 커스텀이나 지속적인 관리가 (특히 github 잔디를 지속해서 심을 수 있다는 점) 수월해 보여 블로그를 옮겨보기로 결정했다.</p>\n<p>그동안 썼던 글들도 차근차근 옮기며 잘 관리해봐야겠다!</p>\n","site":{"data":{}},"excerpt":"","more":"<p>커넥to git 수업동안 hexo와 Github pages를 이용해 블로그를 만들어보았다.</p>\n<p>원래는 velog를 통해 여러 글들을 포스팅 하고 있었는데 디자인에 대한 커스텀이나 지속적인 관리가 (특히 github 잔디를 지속해서 심을 수 있다는 점) 수월해 보여 블로그를 옮겨보기로 결정했다.</p>\n<p>그동안 썼던 글들도 차근차근 옮기며 잘 관리해봐야겠다!</p>\n"},{"title":"MDN을 확신하지는 말자.","date":"2022-09-01T00:37:03.000Z","_content":"어제에 이어 position에 대해 공부하면서 position이 absolute인 경우 containing block은 가장 가까운 position이 static이 아닌 부모요소 외에도 다른 조건들이 있다고 해 MDN을 통해 공부를 하던 중 이상하다고 생각되는 점이 생겼다.\n<hr>\n\n# 👀\n\n\n[컨테이닝 블록의 모든것](https://developer.mozilla.org/ko/docs/Web/CSS/Containing_block)이라는 MDN 문서에서 컨테이닝 블록 식별 항목을 읽어보면 다음과 같이 설명하고 있다. \n> position 속성이 **absolute**나 **fixed**인 경우, 다음 조건 중 하나를 만족하는 가장 가까운 조상의 내부 여백 영역이 컨테이닝 블록이 될 수도 있습니다.\n - transform이나 perspective (en-US) 속성이 none이 아님.\n- will-change 속성이 transform이나 perspective임.\n- filter 속성이 none임. (Firefox에선 will-change가 filter일 때도 적용)\n- contain 속성이 paint임.\n\n각 속성들이 어떤 역할을 하는지 찾아보던 중 filter 속성을 검색해 보았는데 default value가 none임을 알았다. 그러자 다음과 같은 의문이 생겼다.\n\n# 🤔\n음 이상한데? filter 속성이 none이면 containing block이 될 수 있고 filter 속성의 default value가 none이면 거의 모든것이 containing block이 될 수 있다는 소리인가? 그건 아닌것 같은데...\n아 된다가 아니라 될 수도 있다네? 그러면 될 수 있는 조건과 안되는 조건은 무엇이지? \n\n그러다 [position] (https://developer.mozilla.org/ko/docs/Web/CSS/position) MDN을 들어가 보니 fixed 항목이 이렇게 나와 있었다.\n> 요소를 일반적인 문서 흐름에서 제거하고, 페이지 레이아웃에 공간도 배정하지 않습니다. 대신 뷰포트의 초기 컨테이닝 블록을 기준으로 삼아 배치합니다. 단, 요소의 조상 중 하나가 transform, perspective, filter 속성 중 어느 하나라도 none이 아니라면 (CSS Transforms 명세 참조) 뷰포트 대신 그 조상을 컨테이닝 블록으로 삼습니다. (perspective와 filter의 경우 브라우저별로 결과가 다름에 유의) 최종 위치는 top, right, bottom, left 값이 지정합니다.\n\n앗 여기에는 filter 속성이 none이 아니라고 되어있네 뭐가 맞는거지? transform이나 perspective가 none이 아니여야 했으니 filter도 none이 아닌게 맞는것 같은데.. 라며 계속 고민하다 같이 공부하시는 분들의 도움을 받아 궁금증을 해결했다.\n\n# ✔\n\n바로 [영문 MDN 사이트](https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block)에는 filter 속성이 none이 아니라고 나와있던것! 사이트 번역과정에서 오류가 있었던것이다. \n> - A filter value other than none or a will-change value of filter (only works on Firefox).\n\n<hr>\n\nMDN이 거의 공식문서 혹은 표준처럼 여겨지기는 하지만 번역문서 그리고 원문 역시도 contributor분들에 의해 쓰여지는 것이기 때문에 확신을 하지는 말고 여러 레퍼런스들을 통해 교차검증해야되겠다고 깨달았다.\n\n\n","source":"_posts/Don-t-be-sure-of-MDN-always.md","raw":"---\ntitle: MDN을 확신하지는 말자.\ndate: 2022-09-01 09:37:03\ntags:\n- 개발\n- MDN\n---\n어제에 이어 position에 대해 공부하면서 position이 absolute인 경우 containing block은 가장 가까운 position이 static이 아닌 부모요소 외에도 다른 조건들이 있다고 해 MDN을 통해 공부를 하던 중 이상하다고 생각되는 점이 생겼다.\n<hr>\n\n# 👀\n\n\n[컨테이닝 블록의 모든것](https://developer.mozilla.org/ko/docs/Web/CSS/Containing_block)이라는 MDN 문서에서 컨테이닝 블록 식별 항목을 읽어보면 다음과 같이 설명하고 있다. \n> position 속성이 **absolute**나 **fixed**인 경우, 다음 조건 중 하나를 만족하는 가장 가까운 조상의 내부 여백 영역이 컨테이닝 블록이 될 수도 있습니다.\n - transform이나 perspective (en-US) 속성이 none이 아님.\n- will-change 속성이 transform이나 perspective임.\n- filter 속성이 none임. (Firefox에선 will-change가 filter일 때도 적용)\n- contain 속성이 paint임.\n\n각 속성들이 어떤 역할을 하는지 찾아보던 중 filter 속성을 검색해 보았는데 default value가 none임을 알았다. 그러자 다음과 같은 의문이 생겼다.\n\n# 🤔\n음 이상한데? filter 속성이 none이면 containing block이 될 수 있고 filter 속성의 default value가 none이면 거의 모든것이 containing block이 될 수 있다는 소리인가? 그건 아닌것 같은데...\n아 된다가 아니라 될 수도 있다네? 그러면 될 수 있는 조건과 안되는 조건은 무엇이지? \n\n그러다 [position] (https://developer.mozilla.org/ko/docs/Web/CSS/position) MDN을 들어가 보니 fixed 항목이 이렇게 나와 있었다.\n> 요소를 일반적인 문서 흐름에서 제거하고, 페이지 레이아웃에 공간도 배정하지 않습니다. 대신 뷰포트의 초기 컨테이닝 블록을 기준으로 삼아 배치합니다. 단, 요소의 조상 중 하나가 transform, perspective, filter 속성 중 어느 하나라도 none이 아니라면 (CSS Transforms 명세 참조) 뷰포트 대신 그 조상을 컨테이닝 블록으로 삼습니다. (perspective와 filter의 경우 브라우저별로 결과가 다름에 유의) 최종 위치는 top, right, bottom, left 값이 지정합니다.\n\n앗 여기에는 filter 속성이 none이 아니라고 되어있네 뭐가 맞는거지? transform이나 perspective가 none이 아니여야 했으니 filter도 none이 아닌게 맞는것 같은데.. 라며 계속 고민하다 같이 공부하시는 분들의 도움을 받아 궁금증을 해결했다.\n\n# ✔\n\n바로 [영문 MDN 사이트](https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block)에는 filter 속성이 none이 아니라고 나와있던것! 사이트 번역과정에서 오류가 있었던것이다. \n> - A filter value other than none or a will-change value of filter (only works on Firefox).\n\n<hr>\n\nMDN이 거의 공식문서 혹은 표준처럼 여겨지기는 하지만 번역문서 그리고 원문 역시도 contributor분들에 의해 쓰여지는 것이기 때문에 확신을 하지는 말고 여러 레퍼런스들을 통해 교차검증해야되겠다고 깨달았다.\n\n\n","slug":"Don-t-be-sure-of-MDN-always","published":1,"updated":"2022-10-07T00:38:14.895Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb08iq610002e4vk8gniasy2","content":"<p>어제에 이어 position에 대해 공부하면서 position이 absolute인 경우 containing block은 가장 가까운 position이 static이 아닌 부모요소 외에도 다른 조건들이 있다고 해 MDN을 통해 공부를 하던 중 이상하다고 생각되는 점이 생겼다.</p>\n<hr>\n\n<h1 id=\"👀\"><a href=\"#👀\" class=\"headerlink\" title=\"👀\"></a>👀</h1><p><a href=\"https://developer.mozilla.org/ko/docs/Web/CSS/Containing_block\">컨테이닝 블록의 모든것</a>이라는 MDN 문서에서 컨테이닝 블록 식별 항목을 읽어보면 다음과 같이 설명하고 있다. </p>\n<blockquote>\n<p>position 속성이 <strong>absolute</strong>나 <strong>fixed</strong>인 경우, 다음 조건 중 하나를 만족하는 가장 가까운 조상의 내부 여백 영역이 컨테이닝 블록이 될 수도 있습니다.</p>\n</blockquote>\n<ul>\n<li>transform이나 perspective (en-US) 속성이 none이 아님.</li>\n<li>will-change 속성이 transform이나 perspective임.</li>\n<li>filter 속성이 none임. (Firefox에선 will-change가 filter일 때도 적용)</li>\n<li>contain 속성이 paint임.</li>\n</ul>\n<p>각 속성들이 어떤 역할을 하는지 찾아보던 중 filter 속성을 검색해 보았는데 default value가 none임을 알았다. 그러자 다음과 같은 의문이 생겼다.</p>\n<h1 id=\"🤔\"><a href=\"#🤔\" class=\"headerlink\" title=\"🤔\"></a>🤔</h1><p>음 이상한데? filter 속성이 none이면 containing block이 될 수 있고 filter 속성의 default value가 none이면 거의 모든것이 containing block이 될 수 있다는 소리인가? 그건 아닌것 같은데…<br>아 된다가 아니라 될 수도 있다네? 그러면 될 수 있는 조건과 안되는 조건은 무엇이지? </p>\n<p>그러다 [position] (<a href=\"https://developer.mozilla.org/ko/docs/Web/CSS/position\">https://developer.mozilla.org/ko/docs/Web/CSS/position</a>) MDN을 들어가 보니 fixed 항목이 이렇게 나와 있었다.</p>\n<blockquote>\n<p>요소를 일반적인 문서 흐름에서 제거하고, 페이지 레이아웃에 공간도 배정하지 않습니다. 대신 뷰포트의 초기 컨테이닝 블록을 기준으로 삼아 배치합니다. 단, 요소의 조상 중 하나가 transform, perspective, filter 속성 중 어느 하나라도 none이 아니라면 (CSS Transforms 명세 참조) 뷰포트 대신 그 조상을 컨테이닝 블록으로 삼습니다. (perspective와 filter의 경우 브라우저별로 결과가 다름에 유의) 최종 위치는 top, right, bottom, left 값이 지정합니다.</p>\n</blockquote>\n<p>앗 여기에는 filter 속성이 none이 아니라고 되어있네 뭐가 맞는거지? transform이나 perspective가 none이 아니여야 했으니 filter도 none이 아닌게 맞는것 같은데.. 라며 계속 고민하다 같이 공부하시는 분들의 도움을 받아 궁금증을 해결했다.</p>\n<h1 id=\"✔\"><a href=\"#✔\" class=\"headerlink\" title=\"✔\"></a>✔</h1><p>바로 <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block\">영문 MDN 사이트</a>에는 filter 속성이 none이 아니라고 나와있던것! 사이트 번역과정에서 오류가 있었던것이다. </p>\n<blockquote>\n<ul>\n<li>A filter value other than none or a will-change value of filter (only works on Firefox).</li>\n</ul>\n</blockquote>\n<hr>\n\n<p>MDN이 거의 공식문서 혹은 표준처럼 여겨지기는 하지만 번역문서 그리고 원문 역시도 contributor분들에 의해 쓰여지는 것이기 때문에 확신을 하지는 말고 여러 레퍼런스들을 통해 교차검증해야되겠다고 깨달았다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>어제에 이어 position에 대해 공부하면서 position이 absolute인 경우 containing block은 가장 가까운 position이 static이 아닌 부모요소 외에도 다른 조건들이 있다고 해 MDN을 통해 공부를 하던 중 이상하다고 생각되는 점이 생겼다.</p>\n<hr>\n\n<h1 id=\"👀\"><a href=\"#👀\" class=\"headerlink\" title=\"👀\"></a>👀</h1><p><a href=\"https://developer.mozilla.org/ko/docs/Web/CSS/Containing_block\">컨테이닝 블록의 모든것</a>이라는 MDN 문서에서 컨테이닝 블록 식별 항목을 읽어보면 다음과 같이 설명하고 있다. </p>\n<blockquote>\n<p>position 속성이 <strong>absolute</strong>나 <strong>fixed</strong>인 경우, 다음 조건 중 하나를 만족하는 가장 가까운 조상의 내부 여백 영역이 컨테이닝 블록이 될 수도 있습니다.</p>\n</blockquote>\n<ul>\n<li>transform이나 perspective (en-US) 속성이 none이 아님.</li>\n<li>will-change 속성이 transform이나 perspective임.</li>\n<li>filter 속성이 none임. (Firefox에선 will-change가 filter일 때도 적용)</li>\n<li>contain 속성이 paint임.</li>\n</ul>\n<p>각 속성들이 어떤 역할을 하는지 찾아보던 중 filter 속성을 검색해 보았는데 default value가 none임을 알았다. 그러자 다음과 같은 의문이 생겼다.</p>\n<h1 id=\"🤔\"><a href=\"#🤔\" class=\"headerlink\" title=\"🤔\"></a>🤔</h1><p>음 이상한데? filter 속성이 none이면 containing block이 될 수 있고 filter 속성의 default value가 none이면 거의 모든것이 containing block이 될 수 있다는 소리인가? 그건 아닌것 같은데…<br>아 된다가 아니라 될 수도 있다네? 그러면 될 수 있는 조건과 안되는 조건은 무엇이지? </p>\n<p>그러다 [position] (<a href=\"https://developer.mozilla.org/ko/docs/Web/CSS/position\">https://developer.mozilla.org/ko/docs/Web/CSS/position</a>) MDN을 들어가 보니 fixed 항목이 이렇게 나와 있었다.</p>\n<blockquote>\n<p>요소를 일반적인 문서 흐름에서 제거하고, 페이지 레이아웃에 공간도 배정하지 않습니다. 대신 뷰포트의 초기 컨테이닝 블록을 기준으로 삼아 배치합니다. 단, 요소의 조상 중 하나가 transform, perspective, filter 속성 중 어느 하나라도 none이 아니라면 (CSS Transforms 명세 참조) 뷰포트 대신 그 조상을 컨테이닝 블록으로 삼습니다. (perspective와 filter의 경우 브라우저별로 결과가 다름에 유의) 최종 위치는 top, right, bottom, left 값이 지정합니다.</p>\n</blockquote>\n<p>앗 여기에는 filter 속성이 none이 아니라고 되어있네 뭐가 맞는거지? transform이나 perspective가 none이 아니여야 했으니 filter도 none이 아닌게 맞는것 같은데.. 라며 계속 고민하다 같이 공부하시는 분들의 도움을 받아 궁금증을 해결했다.</p>\n<h1 id=\"✔\"><a href=\"#✔\" class=\"headerlink\" title=\"✔\"></a>✔</h1><p>바로 <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block\">영문 MDN 사이트</a>에는 filter 속성이 none이 아니라고 나와있던것! 사이트 번역과정에서 오류가 있었던것이다. </p>\n<blockquote>\n<ul>\n<li>A filter value other than none or a will-change value of filter (only works on Firefox).</li>\n</ul>\n</blockquote>\n<hr>\n\n<p>MDN이 거의 공식문서 혹은 표준처럼 여겨지기는 하지만 번역문서 그리고 원문 역시도 contributor분들에 의해 쓰여지는 것이기 때문에 확신을 하지는 말고 여러 레퍼런스들을 통해 교차검증해야되겠다고 깨달았다.</p>\n"},{"title":"IR기법 (Image Replacement)","date":"2022-09-07T13:21:22.000Z","_content":"# 👀\nWCAG 2.1에 웹 콘텐츠의 접근성을 향상시키기 위해 텍스트 아닌 콘텐츠에 대해 대체 텍스트를 제공해주어야 한다는 지침이 있다. 이미지 역시 텍스트가 아닌 콘텐츠이기 때문에 대체 텍스트를 제공해주어야 하는데, 이는 접근성의 향상 뿐만 아니라 SEO(검색 엔진 최적화)와도 관련이 있어 중요하다.\n\n이렇게 사용자에게 대체 텍스트를 제공하는 것을 IR(Image Replacement)이라고 하는데, HTML의 요소를 사용할 경우 alt 속성을 통해 대체 텍스트를 제공하는것이 일반적이다.\n\n하지만 CSS를 이용해 background-image를 넣는 경우도 많기에 어떻게 대체 텍스트를 제공하는지 정리해보자.\n\n<hr>\n\n# 😒 visibility: hidden, display: none\n\n먼저 IR기법으로 잘못 사용되고 있는 대표적인 예가 있는데 visibility: hidden과 display: none이다.\n\n이 두 방법은 모두 적용된 요소가 화면에서 보이지 않게 하기 때문에 스크린리더 사용자를 위한 텍스트를 제공하기 위해 사용되는 경우를 발견할 수 있다. 하지만 이 두 방법은 스크린리더에서도 읽지 않는것을 원칙으로 한다.\n\nIR기법의 목표는 대체 텍스트를 시각적으는 숨기지만 스크린 리더 사용자는 읽을 수 있어야 하기 때문에 이 두가지 방법은 옳지 않다.\n\n<hr>\n\n# 😊 올바른 IR 기법\n\n## Phark Method\n- 가장 널리 사용되는 방법으로 이미지로 대체할 엘리먼트에 배경이미지를 설정하고 글자는 text-indent를 이용하여 화면 바깥으로 빼내어 보이지 않게 하는 방법이다.\n\n- 의미있는 이미지의 대체 텍스트를 제공하는 경우에 사용한다.\n\n- Text-indent 속성은 사용하기 간편하지만 단점 또한 존재한다. 만약 이미지가 제대로 로드되지 않으면 텍스트가 보이지 않기 때문에 스크린리더 사용자가 아닌 경우 이미지를 설명하는 텍스트를 보고 콘텐츠의 내용을 확인 할 수 없다. 또한, 웹페이지에 text-indent 스타일 속성이 적용된 요소가 많으면 성능 저하를 불러올 수 있다.\n\n``` css\n.ir_pm{\nwidth: 995px;\nheight: 1441px;\ntext-indent: -9999px;\nbackground : url(\"rocketgril_poster.jpg\") no-repeat;\n}\n```\n\n## Dwyer Method\n- 이미지로 대체할 엘리먼트에 배경이미지를 설정하고 글자는 span태그로 감싼 후 width와 height를 각각 0으로 하여 넘치는 글자를 숨기는 방법이다.\n\n- 추가적인 tag를 사용하고, Phark Method와 마찬가지로 이미지가 제대로 로드되지 않으면 텍스트가 보이지 않아 콘텐츠 내용 확인이 어렵다는 단점이 존재한다.\n\n``` css\n.ir_dm{\nwidth: 995px;\nheight: 1441px;\nbackground : url(\"rocketgril_poster.jpg\") no-repeat;\n}\n\n.ir_dm span{\ndisplay :block;\noverflow: hidden;\nwidth: 0px;\nheight: 0px;\n}\n```\n\n## WA IR\n- 접근성 및 UX(User Experience) 향상을 위한 화면읽기프로그램 활용 기법으로 권장되는 방법이다.\n\n- 의미있는 이미지의 대체 텍스트로 이미지가 없어도 대체 텍스트를 보여주고자 할 때 사용한다.\n\n- 이미지로 대체할 엘리먼트에 배경이미지를 설정하고 글자는 span 태그로 감싼 후 z-index:-1을 이용하여 배치순서를 뒤로 보내어 화면에 안보이게 처리한다.\n\n- 만약 브라우저에서 CSS를 끄거나, 웹 페이지에 적용된 CSS가 정상적으로 로드되지 않을 때 숨겨진 텍스트가 화면에 출력된다. 또한, position 속성을 사용하기 때문에 성능에 영향을 줄 수 있다.\n``` css\n.ir_wa{\nwidth: 995px;\nheight: 1441px;\nbackground : url(\"rockegril_poster.jpg\") no-repeat;\n}\n\n.ir_wa span{\ndisplay:block;\nposition:relative;\nz-index:-1;\n}\n```\n\n이 외에도 CSS의 위치 속성과 overflow: hidden을 사용하는 방법, 자바스크립트를 이용하여 이미지로 대체할 엘리먼트의 텍스트를 img태그로 교체하는 방법등 다양한 방법이 존재한다.\n\n<hr>\n\n# 참고\n- https://m.blog.naver.com/eirene100999/221686480420\n- https://nuli.navercorp.com/community/article/1132804?email=true\n- https://alonehistory.tistory.com/14\n","source":"_posts/Image-Replacement.md","raw":"---\ntitle: IR기법 (Image Replacement)\ndate: 2022-09-07 22:21:22\ntags:\n- 개발\n- CSS\n- IR\n---\n# 👀\nWCAG 2.1에 웹 콘텐츠의 접근성을 향상시키기 위해 텍스트 아닌 콘텐츠에 대해 대체 텍스트를 제공해주어야 한다는 지침이 있다. 이미지 역시 텍스트가 아닌 콘텐츠이기 때문에 대체 텍스트를 제공해주어야 하는데, 이는 접근성의 향상 뿐만 아니라 SEO(검색 엔진 최적화)와도 관련이 있어 중요하다.\n\n이렇게 사용자에게 대체 텍스트를 제공하는 것을 IR(Image Replacement)이라고 하는데, HTML의 요소를 사용할 경우 alt 속성을 통해 대체 텍스트를 제공하는것이 일반적이다.\n\n하지만 CSS를 이용해 background-image를 넣는 경우도 많기에 어떻게 대체 텍스트를 제공하는지 정리해보자.\n\n<hr>\n\n# 😒 visibility: hidden, display: none\n\n먼저 IR기법으로 잘못 사용되고 있는 대표적인 예가 있는데 visibility: hidden과 display: none이다.\n\n이 두 방법은 모두 적용된 요소가 화면에서 보이지 않게 하기 때문에 스크린리더 사용자를 위한 텍스트를 제공하기 위해 사용되는 경우를 발견할 수 있다. 하지만 이 두 방법은 스크린리더에서도 읽지 않는것을 원칙으로 한다.\n\nIR기법의 목표는 대체 텍스트를 시각적으는 숨기지만 스크린 리더 사용자는 읽을 수 있어야 하기 때문에 이 두가지 방법은 옳지 않다.\n\n<hr>\n\n# 😊 올바른 IR 기법\n\n## Phark Method\n- 가장 널리 사용되는 방법으로 이미지로 대체할 엘리먼트에 배경이미지를 설정하고 글자는 text-indent를 이용하여 화면 바깥으로 빼내어 보이지 않게 하는 방법이다.\n\n- 의미있는 이미지의 대체 텍스트를 제공하는 경우에 사용한다.\n\n- Text-indent 속성은 사용하기 간편하지만 단점 또한 존재한다. 만약 이미지가 제대로 로드되지 않으면 텍스트가 보이지 않기 때문에 스크린리더 사용자가 아닌 경우 이미지를 설명하는 텍스트를 보고 콘텐츠의 내용을 확인 할 수 없다. 또한, 웹페이지에 text-indent 스타일 속성이 적용된 요소가 많으면 성능 저하를 불러올 수 있다.\n\n``` css\n.ir_pm{\nwidth: 995px;\nheight: 1441px;\ntext-indent: -9999px;\nbackground : url(\"rocketgril_poster.jpg\") no-repeat;\n}\n```\n\n## Dwyer Method\n- 이미지로 대체할 엘리먼트에 배경이미지를 설정하고 글자는 span태그로 감싼 후 width와 height를 각각 0으로 하여 넘치는 글자를 숨기는 방법이다.\n\n- 추가적인 tag를 사용하고, Phark Method와 마찬가지로 이미지가 제대로 로드되지 않으면 텍스트가 보이지 않아 콘텐츠 내용 확인이 어렵다는 단점이 존재한다.\n\n``` css\n.ir_dm{\nwidth: 995px;\nheight: 1441px;\nbackground : url(\"rocketgril_poster.jpg\") no-repeat;\n}\n\n.ir_dm span{\ndisplay :block;\noverflow: hidden;\nwidth: 0px;\nheight: 0px;\n}\n```\n\n## WA IR\n- 접근성 및 UX(User Experience) 향상을 위한 화면읽기프로그램 활용 기법으로 권장되는 방법이다.\n\n- 의미있는 이미지의 대체 텍스트로 이미지가 없어도 대체 텍스트를 보여주고자 할 때 사용한다.\n\n- 이미지로 대체할 엘리먼트에 배경이미지를 설정하고 글자는 span 태그로 감싼 후 z-index:-1을 이용하여 배치순서를 뒤로 보내어 화면에 안보이게 처리한다.\n\n- 만약 브라우저에서 CSS를 끄거나, 웹 페이지에 적용된 CSS가 정상적으로 로드되지 않을 때 숨겨진 텍스트가 화면에 출력된다. 또한, position 속성을 사용하기 때문에 성능에 영향을 줄 수 있다.\n``` css\n.ir_wa{\nwidth: 995px;\nheight: 1441px;\nbackground : url(\"rockegril_poster.jpg\") no-repeat;\n}\n\n.ir_wa span{\ndisplay:block;\nposition:relative;\nz-index:-1;\n}\n```\n\n이 외에도 CSS의 위치 속성과 overflow: hidden을 사용하는 방법, 자바스크립트를 이용하여 이미지로 대체할 엘리먼트의 텍스트를 img태그로 교체하는 방법등 다양한 방법이 존재한다.\n\n<hr>\n\n# 참고\n- https://m.blog.naver.com/eirene100999/221686480420\n- https://nuli.navercorp.com/community/article/1132804?email=true\n- https://alonehistory.tistory.com/14\n","slug":"Image-Replacement","published":1,"updated":"2022-10-09T13:22:27.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb08iq660004e4vke6xvcktw","content":"<h1 id=\"👀\"><a href=\"#👀\" class=\"headerlink\" title=\"👀\"></a>👀</h1><p>WCAG 2.1에 웹 콘텐츠의 접근성을 향상시키기 위해 텍스트 아닌 콘텐츠에 대해 대체 텍스트를 제공해주어야 한다는 지침이 있다. 이미지 역시 텍스트가 아닌 콘텐츠이기 때문에 대체 텍스트를 제공해주어야 하는데, 이는 접근성의 향상 뿐만 아니라 SEO(검색 엔진 최적화)와도 관련이 있어 중요하다.</p>\n<p>이렇게 사용자에게 대체 텍스트를 제공하는 것을 IR(Image Replacement)이라고 하는데, HTML의 요소를 사용할 경우 alt 속성을 통해 대체 텍스트를 제공하는것이 일반적이다.</p>\n<p>하지만 CSS를 이용해 background-image를 넣는 경우도 많기에 어떻게 대체 텍스트를 제공하는지 정리해보자.</p>\n<hr>\n\n<h1 id=\"😒-visibility-hidden-display-none\"><a href=\"#😒-visibility-hidden-display-none\" class=\"headerlink\" title=\"😒 visibility: hidden, display: none\"></a>😒 visibility: hidden, display: none</h1><p>먼저 IR기법으로 잘못 사용되고 있는 대표적인 예가 있는데 visibility: hidden과 display: none이다.</p>\n<p>이 두 방법은 모두 적용된 요소가 화면에서 보이지 않게 하기 때문에 스크린리더 사용자를 위한 텍스트를 제공하기 위해 사용되는 경우를 발견할 수 있다. 하지만 이 두 방법은 스크린리더에서도 읽지 않는것을 원칙으로 한다.</p>\n<p>IR기법의 목표는 대체 텍스트를 시각적으는 숨기지만 스크린 리더 사용자는 읽을 수 있어야 하기 때문에 이 두가지 방법은 옳지 않다.</p>\n<hr>\n\n<h1 id=\"😊-올바른-IR-기법\"><a href=\"#😊-올바른-IR-기법\" class=\"headerlink\" title=\"😊 올바른 IR 기법\"></a>😊 올바른 IR 기법</h1><h2 id=\"Phark-Method\"><a href=\"#Phark-Method\" class=\"headerlink\" title=\"Phark Method\"></a>Phark Method</h2><ul>\n<li><p>가장 널리 사용되는 방법으로 이미지로 대체할 엘리먼트에 배경이미지를 설정하고 글자는 text-indent를 이용하여 화면 바깥으로 빼내어 보이지 않게 하는 방법이다.</p>\n</li>\n<li><p>의미있는 이미지의 대체 텍스트를 제공하는 경우에 사용한다.</p>\n</li>\n<li><p>Text-indent 속성은 사용하기 간편하지만 단점 또한 존재한다. 만약 이미지가 제대로 로드되지 않으면 텍스트가 보이지 않기 때문에 스크린리더 사용자가 아닌 경우 이미지를 설명하는 텍스트를 보고 콘텐츠의 내용을 확인 할 수 없다. 또한, 웹페이지에 text-indent 스타일 속성이 적용된 요소가 많으면 성능 저하를 불러올 수 있다.</p>\n</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.ir_pm</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">width</span>: <span class=\"number\">995px</span>;</span><br><span class=\"line\"><span class=\"attribute\">height</span>: <span class=\"number\">1441px</span>;</span><br><span class=\"line\"><span class=\"attribute\">text-indent</span>: -<span class=\"number\">9999px</span>;</span><br><span class=\"line\"><span class=\"attribute\">background</span> : <span class=\"built_in\">url</span>(<span class=\"string\">&quot;rocketgril_poster.jpg&quot;</span>) no-repeat;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Dwyer-Method\"><a href=\"#Dwyer-Method\" class=\"headerlink\" title=\"Dwyer Method\"></a>Dwyer Method</h2><ul>\n<li><p>이미지로 대체할 엘리먼트에 배경이미지를 설정하고 글자는 span태그로 감싼 후 width와 height를 각각 0으로 하여 넘치는 글자를 숨기는 방법이다.</p>\n</li>\n<li><p>추가적인 tag를 사용하고, Phark Method와 마찬가지로 이미지가 제대로 로드되지 않으면 텍스트가 보이지 않아 콘텐츠 내용 확인이 어렵다는 단점이 존재한다.</p>\n</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.ir_dm</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">width</span>: <span class=\"number\">995px</span>;</span><br><span class=\"line\"><span class=\"attribute\">height</span>: <span class=\"number\">1441px</span>;</span><br><span class=\"line\"><span class=\"attribute\">background</span> : <span class=\"built_in\">url</span>(<span class=\"string\">&quot;rocketgril_poster.jpg&quot;</span>) no-repeat;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.ir_dm</span> <span class=\"selector-tag\">span</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">display</span> :block;</span><br><span class=\"line\"><span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\"><span class=\"attribute\">width</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\"><span class=\"attribute\">height</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"WA-IR\"><a href=\"#WA-IR\" class=\"headerlink\" title=\"WA IR\"></a>WA IR</h2><ul>\n<li><p>접근성 및 UX(User Experience) 향상을 위한 화면읽기프로그램 활용 기법으로 권장되는 방법이다.</p>\n</li>\n<li><p>의미있는 이미지의 대체 텍스트로 이미지가 없어도 대체 텍스트를 보여주고자 할 때 사용한다.</p>\n</li>\n<li><p>이미지로 대체할 엘리먼트에 배경이미지를 설정하고 글자는 span 태그로 감싼 후 z-index:-1을 이용하여 배치순서를 뒤로 보내어 화면에 안보이게 처리한다.</p>\n</li>\n<li><p>만약 브라우저에서 CSS를 끄거나, 웹 페이지에 적용된 CSS가 정상적으로 로드되지 않을 때 숨겨진 텍스트가 화면에 출력된다. 또한, position 속성을 사용하기 때문에 성능에 영향을 줄 수 있다.</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.ir_wa</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">width</span>: <span class=\"number\">995px</span>;</span><br><span class=\"line\"><span class=\"attribute\">height</span>: <span class=\"number\">1441px</span>;</span><br><span class=\"line\"><span class=\"attribute\">background</span> : <span class=\"built_in\">url</span>(<span class=\"string\">&quot;rockegril_poster.jpg&quot;</span>) no-repeat;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.ir_wa</span> <span class=\"selector-tag\">span</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">display</span>:block;</span><br><span class=\"line\"><span class=\"attribute\">position</span>:relative;</span><br><span class=\"line\"><span class=\"attribute\">z-index</span>:-<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>이 외에도 CSS의 위치 속성과 overflow: hidden을 사용하는 방법, 자바스크립트를 이용하여 이미지로 대체할 엘리먼트의 텍스트를 img태그로 교체하는 방법등 다양한 방법이 존재한다.</p>\n<hr>\n\n<h1 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h1><ul>\n<li><a href=\"https://m.blog.naver.com/eirene100999/221686480420\">https://m.blog.naver.com/eirene100999/221686480420</a></li>\n<li><a href=\"https://nuli.navercorp.com/community/article/1132804?email=true\">https://nuli.navercorp.com/community/article/1132804?email=true</a></li>\n<li><a href=\"https://alonehistory.tistory.com/14\">https://alonehistory.tistory.com/14</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"👀\"><a href=\"#👀\" class=\"headerlink\" title=\"👀\"></a>👀</h1><p>WCAG 2.1에 웹 콘텐츠의 접근성을 향상시키기 위해 텍스트 아닌 콘텐츠에 대해 대체 텍스트를 제공해주어야 한다는 지침이 있다. 이미지 역시 텍스트가 아닌 콘텐츠이기 때문에 대체 텍스트를 제공해주어야 하는데, 이는 접근성의 향상 뿐만 아니라 SEO(검색 엔진 최적화)와도 관련이 있어 중요하다.</p>\n<p>이렇게 사용자에게 대체 텍스트를 제공하는 것을 IR(Image Replacement)이라고 하는데, HTML의 요소를 사용할 경우 alt 속성을 통해 대체 텍스트를 제공하는것이 일반적이다.</p>\n<p>하지만 CSS를 이용해 background-image를 넣는 경우도 많기에 어떻게 대체 텍스트를 제공하는지 정리해보자.</p>\n<hr>\n\n<h1 id=\"😒-visibility-hidden-display-none\"><a href=\"#😒-visibility-hidden-display-none\" class=\"headerlink\" title=\"😒 visibility: hidden, display: none\"></a>😒 visibility: hidden, display: none</h1><p>먼저 IR기법으로 잘못 사용되고 있는 대표적인 예가 있는데 visibility: hidden과 display: none이다.</p>\n<p>이 두 방법은 모두 적용된 요소가 화면에서 보이지 않게 하기 때문에 스크린리더 사용자를 위한 텍스트를 제공하기 위해 사용되는 경우를 발견할 수 있다. 하지만 이 두 방법은 스크린리더에서도 읽지 않는것을 원칙으로 한다.</p>\n<p>IR기법의 목표는 대체 텍스트를 시각적으는 숨기지만 스크린 리더 사용자는 읽을 수 있어야 하기 때문에 이 두가지 방법은 옳지 않다.</p>\n<hr>\n\n<h1 id=\"😊-올바른-IR-기법\"><a href=\"#😊-올바른-IR-기법\" class=\"headerlink\" title=\"😊 올바른 IR 기법\"></a>😊 올바른 IR 기법</h1><h2 id=\"Phark-Method\"><a href=\"#Phark-Method\" class=\"headerlink\" title=\"Phark Method\"></a>Phark Method</h2><ul>\n<li><p>가장 널리 사용되는 방법으로 이미지로 대체할 엘리먼트에 배경이미지를 설정하고 글자는 text-indent를 이용하여 화면 바깥으로 빼내어 보이지 않게 하는 방법이다.</p>\n</li>\n<li><p>의미있는 이미지의 대체 텍스트를 제공하는 경우에 사용한다.</p>\n</li>\n<li><p>Text-indent 속성은 사용하기 간편하지만 단점 또한 존재한다. 만약 이미지가 제대로 로드되지 않으면 텍스트가 보이지 않기 때문에 스크린리더 사용자가 아닌 경우 이미지를 설명하는 텍스트를 보고 콘텐츠의 내용을 확인 할 수 없다. 또한, 웹페이지에 text-indent 스타일 속성이 적용된 요소가 많으면 성능 저하를 불러올 수 있다.</p>\n</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.ir_pm</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">width</span>: <span class=\"number\">995px</span>;</span><br><span class=\"line\"><span class=\"attribute\">height</span>: <span class=\"number\">1441px</span>;</span><br><span class=\"line\"><span class=\"attribute\">text-indent</span>: -<span class=\"number\">9999px</span>;</span><br><span class=\"line\"><span class=\"attribute\">background</span> : <span class=\"built_in\">url</span>(<span class=\"string\">&quot;rocketgril_poster.jpg&quot;</span>) no-repeat;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Dwyer-Method\"><a href=\"#Dwyer-Method\" class=\"headerlink\" title=\"Dwyer Method\"></a>Dwyer Method</h2><ul>\n<li><p>이미지로 대체할 엘리먼트에 배경이미지를 설정하고 글자는 span태그로 감싼 후 width와 height를 각각 0으로 하여 넘치는 글자를 숨기는 방법이다.</p>\n</li>\n<li><p>추가적인 tag를 사용하고, Phark Method와 마찬가지로 이미지가 제대로 로드되지 않으면 텍스트가 보이지 않아 콘텐츠 내용 확인이 어렵다는 단점이 존재한다.</p>\n</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.ir_dm</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">width</span>: <span class=\"number\">995px</span>;</span><br><span class=\"line\"><span class=\"attribute\">height</span>: <span class=\"number\">1441px</span>;</span><br><span class=\"line\"><span class=\"attribute\">background</span> : <span class=\"built_in\">url</span>(<span class=\"string\">&quot;rocketgril_poster.jpg&quot;</span>) no-repeat;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.ir_dm</span> <span class=\"selector-tag\">span</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">display</span> :block;</span><br><span class=\"line\"><span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\"><span class=\"attribute\">width</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\"><span class=\"attribute\">height</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"WA-IR\"><a href=\"#WA-IR\" class=\"headerlink\" title=\"WA IR\"></a>WA IR</h2><ul>\n<li><p>접근성 및 UX(User Experience) 향상을 위한 화면읽기프로그램 활용 기법으로 권장되는 방법이다.</p>\n</li>\n<li><p>의미있는 이미지의 대체 텍스트로 이미지가 없어도 대체 텍스트를 보여주고자 할 때 사용한다.</p>\n</li>\n<li><p>이미지로 대체할 엘리먼트에 배경이미지를 설정하고 글자는 span 태그로 감싼 후 z-index:-1을 이용하여 배치순서를 뒤로 보내어 화면에 안보이게 처리한다.</p>\n</li>\n<li><p>만약 브라우저에서 CSS를 끄거나, 웹 페이지에 적용된 CSS가 정상적으로 로드되지 않을 때 숨겨진 텍스트가 화면에 출력된다. 또한, position 속성을 사용하기 때문에 성능에 영향을 줄 수 있다.</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.ir_wa</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">width</span>: <span class=\"number\">995px</span>;</span><br><span class=\"line\"><span class=\"attribute\">height</span>: <span class=\"number\">1441px</span>;</span><br><span class=\"line\"><span class=\"attribute\">background</span> : <span class=\"built_in\">url</span>(<span class=\"string\">&quot;rockegril_poster.jpg&quot;</span>) no-repeat;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.ir_wa</span> <span class=\"selector-tag\">span</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">display</span>:block;</span><br><span class=\"line\"><span class=\"attribute\">position</span>:relative;</span><br><span class=\"line\"><span class=\"attribute\">z-index</span>:-<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>이 외에도 CSS의 위치 속성과 overflow: hidden을 사용하는 방법, 자바스크립트를 이용하여 이미지로 대체할 엘리먼트의 텍스트를 img태그로 교체하는 방법등 다양한 방법이 존재한다.</p>\n<hr>\n\n<h1 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h1><ul>\n<li><a href=\"https://m.blog.naver.com/eirene100999/221686480420\">https://m.blog.naver.com/eirene100999/221686480420</a></li>\n<li><a href=\"https://nuli.navercorp.com/community/article/1132804?email=true\">https://nuli.navercorp.com/community/article/1132804?email=true</a></li>\n<li><a href=\"https://alonehistory.tistory.com/14\">https://alonehistory.tistory.com/14</a></li>\n</ul>\n"},{"title":"[Deep Dive] 변수","date":"2022-10-18T10:51:18.000Z","_content":"모던 자바스크립트 Deep Dive에 대한 러버덕을 진행하면서 각 장에 대해 중요하다고 생각되는 부분들에 대해 정리해보고자 한다. \n<hr>\n\n# 변수의 정의\n\n변수란 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.\n\n<hr>\n\n# 변수는 왜 필요할까?\n\n예를들어 10 + 20이라는 식을 생각해보자. 사람이 위 식을 계산하려면 10, 20을 기억하고 + 연산을 진행해 30이라는 값을 얻어야한다.\n컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억한다.\n메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체이다. 메모리 셀 하나의 크기는 기기 사양마다 다르지만 보통 1바이트이다.\n각 셀은 고유의 메모리 주소를 가진다.\n\n다시 식으로 돌아가보면 숫자 값 10과 20은 메모리 상의 임의의 위치에 저장되고 CPU는 이 값을 읽어 연산한다.\n결과인 30이라는 숫자 값 역시 메모리 상의 임의의 위치에 저장된다.\n\n이때 30이라는 숫자값을 어떻게 재사용 할 수 있을까?\n값이 저장된 메모리 주소를 통해 값에 접근할 수 있다.\n하지만 이 경우는 실수로 운영체제가 사용하고 있는 값을 변경할수도 있고, 값이 저장될 메모리 주소 또한 임의로 결정되기에 올바른 방법이 아니다.\n\n프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해 변수라는 메커니즘을 제공한다.\n\n결국 값을 저장할 수 있도록 하나의 값을 저장하기 위해 확보한 메모리 공간에 상징적인 이름을 붙인 것이 변수이다.\n\n<hr>\n\n# 변수는 어떻게 생성하는가?\n\n변수의 생성은 선언을 통해 일어난다.\n\n변수 선언은 변수를 선언하는 var, let, const의 키워드와 변수 이름을 사용한다.\n이 때 변수 이름을 식별자라고도 하는데, 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.\n식별자라는 용어는 변수 이름에만 국한되지 않고 변수, 함수, 클래스 등의 이름 모두를 식별자라 한다.\n즉 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름 모두가 식별자이다.\n\n자바스크립트 엔진은 변수 선언을 선언 단계와 초기화 단계로 나누어 수행한다.\n선언 단계는 변수 이름을 등록해 자바스크립트 엔진에 변수의 존재를 알리고 메모리 공간을 확보하는 것이며, 초기화 단계에서는 확보한 메모리 공간에 최초로 값을 할당하는 것을 말한다.\n\nvar 키워드의 경우 선언 단계와 초기화 단계가 동시에 진행 되는데, 변수 선언 후 암묵적으로 undefined값을 넣어 초기화를 수행한다. 따라서 var 키워드로 선언한 변수는 어떠한 값을 할당하지 않아도 undefined라는 값을 갖는다.\n\n왜 undefined 값을 통해 초기화를 진행하는 것일까?\n변수가 선언되어 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아 있을 수 있다. 이러한 값을 쓰레기 값이라 하는데, 만약 초기화가 진행되지 않은 상태에서 변수를 참조한다면 쓰레기 값이 나올 위험성이 있다. 이러한 위험을 피하기 위해 자바스크립트의 var 키워드는 undefined를 통해 암묵적인 초기화를 수행한다.\n\n## 메모리 확보란 무엇인가?\n\n메모리 확보란 변수가 사용할 메모리 공간을 지정하고 변수 이름과 그 공간을 연결해 값을 저장할 수 있도록 준비하는 것이다. 이 때 중요한 점은 확보된 메모리 공간은 확보가 해제 되기 전까지 누구도 사용할 수 없도록 보호된다는 점이다.\n\n## 변수 이름은 어디에 등록되는가\n\n변수 이름 또한 어딘가에 등록이 되어 있어야 읽어서 사용 할 수 있을 것이다. 변수 이름을 비롯한 모든 식별자는 바로 실행 컨텍스트에 등록된다. 실행 컨텍스트란 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환겨을 제공하고 코드의 실행결과를 실제로 관리하는 영역이다.\n\n<hr>\n\n# 변수 선언의 실행 시점\n\n변수 선언은 소스코드가 한 줄씩 순차적으로 실행되는 시점인 런타임이 아니라 그 이전에 먼저 실행된다.\n\n자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서 먼저 소스코드의 평가 과정을 거치는데, 이 때 변수 선언을 포함한 모든 선언문을 소스코드에서 뽑아내 먼저 실행한다. 그리고 소스코드의 평가 과정이 끝나면 선언문을 제외한 소스코드를 한 줄씩 순차적으로 실행한다.\n\n즉 자바스크립트 엔진은 변수 선언이 소스코드의 어느 위치에 있던 다른 코드보다 먼저 실행하는데, 이처럼 변수 선언문이 코드의 최상단으로 끌어 올려진 것처럼 동작하는 것을 변수 호이스팅이라 한다.\n\n변수 호이스팅에 의해 다음과 같은 현상이 일어날 수 있다.\n\n```javascript\nconsole.log(score); // undefined\n\nvar score;\n```\n\n<hr>\n\n# 할당이 일어나는 시점\n\n변수는 값을 저장해 재사용 하기 위한 메커니즘이므로 일반적으로 선언 이후 재사용 할 값을 할당하게 된다.\n\n이 때 변수의 선언과 값의 할당은 실행 시점이 다른데, 변수 선언은 런타임 이전에 실행되는 반면 값의 할당은 런타임에 실행된다.\n\n일반적으로 변수를 다음과 같이 2개의 문으로 사용하지만 하나의 문으로 단축 표현 할 수도 있다.\n\n```javascript\nvar score;\nscore = 80;\n\nvar score = 80; // 단축 표현\n```\n\n변수 선언과 값의 할당을 2개의 문으로 나눈 코드와 하나의 문으로 단축 표현한 코드는 정확히 동일하게 동작한다.\n\n<hr>\n\n# 재할당\n\nvar 키워드로 선언한 변수는 값을 재할당할 수 있다. 재할당은 현재 변수에 저장된 값을 버리고 새로운 값을 저장하는 것이다. var 키워드는 선언시 undefined로 초기화되기 때문에 변수에 처음으로 값을 할당하는 것도 사실 재할당이다.\n\n만약 재할당이 불가능해 변수에 저장된 값을 변경할 수 없다면 이를 상수라고 한다. 즉 상수는 단 한번만 할당이 가능한 변수이다.\n\n만약 변수에 값을 재할당 하면 변수의 값을 이전 값에서 재할당한 값으로 변하게 된다. 이때 메모리에서는 어떤 일이 일어날까? 재할당시에는 메모리 공간에서 이전 값을 지우고 새로운 값을 할당하는것이 아닌 변수가 새로운 메모리 공간을 확보하고 그 공간에 새로운 값을 저장하게 된다.\n\n이 때 이전 값이 들어 있던 메모리 공간은 어떤 식별자와도 연결되어 있지 않으므로 불필요한 값이 된다.\n이 경우 가비지 콜렉터에 의해서 메모리에서 자동 해제되지만 언저 해제될지 예측은 불가능하다.\n\n","source":"_posts/Modern-JavaScript-Deep-Dive-Chapter-4-Variable-Summary.md","raw":"---\ntitle: \"[Deep Dive] 변수\"\ndate: 2022-10-18 19:51:18\ntags:\n- 개발\n- 자바스크립트\n- 모던 자바스크립트 Deep Dive\n---\n모던 자바스크립트 Deep Dive에 대한 러버덕을 진행하면서 각 장에 대해 중요하다고 생각되는 부분들에 대해 정리해보고자 한다. \n<hr>\n\n# 변수의 정의\n\n변수란 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.\n\n<hr>\n\n# 변수는 왜 필요할까?\n\n예를들어 10 + 20이라는 식을 생각해보자. 사람이 위 식을 계산하려면 10, 20을 기억하고 + 연산을 진행해 30이라는 값을 얻어야한다.\n컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억한다.\n메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체이다. 메모리 셀 하나의 크기는 기기 사양마다 다르지만 보통 1바이트이다.\n각 셀은 고유의 메모리 주소를 가진다.\n\n다시 식으로 돌아가보면 숫자 값 10과 20은 메모리 상의 임의의 위치에 저장되고 CPU는 이 값을 읽어 연산한다.\n결과인 30이라는 숫자 값 역시 메모리 상의 임의의 위치에 저장된다.\n\n이때 30이라는 숫자값을 어떻게 재사용 할 수 있을까?\n값이 저장된 메모리 주소를 통해 값에 접근할 수 있다.\n하지만 이 경우는 실수로 운영체제가 사용하고 있는 값을 변경할수도 있고, 값이 저장될 메모리 주소 또한 임의로 결정되기에 올바른 방법이 아니다.\n\n프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해 변수라는 메커니즘을 제공한다.\n\n결국 값을 저장할 수 있도록 하나의 값을 저장하기 위해 확보한 메모리 공간에 상징적인 이름을 붙인 것이 변수이다.\n\n<hr>\n\n# 변수는 어떻게 생성하는가?\n\n변수의 생성은 선언을 통해 일어난다.\n\n변수 선언은 변수를 선언하는 var, let, const의 키워드와 변수 이름을 사용한다.\n이 때 변수 이름을 식별자라고도 하는데, 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.\n식별자라는 용어는 변수 이름에만 국한되지 않고 변수, 함수, 클래스 등의 이름 모두를 식별자라 한다.\n즉 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름 모두가 식별자이다.\n\n자바스크립트 엔진은 변수 선언을 선언 단계와 초기화 단계로 나누어 수행한다.\n선언 단계는 변수 이름을 등록해 자바스크립트 엔진에 변수의 존재를 알리고 메모리 공간을 확보하는 것이며, 초기화 단계에서는 확보한 메모리 공간에 최초로 값을 할당하는 것을 말한다.\n\nvar 키워드의 경우 선언 단계와 초기화 단계가 동시에 진행 되는데, 변수 선언 후 암묵적으로 undefined값을 넣어 초기화를 수행한다. 따라서 var 키워드로 선언한 변수는 어떠한 값을 할당하지 않아도 undefined라는 값을 갖는다.\n\n왜 undefined 값을 통해 초기화를 진행하는 것일까?\n변수가 선언되어 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아 있을 수 있다. 이러한 값을 쓰레기 값이라 하는데, 만약 초기화가 진행되지 않은 상태에서 변수를 참조한다면 쓰레기 값이 나올 위험성이 있다. 이러한 위험을 피하기 위해 자바스크립트의 var 키워드는 undefined를 통해 암묵적인 초기화를 수행한다.\n\n## 메모리 확보란 무엇인가?\n\n메모리 확보란 변수가 사용할 메모리 공간을 지정하고 변수 이름과 그 공간을 연결해 값을 저장할 수 있도록 준비하는 것이다. 이 때 중요한 점은 확보된 메모리 공간은 확보가 해제 되기 전까지 누구도 사용할 수 없도록 보호된다는 점이다.\n\n## 변수 이름은 어디에 등록되는가\n\n변수 이름 또한 어딘가에 등록이 되어 있어야 읽어서 사용 할 수 있을 것이다. 변수 이름을 비롯한 모든 식별자는 바로 실행 컨텍스트에 등록된다. 실행 컨텍스트란 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환겨을 제공하고 코드의 실행결과를 실제로 관리하는 영역이다.\n\n<hr>\n\n# 변수 선언의 실행 시점\n\n변수 선언은 소스코드가 한 줄씩 순차적으로 실행되는 시점인 런타임이 아니라 그 이전에 먼저 실행된다.\n\n자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서 먼저 소스코드의 평가 과정을 거치는데, 이 때 변수 선언을 포함한 모든 선언문을 소스코드에서 뽑아내 먼저 실행한다. 그리고 소스코드의 평가 과정이 끝나면 선언문을 제외한 소스코드를 한 줄씩 순차적으로 실행한다.\n\n즉 자바스크립트 엔진은 변수 선언이 소스코드의 어느 위치에 있던 다른 코드보다 먼저 실행하는데, 이처럼 변수 선언문이 코드의 최상단으로 끌어 올려진 것처럼 동작하는 것을 변수 호이스팅이라 한다.\n\n변수 호이스팅에 의해 다음과 같은 현상이 일어날 수 있다.\n\n```javascript\nconsole.log(score); // undefined\n\nvar score;\n```\n\n<hr>\n\n# 할당이 일어나는 시점\n\n변수는 값을 저장해 재사용 하기 위한 메커니즘이므로 일반적으로 선언 이후 재사용 할 값을 할당하게 된다.\n\n이 때 변수의 선언과 값의 할당은 실행 시점이 다른데, 변수 선언은 런타임 이전에 실행되는 반면 값의 할당은 런타임에 실행된다.\n\n일반적으로 변수를 다음과 같이 2개의 문으로 사용하지만 하나의 문으로 단축 표현 할 수도 있다.\n\n```javascript\nvar score;\nscore = 80;\n\nvar score = 80; // 단축 표현\n```\n\n변수 선언과 값의 할당을 2개의 문으로 나눈 코드와 하나의 문으로 단축 표현한 코드는 정확히 동일하게 동작한다.\n\n<hr>\n\n# 재할당\n\nvar 키워드로 선언한 변수는 값을 재할당할 수 있다. 재할당은 현재 변수에 저장된 값을 버리고 새로운 값을 저장하는 것이다. var 키워드는 선언시 undefined로 초기화되기 때문에 변수에 처음으로 값을 할당하는 것도 사실 재할당이다.\n\n만약 재할당이 불가능해 변수에 저장된 값을 변경할 수 없다면 이를 상수라고 한다. 즉 상수는 단 한번만 할당이 가능한 변수이다.\n\n만약 변수에 값을 재할당 하면 변수의 값을 이전 값에서 재할당한 값으로 변하게 된다. 이때 메모리에서는 어떤 일이 일어날까? 재할당시에는 메모리 공간에서 이전 값을 지우고 새로운 값을 할당하는것이 아닌 변수가 새로운 메모리 공간을 확보하고 그 공간에 새로운 값을 저장하게 된다.\n\n이 때 이전 값이 들어 있던 메모리 공간은 어떤 식별자와도 연결되어 있지 않으므로 불필요한 값이 된다.\n이 경우 가비지 콜렉터에 의해서 메모리에서 자동 해제되지만 언저 해제될지 예측은 불가능하다.\n\n","slug":"Modern-JavaScript-Deep-Dive-Chapter-4-Variable-Summary","published":1,"updated":"2022-10-18T11:28:05.128Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb08iq6a0005e4vkassqfx7d","content":"<p>모던 자바스크립트 Deep Dive에 대한 러버덕을 진행하면서 각 장에 대해 중요하다고 생각되는 부분들에 대해 정리해보고자 한다. </p>\n<hr>\n\n<h1 id=\"변수의-정의\"><a href=\"#변수의-정의\" class=\"headerlink\" title=\"변수의 정의\"></a>변수의 정의</h1><p>변수란 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.</p>\n<hr>\n\n<h1 id=\"변수는-왜-필요할까\"><a href=\"#변수는-왜-필요할까\" class=\"headerlink\" title=\"변수는 왜 필요할까?\"></a>변수는 왜 필요할까?</h1><p>예를들어 10 + 20이라는 식을 생각해보자. 사람이 위 식을 계산하려면 10, 20을 기억하고 + 연산을 진행해 30이라는 값을 얻어야한다.<br>컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억한다.<br>메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체이다. 메모리 셀 하나의 크기는 기기 사양마다 다르지만 보통 1바이트이다.<br>각 셀은 고유의 메모리 주소를 가진다.</p>\n<p>다시 식으로 돌아가보면 숫자 값 10과 20은 메모리 상의 임의의 위치에 저장되고 CPU는 이 값을 읽어 연산한다.<br>결과인 30이라는 숫자 값 역시 메모리 상의 임의의 위치에 저장된다.</p>\n<p>이때 30이라는 숫자값을 어떻게 재사용 할 수 있을까?<br>값이 저장된 메모리 주소를 통해 값에 접근할 수 있다.<br>하지만 이 경우는 실수로 운영체제가 사용하고 있는 값을 변경할수도 있고, 값이 저장될 메모리 주소 또한 임의로 결정되기에 올바른 방법이 아니다.</p>\n<p>프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해 변수라는 메커니즘을 제공한다.</p>\n<p>결국 값을 저장할 수 있도록 하나의 값을 저장하기 위해 확보한 메모리 공간에 상징적인 이름을 붙인 것이 변수이다.</p>\n<hr>\n\n<h1 id=\"변수는-어떻게-생성하는가\"><a href=\"#변수는-어떻게-생성하는가\" class=\"headerlink\" title=\"변수는 어떻게 생성하는가?\"></a>변수는 어떻게 생성하는가?</h1><p>변수의 생성은 선언을 통해 일어난다.</p>\n<p>변수 선언은 변수를 선언하는 var, let, const의 키워드와 변수 이름을 사용한다.<br>이 때 변수 이름을 식별자라고도 하는데, 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.<br>식별자라는 용어는 변수 이름에만 국한되지 않고 변수, 함수, 클래스 등의 이름 모두를 식별자라 한다.<br>즉 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름 모두가 식별자이다.</p>\n<p>자바스크립트 엔진은 변수 선언을 선언 단계와 초기화 단계로 나누어 수행한다.<br>선언 단계는 변수 이름을 등록해 자바스크립트 엔진에 변수의 존재를 알리고 메모리 공간을 확보하는 것이며, 초기화 단계에서는 확보한 메모리 공간에 최초로 값을 할당하는 것을 말한다.</p>\n<p>var 키워드의 경우 선언 단계와 초기화 단계가 동시에 진행 되는데, 변수 선언 후 암묵적으로 undefined값을 넣어 초기화를 수행한다. 따라서 var 키워드로 선언한 변수는 어떠한 값을 할당하지 않아도 undefined라는 값을 갖는다.</p>\n<p>왜 undefined 값을 통해 초기화를 진행하는 것일까?<br>변수가 선언되어 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아 있을 수 있다. 이러한 값을 쓰레기 값이라 하는데, 만약 초기화가 진행되지 않은 상태에서 변수를 참조한다면 쓰레기 값이 나올 위험성이 있다. 이러한 위험을 피하기 위해 자바스크립트의 var 키워드는 undefined를 통해 암묵적인 초기화를 수행한다.</p>\n<h2 id=\"메모리-확보란-무엇인가\"><a href=\"#메모리-확보란-무엇인가\" class=\"headerlink\" title=\"메모리 확보란 무엇인가?\"></a>메모리 확보란 무엇인가?</h2><p>메모리 확보란 변수가 사용할 메모리 공간을 지정하고 변수 이름과 그 공간을 연결해 값을 저장할 수 있도록 준비하는 것이다. 이 때 중요한 점은 확보된 메모리 공간은 확보가 해제 되기 전까지 누구도 사용할 수 없도록 보호된다는 점이다.</p>\n<h2 id=\"변수-이름은-어디에-등록되는가\"><a href=\"#변수-이름은-어디에-등록되는가\" class=\"headerlink\" title=\"변수 이름은 어디에 등록되는가\"></a>변수 이름은 어디에 등록되는가</h2><p>변수 이름 또한 어딘가에 등록이 되어 있어야 읽어서 사용 할 수 있을 것이다. 변수 이름을 비롯한 모든 식별자는 바로 실행 컨텍스트에 등록된다. 실행 컨텍스트란 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환겨을 제공하고 코드의 실행결과를 실제로 관리하는 영역이다.</p>\n<hr>\n\n<h1 id=\"변수-선언의-실행-시점\"><a href=\"#변수-선언의-실행-시점\" class=\"headerlink\" title=\"변수 선언의 실행 시점\"></a>변수 선언의 실행 시점</h1><p>변수 선언은 소스코드가 한 줄씩 순차적으로 실행되는 시점인 런타임이 아니라 그 이전에 먼저 실행된다.</p>\n<p>자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서 먼저 소스코드의 평가 과정을 거치는데, 이 때 변수 선언을 포함한 모든 선언문을 소스코드에서 뽑아내 먼저 실행한다. 그리고 소스코드의 평가 과정이 끝나면 선언문을 제외한 소스코드를 한 줄씩 순차적으로 실행한다.</p>\n<p>즉 자바스크립트 엔진은 변수 선언이 소스코드의 어느 위치에 있던 다른 코드보다 먼저 실행하는데, 이처럼 변수 선언문이 코드의 최상단으로 끌어 올려진 것처럼 동작하는 것을 변수 호이스팅이라 한다.</p>\n<p>변수 호이스팅에 의해 다음과 같은 현상이 일어날 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(score); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> score;</span><br></pre></td></tr></table></figure>\n\n<hr>\n\n<h1 id=\"할당이-일어나는-시점\"><a href=\"#할당이-일어나는-시점\" class=\"headerlink\" title=\"할당이 일어나는 시점\"></a>할당이 일어나는 시점</h1><p>변수는 값을 저장해 재사용 하기 위한 메커니즘이므로 일반적으로 선언 이후 재사용 할 값을 할당하게 된다.</p>\n<p>이 때 변수의 선언과 값의 할당은 실행 시점이 다른데, 변수 선언은 런타임 이전에 실행되는 반면 값의 할당은 런타임에 실행된다.</p>\n<p>일반적으로 변수를 다음과 같이 2개의 문으로 사용하지만 하나의 문으로 단축 표현 할 수도 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> score;</span><br><span class=\"line\">score = <span class=\"number\">80</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> score = <span class=\"number\">80</span>; <span class=\"comment\">// 단축 표현</span></span><br></pre></td></tr></table></figure>\n\n<p>변수 선언과 값의 할당을 2개의 문으로 나눈 코드와 하나의 문으로 단축 표현한 코드는 정확히 동일하게 동작한다.</p>\n<hr>\n\n<h1 id=\"재할당\"><a href=\"#재할당\" class=\"headerlink\" title=\"재할당\"></a>재할당</h1><p>var 키워드로 선언한 변수는 값을 재할당할 수 있다. 재할당은 현재 변수에 저장된 값을 버리고 새로운 값을 저장하는 것이다. var 키워드는 선언시 undefined로 초기화되기 때문에 변수에 처음으로 값을 할당하는 것도 사실 재할당이다.</p>\n<p>만약 재할당이 불가능해 변수에 저장된 값을 변경할 수 없다면 이를 상수라고 한다. 즉 상수는 단 한번만 할당이 가능한 변수이다.</p>\n<p>만약 변수에 값을 재할당 하면 변수의 값을 이전 값에서 재할당한 값으로 변하게 된다. 이때 메모리에서는 어떤 일이 일어날까? 재할당시에는 메모리 공간에서 이전 값을 지우고 새로운 값을 할당하는것이 아닌 변수가 새로운 메모리 공간을 확보하고 그 공간에 새로운 값을 저장하게 된다.</p>\n<p>이 때 이전 값이 들어 있던 메모리 공간은 어떤 식별자와도 연결되어 있지 않으므로 불필요한 값이 된다.<br>이 경우 가비지 콜렉터에 의해서 메모리에서 자동 해제되지만 언저 해제될지 예측은 불가능하다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>모던 자바스크립트 Deep Dive에 대한 러버덕을 진행하면서 각 장에 대해 중요하다고 생각되는 부분들에 대해 정리해보고자 한다. </p>\n<hr>\n\n<h1 id=\"변수의-정의\"><a href=\"#변수의-정의\" class=\"headerlink\" title=\"변수의 정의\"></a>변수의 정의</h1><p>변수란 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.</p>\n<hr>\n\n<h1 id=\"변수는-왜-필요할까\"><a href=\"#변수는-왜-필요할까\" class=\"headerlink\" title=\"변수는 왜 필요할까?\"></a>변수는 왜 필요할까?</h1><p>예를들어 10 + 20이라는 식을 생각해보자. 사람이 위 식을 계산하려면 10, 20을 기억하고 + 연산을 진행해 30이라는 값을 얻어야한다.<br>컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억한다.<br>메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체이다. 메모리 셀 하나의 크기는 기기 사양마다 다르지만 보통 1바이트이다.<br>각 셀은 고유의 메모리 주소를 가진다.</p>\n<p>다시 식으로 돌아가보면 숫자 값 10과 20은 메모리 상의 임의의 위치에 저장되고 CPU는 이 값을 읽어 연산한다.<br>결과인 30이라는 숫자 값 역시 메모리 상의 임의의 위치에 저장된다.</p>\n<p>이때 30이라는 숫자값을 어떻게 재사용 할 수 있을까?<br>값이 저장된 메모리 주소를 통해 값에 접근할 수 있다.<br>하지만 이 경우는 실수로 운영체제가 사용하고 있는 값을 변경할수도 있고, 값이 저장될 메모리 주소 또한 임의로 결정되기에 올바른 방법이 아니다.</p>\n<p>프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해 변수라는 메커니즘을 제공한다.</p>\n<p>결국 값을 저장할 수 있도록 하나의 값을 저장하기 위해 확보한 메모리 공간에 상징적인 이름을 붙인 것이 변수이다.</p>\n<hr>\n\n<h1 id=\"변수는-어떻게-생성하는가\"><a href=\"#변수는-어떻게-생성하는가\" class=\"headerlink\" title=\"변수는 어떻게 생성하는가?\"></a>변수는 어떻게 생성하는가?</h1><p>변수의 생성은 선언을 통해 일어난다.</p>\n<p>변수 선언은 변수를 선언하는 var, let, const의 키워드와 변수 이름을 사용한다.<br>이 때 변수 이름을 식별자라고도 하는데, 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.<br>식별자라는 용어는 변수 이름에만 국한되지 않고 변수, 함수, 클래스 등의 이름 모두를 식별자라 한다.<br>즉 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름 모두가 식별자이다.</p>\n<p>자바스크립트 엔진은 변수 선언을 선언 단계와 초기화 단계로 나누어 수행한다.<br>선언 단계는 변수 이름을 등록해 자바스크립트 엔진에 변수의 존재를 알리고 메모리 공간을 확보하는 것이며, 초기화 단계에서는 확보한 메모리 공간에 최초로 값을 할당하는 것을 말한다.</p>\n<p>var 키워드의 경우 선언 단계와 초기화 단계가 동시에 진행 되는데, 변수 선언 후 암묵적으로 undefined값을 넣어 초기화를 수행한다. 따라서 var 키워드로 선언한 변수는 어떠한 값을 할당하지 않아도 undefined라는 값을 갖는다.</p>\n<p>왜 undefined 값을 통해 초기화를 진행하는 것일까?<br>변수가 선언되어 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아 있을 수 있다. 이러한 값을 쓰레기 값이라 하는데, 만약 초기화가 진행되지 않은 상태에서 변수를 참조한다면 쓰레기 값이 나올 위험성이 있다. 이러한 위험을 피하기 위해 자바스크립트의 var 키워드는 undefined를 통해 암묵적인 초기화를 수행한다.</p>\n<h2 id=\"메모리-확보란-무엇인가\"><a href=\"#메모리-확보란-무엇인가\" class=\"headerlink\" title=\"메모리 확보란 무엇인가?\"></a>메모리 확보란 무엇인가?</h2><p>메모리 확보란 변수가 사용할 메모리 공간을 지정하고 변수 이름과 그 공간을 연결해 값을 저장할 수 있도록 준비하는 것이다. 이 때 중요한 점은 확보된 메모리 공간은 확보가 해제 되기 전까지 누구도 사용할 수 없도록 보호된다는 점이다.</p>\n<h2 id=\"변수-이름은-어디에-등록되는가\"><a href=\"#변수-이름은-어디에-등록되는가\" class=\"headerlink\" title=\"변수 이름은 어디에 등록되는가\"></a>변수 이름은 어디에 등록되는가</h2><p>변수 이름 또한 어딘가에 등록이 되어 있어야 읽어서 사용 할 수 있을 것이다. 변수 이름을 비롯한 모든 식별자는 바로 실행 컨텍스트에 등록된다. 실행 컨텍스트란 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환겨을 제공하고 코드의 실행결과를 실제로 관리하는 영역이다.</p>\n<hr>\n\n<h1 id=\"변수-선언의-실행-시점\"><a href=\"#변수-선언의-실행-시점\" class=\"headerlink\" title=\"변수 선언의 실행 시점\"></a>변수 선언의 실행 시점</h1><p>변수 선언은 소스코드가 한 줄씩 순차적으로 실행되는 시점인 런타임이 아니라 그 이전에 먼저 실행된다.</p>\n<p>자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서 먼저 소스코드의 평가 과정을 거치는데, 이 때 변수 선언을 포함한 모든 선언문을 소스코드에서 뽑아내 먼저 실행한다. 그리고 소스코드의 평가 과정이 끝나면 선언문을 제외한 소스코드를 한 줄씩 순차적으로 실행한다.</p>\n<p>즉 자바스크립트 엔진은 변수 선언이 소스코드의 어느 위치에 있던 다른 코드보다 먼저 실행하는데, 이처럼 변수 선언문이 코드의 최상단으로 끌어 올려진 것처럼 동작하는 것을 변수 호이스팅이라 한다.</p>\n<p>변수 호이스팅에 의해 다음과 같은 현상이 일어날 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(score); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> score;</span><br></pre></td></tr></table></figure>\n\n<hr>\n\n<h1 id=\"할당이-일어나는-시점\"><a href=\"#할당이-일어나는-시점\" class=\"headerlink\" title=\"할당이 일어나는 시점\"></a>할당이 일어나는 시점</h1><p>변수는 값을 저장해 재사용 하기 위한 메커니즘이므로 일반적으로 선언 이후 재사용 할 값을 할당하게 된다.</p>\n<p>이 때 변수의 선언과 값의 할당은 실행 시점이 다른데, 변수 선언은 런타임 이전에 실행되는 반면 값의 할당은 런타임에 실행된다.</p>\n<p>일반적으로 변수를 다음과 같이 2개의 문으로 사용하지만 하나의 문으로 단축 표현 할 수도 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> score;</span><br><span class=\"line\">score = <span class=\"number\">80</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> score = <span class=\"number\">80</span>; <span class=\"comment\">// 단축 표현</span></span><br></pre></td></tr></table></figure>\n\n<p>변수 선언과 값의 할당을 2개의 문으로 나눈 코드와 하나의 문으로 단축 표현한 코드는 정확히 동일하게 동작한다.</p>\n<hr>\n\n<h1 id=\"재할당\"><a href=\"#재할당\" class=\"headerlink\" title=\"재할당\"></a>재할당</h1><p>var 키워드로 선언한 변수는 값을 재할당할 수 있다. 재할당은 현재 변수에 저장된 값을 버리고 새로운 값을 저장하는 것이다. var 키워드는 선언시 undefined로 초기화되기 때문에 변수에 처음으로 값을 할당하는 것도 사실 재할당이다.</p>\n<p>만약 재할당이 불가능해 변수에 저장된 값을 변경할 수 없다면 이를 상수라고 한다. 즉 상수는 단 한번만 할당이 가능한 변수이다.</p>\n<p>만약 변수에 값을 재할당 하면 변수의 값을 이전 값에서 재할당한 값으로 변하게 된다. 이때 메모리에서는 어떤 일이 일어날까? 재할당시에는 메모리 공간에서 이전 값을 지우고 새로운 값을 할당하는것이 아닌 변수가 새로운 메모리 공간을 확보하고 그 공간에 새로운 값을 저장하게 된다.</p>\n<p>이 때 이전 값이 들어 있던 메모리 공간은 어떤 식별자와도 연결되어 있지 않으므로 불필요한 값이 된다.<br>이 경우 가비지 콜렉터에 의해서 메모리에서 자동 해제되지만 언저 해제될지 예측은 불가능하다.</p>\n"},{"title":"[Deep Dive] 원시 값과 객체의 비교","date":"2022-10-27T07:03:22.000Z","_content":"# 원시 값 vs 객체 값\n\n앞서 데이터 타입에서 살펴보았듯이 자바스크립트가 제공하는 데이터타입은 크게 원시 타입과 객체 타입으로 구분할 수 있다.\n\n데이터 타입을 원시 타입과 객체 타입으로 구분하는 이유는 무엇일까?\n원시 타입과 객체 타입은 근본적으로 다르다는 의미일 것이다. 원시타입과 객체 타입은 크게 세 가지 측면에서 다르다.\n\n- 원시 타입의 값은 변경 불가능한 값이다. 반면 객체(참조) 타입의 값은 변경 가능한 값이다.\n- 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다. 반면 객체를 변수에 할당하면 변수에는 참조 값이 저장된다.\n- 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달이라고 한다. 반면 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달이라고 한다.\n\n원시 타입과 객체 타입에 대해 조금 더 자세히 살펴보자\n\n## 원시 값\n\n### 변경 불가능한 값\n\n원시 타입의 값은 변경 불가능한 값이다. 다시 말해, 한번 생성된 원시 값은 읽기 전용 값으로 변경할 수 없다.\n\n값을 변경할 수 없다는 것이 어떤 의미일까? 먼저 변수와 값을 정확히 구분해야 한다.\n변수란 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이고, 값이란 변수에 저장된 데이터로 표현식이 평가되어 생성된 결과이다. 값을 변경할 수 없다는 것은 변수에 관한 것이 아닌 값에 대한 진술이다.\n\n즉 원시 값을 변경할 수 없다는 것은 원시 값 자체를 변경할 수 없다는 것이지 변수 값을 변경할 수 없다는 것이 아니다. 변수 값은 재할당을 통해 언제든지 변경 가능하다. 단 상수는 재할당이 금지된 변수이므로 변수 값을 변경할 수 없다.\n\n원시 값은 변경 불가능한 값이므로 데이터의 신뢰성을 보장한다.\n\n변수에서 살펴보았듯이 원시 값을 할당한 변수에 새로운 원시 값을 재할당하면 메모리 공간에 저장되어 있는 재할당 이전의 원시 값을 변경하는 것이 아니라 새로운 메모리 공간을 확보하고 재할당할 값을 저장한 후 변수가 새롭게 재할당한 원시 값을 가리킨다.\n\n변수가 참조하던 메모리 공간의 주소가 변경된 이유는 변수에 할당된 원시 값이 변경 불가능한 값이기 때문이다.\n만약 원시 값이 변경 가능한 값이라면 변수에 새로운 원시 값을 재할당했을 때 변수가 가리키던 메모리 공간의 주소를 바꿀 필요 없이 원시 값 자체를 변경하면 될 것이다.\n\n하지만 원시 값은 불변성을 가지므로 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.\n\n### 값에 의한 전달\n\n```javascript\nvar score = 80;\nvar copy = score;\n\nconsole.log(score); // 80\nconsole.log(copy); // 80\n\nscore = 100;\n\nconsole.log(score); // 100\nconsole.log(copy); // ?\n```\n\nscore 변수에 숫자 값 80을 할당 한 후 copy 변수에 score 변수를 할당했다. 그 후, score 변수에 새로운 숫자 값 100을 재할당하면 copy 변수의 값은 어떻게 될까?\n\n이 질문은 결국 \"변수에 변수를 할당했을 때 무엇이 어떻게 전달되는가?\"이다. copy = score에서 score는 변수 값 80으로 평가되므로 copy 변수에도 80이 할당된다. 이처럼 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시 값이 복사되어 전달되는데 이를 값에 의한 전달이라 한다.\n\nscore 변수와 copy 변수는 숫자 값 80을 갖는다는 점은 동일하지만 score 변수와 copy 변수의 값 80은 다른 메모리 공간에 저장된 별개의 값이다.\n따라서 score변수의 값을 변경하더라도 copy 변수의 값은 어떠한 영향을 주지 않는다. 즉 마지막 `console.log(copy)`의 결과는 80이다.\n\n사실 이는 실제 자바스크립트 엔진의 내부 동작과 정확히 일치하지 않을 수 있다. ECMAScript 사양에는 변수를 통해 메모리를 어떻게 관리해야 하는지 명확하게 정의되어 있지 않다. 따라서 실제 자바스크립트 엔진을 구현하는 제조사에 따라 내부 동작은 차이가 있을 수 있다.\n\n위에서는 변수에 원시 값을 갖는 변수를 할당하면 원시 값이 복사되어 새로운 메모리 공간에 할당한다고 설명했지만, 변수에 원시 값을 갖는 변수를 할당하는 시점에는 두 변수가 같은 원시 값을 참조하다가 어느 한쪽의 변수에 재할당이 이뤄졌을 때 비로소 새로운 메모리 공간에 재할당된 값을 저장하도록 동작할 수도 있다.\n\n또한 엄격히 말하자면 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하기에 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달된다. 따라서 \"값에 의한 전달\"이라는 용어도 사실 오해가 있을 수 있다.\n\n결국 \"값에 의한 전달\"도 사실은 값이 아니라 메모리 주소를 전달한다. 단 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.\n중요한 것은 변수에 원시 값을 갖는 변수를 할당하면 변수 할당 시점이든, 두 변수 중 어느 하나의 변수에 값을 재할당하는 시점이든 결국은 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다는 것이다.\n\n## 객체\n\n객체는 프로퍼티의 개수가 정해져 있지 않으며, 동적으로 추가되고 삭제할 수 있다. 또 프로퍼티의 값에도 제약이 없다.\n즉 객체는 원시 값과는 다르게 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.\n\n따라서 객체는 원시 값과는 다른 방식으로 동작하도록 설계되어 있다. 원시 값과의 차이를 통해 객체에 대해 이해해보자.\n\n### 변경 가능한 값\n\n객체 타입의 값은 변경 가능한 값이다. 이게 어떤 의미일까? 먼저 변수에 객체를 할당하면 어떤 일이 일어나는지 살펴보자\n\n```javascript\nvar person = {\n  name: 'Lee',\n};\n```\n\n원시 값을 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 원시 값에 접근할 수 있다.\n즉, 원시 값을 할당한 변수는 원시 값 자체를 값으로 갖는다. 하지만 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값에 접근할 수 있다. 참조 값은 생성된 객체가 저장된 메모리 공간의 주소이다.\n\n원시 값을 할당한 변수를 참조하면 메모리에 저장되어 있는 원시 값에 접근한다. 하지만 객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조 값을 통해 실제 객체에 접근한다.\n\n원시 값은 변경 불가능한 값이므로 원시 값을 갖는 변수의 값을 변경하려면 재할당 외에는 방법이 없다. 하지만 객체는 변경 가능한 값이므로 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다. 재할당 없이 프로퍼티를 동적으로 추가할 수도 있고 프로퍼티 값을 갱신할 수도 있으며 프로퍼티 자체를 삭제할 수도 있다.\n\n이때 객체를 할당한 변수에 재할당을 하지 않았으므로 객체를 할당한 변수의 참조 값은 변경되지 않는다.\n이는 메모리 사용의 효율성과 성능을 위해 어느 정도의 구조적인 단점을 감안한 설계라고 할 수 있다.\n\n객체는 이러한 구조적 단점에 따른 부작용이 존재한다. 원시 값과는 다르게 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이다.\n\n### 참조에 의한 전달\n\n여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이 무슨 의미인지, 어떤 부작용이 발생하는지 알아보자.\n\n```javascript\nvar person = {\n  name: 'Lee';\n};\n\nvar copy = person;\n```\n\n객체를 가리키는 변수(원본, person)을 다른 변수(사본, copy)에 할당하면 원본의 참조 값이 복사되어 전달되는데 이를 참조에 의한 전달이라 한다.\n\n원본 person과 사본 copy는 저장된 메모리 주소는 다르지만 동일한 참조 값을 가지므로 원본 person과 사본 copy 모두 동일한 객체를 가리키게 된다.\n이것이 두 개의 식별자가 하나의 객체를 공유한다는 것을 의미한다. 따라서 원본 또는 사본 중 어느 한 쪽에서 객체를 변경하면 서로 영향을 주고받는다.\n\n```javascript\nvar person = {\n  name: 'Lee',\n};\n\nvar copy = person;\n\nconsole.log(copy === person); // true\n\ncopy.name = 'Kim';\nperson.address = 'Seoul';\n\n// copy와 person은 동일한 객체를 가리키므로 서로 영향을 주고 받는다.\nconsole.log(person); // {name: 'Kim', address: 'Seoul'}\nconsole.log(copy); // {name: 'Kim', address: 'Seoul'}\n```\n\n결국 \"값에 의한 전달\"과 \"참조에 의한 전달\"은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해 전달한다는 면에서 동일하다.\n다만 식별자가 기억하는 메모리 공간, 즉 변수에 저장되어 있는 값이 원시 값이냐 참조 값이냐의 차이만 있을 뿐이다. 따라서 자바스크립트에는 \"참조에 의한 전달\"은 존재하지 않고 \"값에 의한 전달\"만이 존재한다고 말할 수 있지만 전달되는 값이 원시 값인지 참조 값인지 구별해 강조하는 의미로 구분해 부른다고 할 수 있다.\n\n","source":"_posts/Modern-Javascript-Deep-Dive-Chapter-11-Summary.md","raw":"---\ntitle: \"[Deep Dive] 원시 값과 객체의 비교\"\ndate: 2022-10-27 16:03:22\ntags:\n- 개발\n- 자바스크립트\n- 모던 자바스크립트 Deep Dive\n---\n# 원시 값 vs 객체 값\n\n앞서 데이터 타입에서 살펴보았듯이 자바스크립트가 제공하는 데이터타입은 크게 원시 타입과 객체 타입으로 구분할 수 있다.\n\n데이터 타입을 원시 타입과 객체 타입으로 구분하는 이유는 무엇일까?\n원시 타입과 객체 타입은 근본적으로 다르다는 의미일 것이다. 원시타입과 객체 타입은 크게 세 가지 측면에서 다르다.\n\n- 원시 타입의 값은 변경 불가능한 값이다. 반면 객체(참조) 타입의 값은 변경 가능한 값이다.\n- 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다. 반면 객체를 변수에 할당하면 변수에는 참조 값이 저장된다.\n- 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달이라고 한다. 반면 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달이라고 한다.\n\n원시 타입과 객체 타입에 대해 조금 더 자세히 살펴보자\n\n## 원시 값\n\n### 변경 불가능한 값\n\n원시 타입의 값은 변경 불가능한 값이다. 다시 말해, 한번 생성된 원시 값은 읽기 전용 값으로 변경할 수 없다.\n\n값을 변경할 수 없다는 것이 어떤 의미일까? 먼저 변수와 값을 정확히 구분해야 한다.\n변수란 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이고, 값이란 변수에 저장된 데이터로 표현식이 평가되어 생성된 결과이다. 값을 변경할 수 없다는 것은 변수에 관한 것이 아닌 값에 대한 진술이다.\n\n즉 원시 값을 변경할 수 없다는 것은 원시 값 자체를 변경할 수 없다는 것이지 변수 값을 변경할 수 없다는 것이 아니다. 변수 값은 재할당을 통해 언제든지 변경 가능하다. 단 상수는 재할당이 금지된 변수이므로 변수 값을 변경할 수 없다.\n\n원시 값은 변경 불가능한 값이므로 데이터의 신뢰성을 보장한다.\n\n변수에서 살펴보았듯이 원시 값을 할당한 변수에 새로운 원시 값을 재할당하면 메모리 공간에 저장되어 있는 재할당 이전의 원시 값을 변경하는 것이 아니라 새로운 메모리 공간을 확보하고 재할당할 값을 저장한 후 변수가 새롭게 재할당한 원시 값을 가리킨다.\n\n변수가 참조하던 메모리 공간의 주소가 변경된 이유는 변수에 할당된 원시 값이 변경 불가능한 값이기 때문이다.\n만약 원시 값이 변경 가능한 값이라면 변수에 새로운 원시 값을 재할당했을 때 변수가 가리키던 메모리 공간의 주소를 바꿀 필요 없이 원시 값 자체를 변경하면 될 것이다.\n\n하지만 원시 값은 불변성을 가지므로 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.\n\n### 값에 의한 전달\n\n```javascript\nvar score = 80;\nvar copy = score;\n\nconsole.log(score); // 80\nconsole.log(copy); // 80\n\nscore = 100;\n\nconsole.log(score); // 100\nconsole.log(copy); // ?\n```\n\nscore 변수에 숫자 값 80을 할당 한 후 copy 변수에 score 변수를 할당했다. 그 후, score 변수에 새로운 숫자 값 100을 재할당하면 copy 변수의 값은 어떻게 될까?\n\n이 질문은 결국 \"변수에 변수를 할당했을 때 무엇이 어떻게 전달되는가?\"이다. copy = score에서 score는 변수 값 80으로 평가되므로 copy 변수에도 80이 할당된다. 이처럼 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시 값이 복사되어 전달되는데 이를 값에 의한 전달이라 한다.\n\nscore 변수와 copy 변수는 숫자 값 80을 갖는다는 점은 동일하지만 score 변수와 copy 변수의 값 80은 다른 메모리 공간에 저장된 별개의 값이다.\n따라서 score변수의 값을 변경하더라도 copy 변수의 값은 어떠한 영향을 주지 않는다. 즉 마지막 `console.log(copy)`의 결과는 80이다.\n\n사실 이는 실제 자바스크립트 엔진의 내부 동작과 정확히 일치하지 않을 수 있다. ECMAScript 사양에는 변수를 통해 메모리를 어떻게 관리해야 하는지 명확하게 정의되어 있지 않다. 따라서 실제 자바스크립트 엔진을 구현하는 제조사에 따라 내부 동작은 차이가 있을 수 있다.\n\n위에서는 변수에 원시 값을 갖는 변수를 할당하면 원시 값이 복사되어 새로운 메모리 공간에 할당한다고 설명했지만, 변수에 원시 값을 갖는 변수를 할당하는 시점에는 두 변수가 같은 원시 값을 참조하다가 어느 한쪽의 변수에 재할당이 이뤄졌을 때 비로소 새로운 메모리 공간에 재할당된 값을 저장하도록 동작할 수도 있다.\n\n또한 엄격히 말하자면 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하기에 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달된다. 따라서 \"값에 의한 전달\"이라는 용어도 사실 오해가 있을 수 있다.\n\n결국 \"값에 의한 전달\"도 사실은 값이 아니라 메모리 주소를 전달한다. 단 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.\n중요한 것은 변수에 원시 값을 갖는 변수를 할당하면 변수 할당 시점이든, 두 변수 중 어느 하나의 변수에 값을 재할당하는 시점이든 결국은 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다는 것이다.\n\n## 객체\n\n객체는 프로퍼티의 개수가 정해져 있지 않으며, 동적으로 추가되고 삭제할 수 있다. 또 프로퍼티의 값에도 제약이 없다.\n즉 객체는 원시 값과는 다르게 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.\n\n따라서 객체는 원시 값과는 다른 방식으로 동작하도록 설계되어 있다. 원시 값과의 차이를 통해 객체에 대해 이해해보자.\n\n### 변경 가능한 값\n\n객체 타입의 값은 변경 가능한 값이다. 이게 어떤 의미일까? 먼저 변수에 객체를 할당하면 어떤 일이 일어나는지 살펴보자\n\n```javascript\nvar person = {\n  name: 'Lee',\n};\n```\n\n원시 값을 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 원시 값에 접근할 수 있다.\n즉, 원시 값을 할당한 변수는 원시 값 자체를 값으로 갖는다. 하지만 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값에 접근할 수 있다. 참조 값은 생성된 객체가 저장된 메모리 공간의 주소이다.\n\n원시 값을 할당한 변수를 참조하면 메모리에 저장되어 있는 원시 값에 접근한다. 하지만 객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조 값을 통해 실제 객체에 접근한다.\n\n원시 값은 변경 불가능한 값이므로 원시 값을 갖는 변수의 값을 변경하려면 재할당 외에는 방법이 없다. 하지만 객체는 변경 가능한 값이므로 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다. 재할당 없이 프로퍼티를 동적으로 추가할 수도 있고 프로퍼티 값을 갱신할 수도 있으며 프로퍼티 자체를 삭제할 수도 있다.\n\n이때 객체를 할당한 변수에 재할당을 하지 않았으므로 객체를 할당한 변수의 참조 값은 변경되지 않는다.\n이는 메모리 사용의 효율성과 성능을 위해 어느 정도의 구조적인 단점을 감안한 설계라고 할 수 있다.\n\n객체는 이러한 구조적 단점에 따른 부작용이 존재한다. 원시 값과는 다르게 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이다.\n\n### 참조에 의한 전달\n\n여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이 무슨 의미인지, 어떤 부작용이 발생하는지 알아보자.\n\n```javascript\nvar person = {\n  name: 'Lee';\n};\n\nvar copy = person;\n```\n\n객체를 가리키는 변수(원본, person)을 다른 변수(사본, copy)에 할당하면 원본의 참조 값이 복사되어 전달되는데 이를 참조에 의한 전달이라 한다.\n\n원본 person과 사본 copy는 저장된 메모리 주소는 다르지만 동일한 참조 값을 가지므로 원본 person과 사본 copy 모두 동일한 객체를 가리키게 된다.\n이것이 두 개의 식별자가 하나의 객체를 공유한다는 것을 의미한다. 따라서 원본 또는 사본 중 어느 한 쪽에서 객체를 변경하면 서로 영향을 주고받는다.\n\n```javascript\nvar person = {\n  name: 'Lee',\n};\n\nvar copy = person;\n\nconsole.log(copy === person); // true\n\ncopy.name = 'Kim';\nperson.address = 'Seoul';\n\n// copy와 person은 동일한 객체를 가리키므로 서로 영향을 주고 받는다.\nconsole.log(person); // {name: 'Kim', address: 'Seoul'}\nconsole.log(copy); // {name: 'Kim', address: 'Seoul'}\n```\n\n결국 \"값에 의한 전달\"과 \"참조에 의한 전달\"은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해 전달한다는 면에서 동일하다.\n다만 식별자가 기억하는 메모리 공간, 즉 변수에 저장되어 있는 값이 원시 값이냐 참조 값이냐의 차이만 있을 뿐이다. 따라서 자바스크립트에는 \"참조에 의한 전달\"은 존재하지 않고 \"값에 의한 전달\"만이 존재한다고 말할 수 있지만 전달되는 값이 원시 값인지 참조 값인지 구별해 강조하는 의미로 구분해 부른다고 할 수 있다.\n\n","slug":"Modern-Javascript-Deep-Dive-Chapter-11-Summary","published":1,"updated":"2022-10-27T07:04:08.743Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb08iq6b0006e4vk771yaaif","content":"<h1 id=\"원시-값-vs-객체-값\"><a href=\"#원시-값-vs-객체-값\" class=\"headerlink\" title=\"원시 값 vs 객체 값\"></a>원시 값 vs 객체 값</h1><p>앞서 데이터 타입에서 살펴보았듯이 자바스크립트가 제공하는 데이터타입은 크게 원시 타입과 객체 타입으로 구분할 수 있다.</p>\n<p>데이터 타입을 원시 타입과 객체 타입으로 구분하는 이유는 무엇일까?<br>원시 타입과 객체 타입은 근본적으로 다르다는 의미일 것이다. 원시타입과 객체 타입은 크게 세 가지 측면에서 다르다.</p>\n<ul>\n<li>원시 타입의 값은 변경 불가능한 값이다. 반면 객체(참조) 타입의 값은 변경 가능한 값이다.</li>\n<li>원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다. 반면 객체를 변수에 할당하면 변수에는 참조 값이 저장된다.</li>\n<li>원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달이라고 한다. 반면 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달이라고 한다.</li>\n</ul>\n<p>원시 타입과 객체 타입에 대해 조금 더 자세히 살펴보자</p>\n<h2 id=\"원시-값\"><a href=\"#원시-값\" class=\"headerlink\" title=\"원시 값\"></a>원시 값</h2><h3 id=\"변경-불가능한-값\"><a href=\"#변경-불가능한-값\" class=\"headerlink\" title=\"변경 불가능한 값\"></a>변경 불가능한 값</h3><p>원시 타입의 값은 변경 불가능한 값이다. 다시 말해, 한번 생성된 원시 값은 읽기 전용 값으로 변경할 수 없다.</p>\n<p>값을 변경할 수 없다는 것이 어떤 의미일까? 먼저 변수와 값을 정확히 구분해야 한다.<br>변수란 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이고, 값이란 변수에 저장된 데이터로 표현식이 평가되어 생성된 결과이다. 값을 변경할 수 없다는 것은 변수에 관한 것이 아닌 값에 대한 진술이다.</p>\n<p>즉 원시 값을 변경할 수 없다는 것은 원시 값 자체를 변경할 수 없다는 것이지 변수 값을 변경할 수 없다는 것이 아니다. 변수 값은 재할당을 통해 언제든지 변경 가능하다. 단 상수는 재할당이 금지된 변수이므로 변수 값을 변경할 수 없다.</p>\n<p>원시 값은 변경 불가능한 값이므로 데이터의 신뢰성을 보장한다.</p>\n<p>변수에서 살펴보았듯이 원시 값을 할당한 변수에 새로운 원시 값을 재할당하면 메모리 공간에 저장되어 있는 재할당 이전의 원시 값을 변경하는 것이 아니라 새로운 메모리 공간을 확보하고 재할당할 값을 저장한 후 변수가 새롭게 재할당한 원시 값을 가리킨다.</p>\n<p>변수가 참조하던 메모리 공간의 주소가 변경된 이유는 변수에 할당된 원시 값이 변경 불가능한 값이기 때문이다.<br>만약 원시 값이 변경 가능한 값이라면 변수에 새로운 원시 값을 재할당했을 때 변수가 가리키던 메모리 공간의 주소를 바꿀 필요 없이 원시 값 자체를 변경하면 될 것이다.</p>\n<p>하지만 원시 값은 불변성을 가지므로 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.</p>\n<h3 id=\"값에-의한-전달\"><a href=\"#값에-의한-전달\" class=\"headerlink\" title=\"값에 의한 전달\"></a>값에 의한 전달</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> score = <span class=\"number\">80</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> copy = score;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(score); <span class=\"comment\">// 80</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(copy); <span class=\"comment\">// 80</span></span><br><span class=\"line\"></span><br><span class=\"line\">score = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(score); <span class=\"comment\">// 100</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(copy); <span class=\"comment\">// ?</span></span><br></pre></td></tr></table></figure>\n\n<p>score 변수에 숫자 값 80을 할당 한 후 copy 변수에 score 변수를 할당했다. 그 후, score 변수에 새로운 숫자 값 100을 재할당하면 copy 변수의 값은 어떻게 될까?</p>\n<p>이 질문은 결국 “변수에 변수를 할당했을 때 무엇이 어떻게 전달되는가?”이다. copy &#x3D; score에서 score는 변수 값 80으로 평가되므로 copy 변수에도 80이 할당된다. 이처럼 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시 값이 복사되어 전달되는데 이를 값에 의한 전달이라 한다.</p>\n<p>score 변수와 copy 변수는 숫자 값 80을 갖는다는 점은 동일하지만 score 변수와 copy 변수의 값 80은 다른 메모리 공간에 저장된 별개의 값이다.<br>따라서 score변수의 값을 변경하더라도 copy 변수의 값은 어떠한 영향을 주지 않는다. 즉 마지막 <code>console.log(copy)</code>의 결과는 80이다.</p>\n<p>사실 이는 실제 자바스크립트 엔진의 내부 동작과 정확히 일치하지 않을 수 있다. ECMAScript 사양에는 변수를 통해 메모리를 어떻게 관리해야 하는지 명확하게 정의되어 있지 않다. 따라서 실제 자바스크립트 엔진을 구현하는 제조사에 따라 내부 동작은 차이가 있을 수 있다.</p>\n<p>위에서는 변수에 원시 값을 갖는 변수를 할당하면 원시 값이 복사되어 새로운 메모리 공간에 할당한다고 설명했지만, 변수에 원시 값을 갖는 변수를 할당하는 시점에는 두 변수가 같은 원시 값을 참조하다가 어느 한쪽의 변수에 재할당이 이뤄졌을 때 비로소 새로운 메모리 공간에 재할당된 값을 저장하도록 동작할 수도 있다.</p>\n<p>또한 엄격히 말하자면 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하기에 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달된다. 따라서 “값에 의한 전달”이라는 용어도 사실 오해가 있을 수 있다.</p>\n<p>결국 “값에 의한 전달”도 사실은 값이 아니라 메모리 주소를 전달한다. 단 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.<br>중요한 것은 변수에 원시 값을 갖는 변수를 할당하면 변수 할당 시점이든, 두 변수 중 어느 하나의 변수에 값을 재할당하는 시점이든 결국은 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다는 것이다.</p>\n<h2 id=\"객체\"><a href=\"#객체\" class=\"headerlink\" title=\"객체\"></a>객체</h2><p>객체는 프로퍼티의 개수가 정해져 있지 않으며, 동적으로 추가되고 삭제할 수 있다. 또 프로퍼티의 값에도 제약이 없다.<br>즉 객체는 원시 값과는 다르게 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.</p>\n<p>따라서 객체는 원시 값과는 다른 방식으로 동작하도록 설계되어 있다. 원시 값과의 차이를 통해 객체에 대해 이해해보자.</p>\n<h3 id=\"변경-가능한-값\"><a href=\"#변경-가능한-값\" class=\"headerlink\" title=\"변경 가능한 값\"></a>변경 가능한 값</h3><p>객체 타입의 값은 변경 가능한 값이다. 이게 어떤 의미일까? 먼저 변수에 객체를 할당하면 어떤 일이 일어나는지 살펴보자</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Lee&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>원시 값을 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 원시 값에 접근할 수 있다.<br>즉, 원시 값을 할당한 변수는 원시 값 자체를 값으로 갖는다. 하지만 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값에 접근할 수 있다. 참조 값은 생성된 객체가 저장된 메모리 공간의 주소이다.</p>\n<p>원시 값을 할당한 변수를 참조하면 메모리에 저장되어 있는 원시 값에 접근한다. 하지만 객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조 값을 통해 실제 객체에 접근한다.</p>\n<p>원시 값은 변경 불가능한 값이므로 원시 값을 갖는 변수의 값을 변경하려면 재할당 외에는 방법이 없다. 하지만 객체는 변경 가능한 값이므로 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다. 재할당 없이 프로퍼티를 동적으로 추가할 수도 있고 프로퍼티 값을 갱신할 수도 있으며 프로퍼티 자체를 삭제할 수도 있다.</p>\n<p>이때 객체를 할당한 변수에 재할당을 하지 않았으므로 객체를 할당한 변수의 참조 값은 변경되지 않는다.<br>이는 메모리 사용의 효율성과 성능을 위해 어느 정도의 구조적인 단점을 감안한 설계라고 할 수 있다.</p>\n<p>객체는 이러한 구조적 단점에 따른 부작용이 존재한다. 원시 값과는 다르게 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이다.</p>\n<h3 id=\"참조에-의한-전달\"><a href=\"#참조에-의한-전달\" class=\"headerlink\" title=\"참조에 의한 전달\"></a>참조에 의한 전달</h3><p>여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이 무슨 의미인지, 어떤 부작용이 발생하는지 알아보자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Lee&#x27;</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> copy = person;</span><br></pre></td></tr></table></figure>\n\n<p>객체를 가리키는 변수(원본, person)을 다른 변수(사본, copy)에 할당하면 원본의 참조 값이 복사되어 전달되는데 이를 참조에 의한 전달이라 한다.</p>\n<p>원본 person과 사본 copy는 저장된 메모리 주소는 다르지만 동일한 참조 값을 가지므로 원본 person과 사본 copy 모두 동일한 객체를 가리키게 된다.<br>이것이 두 개의 식별자가 하나의 객체를 공유한다는 것을 의미한다. 따라서 원본 또는 사본 중 어느 한 쪽에서 객체를 변경하면 서로 영향을 주고받는다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Lee&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> copy = person;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(copy === person); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">copy.<span class=\"property\">name</span> = <span class=\"string\">&#x27;Kim&#x27;</span>;</span><br><span class=\"line\">person.<span class=\"property\">address</span> = <span class=\"string\">&#x27;Seoul&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// copy와 person은 동일한 객체를 가리키므로 서로 영향을 주고 받는다.</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person); <span class=\"comment\">// &#123;name: &#x27;Kim&#x27;, address: &#x27;Seoul&#x27;&#125;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(copy); <span class=\"comment\">// &#123;name: &#x27;Kim&#x27;, address: &#x27;Seoul&#x27;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>결국 “값에 의한 전달”과 “참조에 의한 전달”은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해 전달한다는 면에서 동일하다.<br>다만 식별자가 기억하는 메모리 공간, 즉 변수에 저장되어 있는 값이 원시 값이냐 참조 값이냐의 차이만 있을 뿐이다. 따라서 자바스크립트에는 “참조에 의한 전달”은 존재하지 않고 “값에 의한 전달”만이 존재한다고 말할 수 있지만 전달되는 값이 원시 값인지 참조 값인지 구별해 강조하는 의미로 구분해 부른다고 할 수 있다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"원시-값-vs-객체-값\"><a href=\"#원시-값-vs-객체-값\" class=\"headerlink\" title=\"원시 값 vs 객체 값\"></a>원시 값 vs 객체 값</h1><p>앞서 데이터 타입에서 살펴보았듯이 자바스크립트가 제공하는 데이터타입은 크게 원시 타입과 객체 타입으로 구분할 수 있다.</p>\n<p>데이터 타입을 원시 타입과 객체 타입으로 구분하는 이유는 무엇일까?<br>원시 타입과 객체 타입은 근본적으로 다르다는 의미일 것이다. 원시타입과 객체 타입은 크게 세 가지 측면에서 다르다.</p>\n<ul>\n<li>원시 타입의 값은 변경 불가능한 값이다. 반면 객체(참조) 타입의 값은 변경 가능한 값이다.</li>\n<li>원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다. 반면 객체를 변수에 할당하면 변수에는 참조 값이 저장된다.</li>\n<li>원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달이라고 한다. 반면 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달이라고 한다.</li>\n</ul>\n<p>원시 타입과 객체 타입에 대해 조금 더 자세히 살펴보자</p>\n<h2 id=\"원시-값\"><a href=\"#원시-값\" class=\"headerlink\" title=\"원시 값\"></a>원시 값</h2><h3 id=\"변경-불가능한-값\"><a href=\"#변경-불가능한-값\" class=\"headerlink\" title=\"변경 불가능한 값\"></a>변경 불가능한 값</h3><p>원시 타입의 값은 변경 불가능한 값이다. 다시 말해, 한번 생성된 원시 값은 읽기 전용 값으로 변경할 수 없다.</p>\n<p>값을 변경할 수 없다는 것이 어떤 의미일까? 먼저 변수와 값을 정확히 구분해야 한다.<br>변수란 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이고, 값이란 변수에 저장된 데이터로 표현식이 평가되어 생성된 결과이다. 값을 변경할 수 없다는 것은 변수에 관한 것이 아닌 값에 대한 진술이다.</p>\n<p>즉 원시 값을 변경할 수 없다는 것은 원시 값 자체를 변경할 수 없다는 것이지 변수 값을 변경할 수 없다는 것이 아니다. 변수 값은 재할당을 통해 언제든지 변경 가능하다. 단 상수는 재할당이 금지된 변수이므로 변수 값을 변경할 수 없다.</p>\n<p>원시 값은 변경 불가능한 값이므로 데이터의 신뢰성을 보장한다.</p>\n<p>변수에서 살펴보았듯이 원시 값을 할당한 변수에 새로운 원시 값을 재할당하면 메모리 공간에 저장되어 있는 재할당 이전의 원시 값을 변경하는 것이 아니라 새로운 메모리 공간을 확보하고 재할당할 값을 저장한 후 변수가 새롭게 재할당한 원시 값을 가리킨다.</p>\n<p>변수가 참조하던 메모리 공간의 주소가 변경된 이유는 변수에 할당된 원시 값이 변경 불가능한 값이기 때문이다.<br>만약 원시 값이 변경 가능한 값이라면 변수에 새로운 원시 값을 재할당했을 때 변수가 가리키던 메모리 공간의 주소를 바꿀 필요 없이 원시 값 자체를 변경하면 될 것이다.</p>\n<p>하지만 원시 값은 불변성을 가지므로 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.</p>\n<h3 id=\"값에-의한-전달\"><a href=\"#값에-의한-전달\" class=\"headerlink\" title=\"값에 의한 전달\"></a>값에 의한 전달</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> score = <span class=\"number\">80</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> copy = score;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(score); <span class=\"comment\">// 80</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(copy); <span class=\"comment\">// 80</span></span><br><span class=\"line\"></span><br><span class=\"line\">score = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(score); <span class=\"comment\">// 100</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(copy); <span class=\"comment\">// ?</span></span><br></pre></td></tr></table></figure>\n\n<p>score 변수에 숫자 값 80을 할당 한 후 copy 변수에 score 변수를 할당했다. 그 후, score 변수에 새로운 숫자 값 100을 재할당하면 copy 변수의 값은 어떻게 될까?</p>\n<p>이 질문은 결국 “변수에 변수를 할당했을 때 무엇이 어떻게 전달되는가?”이다. copy &#x3D; score에서 score는 변수 값 80으로 평가되므로 copy 변수에도 80이 할당된다. 이처럼 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시 값이 복사되어 전달되는데 이를 값에 의한 전달이라 한다.</p>\n<p>score 변수와 copy 변수는 숫자 값 80을 갖는다는 점은 동일하지만 score 변수와 copy 변수의 값 80은 다른 메모리 공간에 저장된 별개의 값이다.<br>따라서 score변수의 값을 변경하더라도 copy 변수의 값은 어떠한 영향을 주지 않는다. 즉 마지막 <code>console.log(copy)</code>의 결과는 80이다.</p>\n<p>사실 이는 실제 자바스크립트 엔진의 내부 동작과 정확히 일치하지 않을 수 있다. ECMAScript 사양에는 변수를 통해 메모리를 어떻게 관리해야 하는지 명확하게 정의되어 있지 않다. 따라서 실제 자바스크립트 엔진을 구현하는 제조사에 따라 내부 동작은 차이가 있을 수 있다.</p>\n<p>위에서는 변수에 원시 값을 갖는 변수를 할당하면 원시 값이 복사되어 새로운 메모리 공간에 할당한다고 설명했지만, 변수에 원시 값을 갖는 변수를 할당하는 시점에는 두 변수가 같은 원시 값을 참조하다가 어느 한쪽의 변수에 재할당이 이뤄졌을 때 비로소 새로운 메모리 공간에 재할당된 값을 저장하도록 동작할 수도 있다.</p>\n<p>또한 엄격히 말하자면 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하기에 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달된다. 따라서 “값에 의한 전달”이라는 용어도 사실 오해가 있을 수 있다.</p>\n<p>결국 “값에 의한 전달”도 사실은 값이 아니라 메모리 주소를 전달한다. 단 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.<br>중요한 것은 변수에 원시 값을 갖는 변수를 할당하면 변수 할당 시점이든, 두 변수 중 어느 하나의 변수에 값을 재할당하는 시점이든 결국은 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다는 것이다.</p>\n<h2 id=\"객체\"><a href=\"#객체\" class=\"headerlink\" title=\"객체\"></a>객체</h2><p>객체는 프로퍼티의 개수가 정해져 있지 않으며, 동적으로 추가되고 삭제할 수 있다. 또 프로퍼티의 값에도 제약이 없다.<br>즉 객체는 원시 값과는 다르게 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.</p>\n<p>따라서 객체는 원시 값과는 다른 방식으로 동작하도록 설계되어 있다. 원시 값과의 차이를 통해 객체에 대해 이해해보자.</p>\n<h3 id=\"변경-가능한-값\"><a href=\"#변경-가능한-값\" class=\"headerlink\" title=\"변경 가능한 값\"></a>변경 가능한 값</h3><p>객체 타입의 값은 변경 가능한 값이다. 이게 어떤 의미일까? 먼저 변수에 객체를 할당하면 어떤 일이 일어나는지 살펴보자</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Lee&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>원시 값을 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 원시 값에 접근할 수 있다.<br>즉, 원시 값을 할당한 변수는 원시 값 자체를 값으로 갖는다. 하지만 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값에 접근할 수 있다. 참조 값은 생성된 객체가 저장된 메모리 공간의 주소이다.</p>\n<p>원시 값을 할당한 변수를 참조하면 메모리에 저장되어 있는 원시 값에 접근한다. 하지만 객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조 값을 통해 실제 객체에 접근한다.</p>\n<p>원시 값은 변경 불가능한 값이므로 원시 값을 갖는 변수의 값을 변경하려면 재할당 외에는 방법이 없다. 하지만 객체는 변경 가능한 값이므로 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다. 재할당 없이 프로퍼티를 동적으로 추가할 수도 있고 프로퍼티 값을 갱신할 수도 있으며 프로퍼티 자체를 삭제할 수도 있다.</p>\n<p>이때 객체를 할당한 변수에 재할당을 하지 않았으므로 객체를 할당한 변수의 참조 값은 변경되지 않는다.<br>이는 메모리 사용의 효율성과 성능을 위해 어느 정도의 구조적인 단점을 감안한 설계라고 할 수 있다.</p>\n<p>객체는 이러한 구조적 단점에 따른 부작용이 존재한다. 원시 값과는 다르게 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이다.</p>\n<h3 id=\"참조에-의한-전달\"><a href=\"#참조에-의한-전달\" class=\"headerlink\" title=\"참조에 의한 전달\"></a>참조에 의한 전달</h3><p>여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이 무슨 의미인지, 어떤 부작용이 발생하는지 알아보자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Lee&#x27;</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> copy = person;</span><br></pre></td></tr></table></figure>\n\n<p>객체를 가리키는 변수(원본, person)을 다른 변수(사본, copy)에 할당하면 원본의 참조 값이 복사되어 전달되는데 이를 참조에 의한 전달이라 한다.</p>\n<p>원본 person과 사본 copy는 저장된 메모리 주소는 다르지만 동일한 참조 값을 가지므로 원본 person과 사본 copy 모두 동일한 객체를 가리키게 된다.<br>이것이 두 개의 식별자가 하나의 객체를 공유한다는 것을 의미한다. 따라서 원본 또는 사본 중 어느 한 쪽에서 객체를 변경하면 서로 영향을 주고받는다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Lee&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> copy = person;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(copy === person); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">copy.<span class=\"property\">name</span> = <span class=\"string\">&#x27;Kim&#x27;</span>;</span><br><span class=\"line\">person.<span class=\"property\">address</span> = <span class=\"string\">&#x27;Seoul&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// copy와 person은 동일한 객체를 가리키므로 서로 영향을 주고 받는다.</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person); <span class=\"comment\">// &#123;name: &#x27;Kim&#x27;, address: &#x27;Seoul&#x27;&#125;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(copy); <span class=\"comment\">// &#123;name: &#x27;Kim&#x27;, address: &#x27;Seoul&#x27;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>결국 “값에 의한 전달”과 “참조에 의한 전달”은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해 전달한다는 면에서 동일하다.<br>다만 식별자가 기억하는 메모리 공간, 즉 변수에 저장되어 있는 값이 원시 값이냐 참조 값이냐의 차이만 있을 뿐이다. 따라서 자바스크립트에는 “참조에 의한 전달”은 존재하지 않고 “값에 의한 전달”만이 존재한다고 말할 수 있지만 전달되는 값이 원시 값인지 참조 값인지 구별해 강조하는 의미로 구분해 부른다고 할 수 있다.</p>\n"},{"title":"이미지 스프라이트(Image Sprite)","date":"2022-09-08T14:25:20.000Z","_content":"이미지 스프라이트란 여러 개의 이미지를 하나로 합쳐서 관리하는 이미지를 의미한다.\n\n웹 페이지에 이미지를 사용한다면 웹 브라우저는 해당 이미지의 다운로드를 위해 서버에 요청을 보낸다. 만약 사용된 이미지가 많을 경우 요청 하는 횟수가 많아지므로 웹 페이지의 로딩 시간이 오래 걸리게 된다. 하지만 만약 이미지 스프라이트를 사용한다면 스프라이트 이미지 파일 하나가 여러 이미지를 가지고 있기에 서버 요청 횟수를 줄일 수 있다.\n\n개인적인 블로그와 같은 일반적인 사이트에서는 굳이 이미지 스프라이트를 사용 할 필요가 없지만, 트래픽이 매우 많거나 많은 사람이 이용하는 검색포털과 같은 사이트에서는 이미지 스프라이트를 사용하여 서버 요청을 줄이고 웹 페이지의 로딩 시간을 단축시켜 사이트의 품질을 높일 수 있다.\n\n다음은 네이버 메인페이지의 스프라이트 이미지이다.\n![](https://velog.velcdn.com/images/rjsej12/post/34bfd37f-ea3a-4073-8a76-7c5cfbf8b1fc/image.png)\n\n이처럼 여러개의 이미지를 하나로 합쳐두고 CSS의 `background-position`을 이용해 사용하려는 이미지만을 보여 줄 수 있다. 이 때 `background-position`의 값은 하나씩 position값을 변경해보며 찾을 수 도 있지만 [Sprite Cow](http://www.spritecow.com/)와 같은 사이트를 이용 할 수 있다.\n\n추가적으로 스프라이트 이미지를 만들기 위해 포토샵, 피그마 등으로 에디팅 할 수 도 있지만 [CSS Sprites Generator](https://www.toptal.com/developers/css/sprite-generator/)라는 사이트를 이용 가능하다.\n\n<hr>\n\n# 참고\n- https://creativestudio.kr/1653\n- http://www.tcpschool.com/css/css_basic_imageSprites\n","source":"_posts/Image-Sprite.md","raw":"---\ntitle: 이미지 스프라이트(Image Sprite)\ndate: 2022-09-08 23:25:20\ntags:\n- 개발\n- CSS\n---\n이미지 스프라이트란 여러 개의 이미지를 하나로 합쳐서 관리하는 이미지를 의미한다.\n\n웹 페이지에 이미지를 사용한다면 웹 브라우저는 해당 이미지의 다운로드를 위해 서버에 요청을 보낸다. 만약 사용된 이미지가 많을 경우 요청 하는 횟수가 많아지므로 웹 페이지의 로딩 시간이 오래 걸리게 된다. 하지만 만약 이미지 스프라이트를 사용한다면 스프라이트 이미지 파일 하나가 여러 이미지를 가지고 있기에 서버 요청 횟수를 줄일 수 있다.\n\n개인적인 블로그와 같은 일반적인 사이트에서는 굳이 이미지 스프라이트를 사용 할 필요가 없지만, 트래픽이 매우 많거나 많은 사람이 이용하는 검색포털과 같은 사이트에서는 이미지 스프라이트를 사용하여 서버 요청을 줄이고 웹 페이지의 로딩 시간을 단축시켜 사이트의 품질을 높일 수 있다.\n\n다음은 네이버 메인페이지의 스프라이트 이미지이다.\n![](https://velog.velcdn.com/images/rjsej12/post/34bfd37f-ea3a-4073-8a76-7c5cfbf8b1fc/image.png)\n\n이처럼 여러개의 이미지를 하나로 합쳐두고 CSS의 `background-position`을 이용해 사용하려는 이미지만을 보여 줄 수 있다. 이 때 `background-position`의 값은 하나씩 position값을 변경해보며 찾을 수 도 있지만 [Sprite Cow](http://www.spritecow.com/)와 같은 사이트를 이용 할 수 있다.\n\n추가적으로 스프라이트 이미지를 만들기 위해 포토샵, 피그마 등으로 에디팅 할 수 도 있지만 [CSS Sprites Generator](https://www.toptal.com/developers/css/sprite-generator/)라는 사이트를 이용 가능하다.\n\n<hr>\n\n# 참고\n- https://creativestudio.kr/1653\n- http://www.tcpschool.com/css/css_basic_imageSprites\n","slug":"Image-Sprite","published":1,"updated":"2022-10-10T14:27:00.103Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb08iq6c0008e4vkftaih3k9","content":"<p>이미지 스프라이트란 여러 개의 이미지를 하나로 합쳐서 관리하는 이미지를 의미한다.</p>\n<p>웹 페이지에 이미지를 사용한다면 웹 브라우저는 해당 이미지의 다운로드를 위해 서버에 요청을 보낸다. 만약 사용된 이미지가 많을 경우 요청 하는 횟수가 많아지므로 웹 페이지의 로딩 시간이 오래 걸리게 된다. 하지만 만약 이미지 스프라이트를 사용한다면 스프라이트 이미지 파일 하나가 여러 이미지를 가지고 있기에 서버 요청 횟수를 줄일 수 있다.</p>\n<p>개인적인 블로그와 같은 일반적인 사이트에서는 굳이 이미지 스프라이트를 사용 할 필요가 없지만, 트래픽이 매우 많거나 많은 사람이 이용하는 검색포털과 같은 사이트에서는 이미지 스프라이트를 사용하여 서버 요청을 줄이고 웹 페이지의 로딩 시간을 단축시켜 사이트의 품질을 높일 수 있다.</p>\n<p>다음은 네이버 메인페이지의 스프라이트 이미지이다.<br><img src=\"https://velog.velcdn.com/images/rjsej12/post/34bfd37f-ea3a-4073-8a76-7c5cfbf8b1fc/image.png\"></p>\n<p>이처럼 여러개의 이미지를 하나로 합쳐두고 CSS의 <code>background-position</code>을 이용해 사용하려는 이미지만을 보여 줄 수 있다. 이 때 <code>background-position</code>의 값은 하나씩 position값을 변경해보며 찾을 수 도 있지만 <a href=\"http://www.spritecow.com/\">Sprite Cow</a>와 같은 사이트를 이용 할 수 있다.</p>\n<p>추가적으로 스프라이트 이미지를 만들기 위해 포토샵, 피그마 등으로 에디팅 할 수 도 있지만 <a href=\"https://www.toptal.com/developers/css/sprite-generator/\">CSS Sprites Generator</a>라는 사이트를 이용 가능하다.</p>\n<hr>\n\n<h1 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h1><ul>\n<li><a href=\"https://creativestudio.kr/1653\">https://creativestudio.kr/1653</a></li>\n<li><a href=\"http://www.tcpschool.com/css/css_basic_imageSprites\">http://www.tcpschool.com/css/css_basic_imageSprites</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>이미지 스프라이트란 여러 개의 이미지를 하나로 합쳐서 관리하는 이미지를 의미한다.</p>\n<p>웹 페이지에 이미지를 사용한다면 웹 브라우저는 해당 이미지의 다운로드를 위해 서버에 요청을 보낸다. 만약 사용된 이미지가 많을 경우 요청 하는 횟수가 많아지므로 웹 페이지의 로딩 시간이 오래 걸리게 된다. 하지만 만약 이미지 스프라이트를 사용한다면 스프라이트 이미지 파일 하나가 여러 이미지를 가지고 있기에 서버 요청 횟수를 줄일 수 있다.</p>\n<p>개인적인 블로그와 같은 일반적인 사이트에서는 굳이 이미지 스프라이트를 사용 할 필요가 없지만, 트래픽이 매우 많거나 많은 사람이 이용하는 검색포털과 같은 사이트에서는 이미지 스프라이트를 사용하여 서버 요청을 줄이고 웹 페이지의 로딩 시간을 단축시켜 사이트의 품질을 높일 수 있다.</p>\n<p>다음은 네이버 메인페이지의 스프라이트 이미지이다.<br><img src=\"https://velog.velcdn.com/images/rjsej12/post/34bfd37f-ea3a-4073-8a76-7c5cfbf8b1fc/image.png\"></p>\n<p>이처럼 여러개의 이미지를 하나로 합쳐두고 CSS의 <code>background-position</code>을 이용해 사용하려는 이미지만을 보여 줄 수 있다. 이 때 <code>background-position</code>의 값은 하나씩 position값을 변경해보며 찾을 수 도 있지만 <a href=\"http://www.spritecow.com/\">Sprite Cow</a>와 같은 사이트를 이용 할 수 있다.</p>\n<p>추가적으로 스프라이트 이미지를 만들기 위해 포토샵, 피그마 등으로 에디팅 할 수 도 있지만 <a href=\"https://www.toptal.com/developers/css/sprite-generator/\">CSS Sprites Generator</a>라는 사이트를 이용 가능하다.</p>\n<hr>\n\n<h1 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h1><ul>\n<li><a href=\"https://creativestudio.kr/1653\">https://creativestudio.kr/1653</a></li>\n<li><a href=\"http://www.tcpschool.com/css/css_basic_imageSprites\">http://www.tcpschool.com/css/css_basic_imageSprites</a></li>\n</ul>\n"},{"title":"[Deep Dive] 제어문","date":"2022-10-20T12:26:32.000Z","_content":"# 제어문\n\n제어문은 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용한다.\n일반적으로 코드는 위에서 아래 방향으로 순차적으로 실행된다.\n제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어할 수 있다.\n\n하지만 코드의 실행 순서가 변경되는 것은 코드의 흐름을 혼란스럽게 만들어 가독성을 해치는 단점이 있다.\n가독성이 좋지 않은 코드는 오류를 발생시키는 원인이 되므로 forEach, map, filter, reduce 같은 고차 함수를 사용한 함수형 프로그래밍 기법에서는 제어문의 사용을 억제하여 복잡성을 해결하려고 노력한다.\n\n하지만 제어문을 바르게 이해하는 것은 코딩 스킬에 많은 영향을 준다.\n특히 for 문은 매우 중요하므로 확실히 살펴보도록 하자.\n\n## 블록문\n\n블록문은 0개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라고 부르기도 한다.\n자바스크립트는 블록문을 하나의 실행 단위로 취급한다.\n블록문은 단독으로 사용 가능하나 일반적으로 제어문이나 함수를 정의할 때 사용한다.\n\n문의 끝에는 세미콜론을 붙이는 것이 일반적이나 블록문은 자체 종결성을 갖기 때문에 블록문의 끝에는 세미콜론을 붙이지 않는다.\n\n```javascript\n// 블록문\n{\n  var foo = 10;\n}\n\n// 제어문\nvar x = 1;\nif (x < 10) {\n  x++;\n}\n\n// 함수 선언문\nfunction sum(a, b) {\n  return a + b;\n}\n```\n\n## 조건문\n\n조건문은 주어진 조건식의 평가 결과에 따라 코드 블록의 실행을 결정한다.\n조건식은 불리언 값으로 평가될 수 있는 표현식이다.\n\n자바스크립트는 if...else 문과 switch 문의 두 가지 조건문을 제공한다.\n\n### if...else 문\n\nif...else 문은 주어진 조건식의 평가 결과에 따라 실행할 코드 블록을 결정한다.\n조건식의 평가 결과가 true일 경우 if 문의 코드 블록이 실행되고 false일 경우 else 문의 코드 블록이 실행된다.\n\n<pre>\nif (조건식) {\n  // 조건식이 참이면 이 코드 블록이 실행\n} else {\n  // 조건식이 거짓이면 이 코드 블록이 실행\n}\n</pre>\n\nif 문의 조건식은 불리언 값으로 평가되어야 한다. 만약 if 문의 조건식이 불리언 값이 아닌 값으로 평가되면 자바스크립트 엔진에 의해 암묵적으로 불리언 값으로 강제 변환되어 실행할 코드 블록을 결정한다.\n\n만약 코드 블록 내의 문이 하나라면 중괄호를 생략할 수 있다.\n\n```javascript\nvar num = 2;\nvar kind;\n\nif (num > 0) kind = '양수';\nelse if (num < 0) kind = '음수';\nelse kind = '영';\n\nconsole.log(kind); // 양수\n```\n\n대부분의 if...else 문은 삼항 조건 연산자로 바꿔 쓸 수 있다.\n연산자에서도 살펴보았듯이 조건에 따라 단순히 값을 결정하여 변수에 할당하는 경우 if...else 문보다 삼항 조건 연산자를 사용하는 편이 가독성이 좋다.\n하지만 조건에 따라 실행해야 할 내용이 복잡하여 여러 줄의 문이 필요하다면 if...else 문을 사용하는 편이 가독성이 좋다.\n\n### switch 문\n\nswitch 문은 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 흐름을 옮긴다.\ncase 문은 상황을 의미하는 표현식을 지정하고 콜론으로 마친다. 그리고 그 뒤에 실행할 문들을 위치시킨다.\n\nswitch 문의 표현식과 일치하는 case 문이 없다면 실행 순서는 default 문으로 이동한다. default 문은 선택사항이다.\n\n<pre>\nswitch (표현식) {\n case 표현식1:\n  switch 문의 표현식과 표현식 1이 일치하면 실행될 문;\n  break;\n case 표현식2:\n  switch 문의 표현식과 표현식 2가 일치하면 실행될 문;\n  break;\n default:\n  switch 문의 표현식과 일치하는 case 문이 없을 때 실행될 문;\n}\n</pre>\n\nif...else 문의 조건식은 불리언 값으로 평가되어야 하지만 switch 문의 표현식은 불리언 값보다는 문자열이나 숫자 값인 경우가 많다.\n즉 switch 문은 논리적 참, 거짓보다는 다양한 상황(case)에 따라 실행할 코드 블록을 결정할 때 사용한다.\n\nswtich 문은 case, default, break 등 다양한 키워드를 사용해야 하고 폴스루가 발생한느 등 문법도 복잡하다.\n따라서 C 언어를 기반으로 하는 프로그래밍 언어는 대부분 switch 문을 지원하지만 파이썬과 같이 switch 문ㅇ을 지원하지 않는 프로그래밍 언어도 있다.\n\n만약 if...else 문으로 해결할 수 있다면 switch 문보다 if...else 문을 사용하는 편이 좋다.\n하지만 조건이 너무 많아 if...else 문보다 switch 문을 사용했을 때 가독성이 더 좋다면 switch문을 사용하는 편이 좋다.\n\n## 반복문\n\n반복문은 조건식의 평가 결과가 참인 경우 코드 블록을 실행한다. 그 후 조건식을 다시 평가하여 여전히 참인 경우 코드 블록을 다시 실행한다.\n이는 조건식이 거짓일 때까지 반복된다.\n\n자바스크립트는 for 문, while 문, do...while 문의 세 가지 반복문을 제공한다\n\n### for 문\n\nfor 문은 조건식이 거짓으로 평가될 때까지 코드 블록을 반복 실행한다. 가장 일반적으로 사용되는 for 문의 형태는 다음과 같다.\n\n<pre>\nfor (변수 선언문 또는 할당문; 조건식; 증감식) {\n 조건식이 참인 경우 반복 실행될 문;\n}\n</pre>\n\nfor 문은 매우 중요하므로 어떻게 동작하는지 많은 연습을 통해 확실히 이해해야 한다.\n\nfor 문의 변수 선언문, 조건식, 증감식은 모두 옵션이므로 반드시 사용할 필요는 없다. 단, 어떤 식도 선언하지 않으면 무한루프가 된다.\n\n```javascript\nfor (;;) {...} // 무한루프\n```\n\nfor 문 내에 for 문을 중첩해 사용할 수 있다. 이를 중첩 for 문이라 한다. 다음은 두 개의 주사위를 던졌을 때 두 눈의 합이 6이 되는 모든 경우의 수를 출력하기 위해 이중 중첩 for 문을 사용한 예다.\n\n```javascript\nfor (var i = 1; i <= 6; i++) {\n  for (var j = 1; j <= 6; j++) {\n    if (i + j === 6) console.log(`[${i}, ${j}]`);\n  }\n}\n// [1, 5] [2, 4] [3, 3] [4, 2] [5, 1]\n```\n\n### while 문\n\nwhile 문은 주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복 실행한다.\nfor 문은 반복 횟수가 명확할 때 주로 사용하고 while 문은 반복 횟수가 불명확할 때 주로 사용한다.\n\nwhile 문은 조건문의 평가 결과가 거짓이 되면 코드 블록을 실행하지 않고 종료한다. 만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 강제 변환하여 논리적 참, 거짓을 구별한다.\n\n```javascript\nvar count = 0;\n\nwhile (count < 3) {\n  console.log(count); // 0 1 2\n  count++;\n}\n```\n\n조건식의 평가 결과가 언제나 참이면 무한루프가 된다.\n무한루프에서 탈출하기 위해서는 코드 블록 내에 if 문으로 탈출 조건을 만들고 break 문으로 코드 블록을 탈출한다.\n\n```javascript\nvar count = 0;\n\n// 무한루프\nwhile (true) {\n  console.log(count); // 0 1 2\n  count++;\n\n  if (count === 3) break;\n}\n```\n\n### do...while 문\n\ndo...while 문은 코드 블록을 먼저 실행하고 조건식을 평가한다. 따라서 코드 블록은 무조건 한 번 이상 실행된다.\n\n```javascript\nvar count = 0;\n\ndo {\n  console.log(count); // 0 1 2\n  count++;\n} while (count < 3);\n```\n\n## break 문\n\nswitch 문과 while 문에서 살펴보았듯이 break 문은 코드 블록을 탈출한다.\n더 정확히 말하자면 레이블 문, 반복문 또는 switch 문의 코드 블록을 탈출한다. 레이블 문, 반복문, switch 문의 코드 블록 외에 break 문을 사용하면 SyntaxError가 발생한다.\n\n```javascript\nif (true) {\n  break; // Uncaught SyntaxError: Illegal break statement\n}\n```\n\n> 참고로 레이블 문은 식별자가 붙은 문을 말한다.\n> 레이블 문은 프로그램의 실행 순서를 제어하는데 사용한다. 사실 switch 문의 case 문과 default 문 역시 레이블 문이다.\n> 레이블 문을 탈출하려면 break 문에 레이블 식별자를 지정한다.\n>\n> ```javascript\n> foo: {\n>   console.log(1);\n>   break foo;\n>   console.log(2);\n> }\n>\n> console.log('Done!');\n> // 1\n> // Done!\n> ```\n>\n> 레이블 문을 사용하면 프로그램의 흐름이 복잡해져서 가독성이 나빠지고 오류를 발생시킬 가능성이 높아지기 때문에 일반적으로 권장하지 않는다.\n\n## continue 문\n\ncontinue 문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다.\nbreak 문처럼 반복문을 탈출하지는 않는다.\n\n다음은 문자열에서 특정 문자의 개수를 세는 예다.\n\n```javascript\nvar string = 'Hello World.';\nvar search = 'l';\nvar count = 0;\n\nfor (var i = 0; i < string.length; i++) {\n  if (string[i] !== search) continue; // 'l'이 아니면 현 지점에서 실행을 중단하고 반복문의 증감식으로 이동한다.\n  count++; // continue 문이 실행되면 이 문은 실행되지 않는다.\n}\n\nconsole.log(count); // 3\n```\n\n","source":"_posts/Modern-JavaScript-Deep-Dive-Chapter-8-Control-Flow-Statement.md","raw":"---\ntitle: \"[Deep Dive] 제어문\"\ndate: 2022-10-20 21:26:32\ntags:\n- 개발\n- 자바스크립트\n- 모던 자바스크립트 Deep Dive\n---\n# 제어문\n\n제어문은 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용한다.\n일반적으로 코드는 위에서 아래 방향으로 순차적으로 실행된다.\n제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어할 수 있다.\n\n하지만 코드의 실행 순서가 변경되는 것은 코드의 흐름을 혼란스럽게 만들어 가독성을 해치는 단점이 있다.\n가독성이 좋지 않은 코드는 오류를 발생시키는 원인이 되므로 forEach, map, filter, reduce 같은 고차 함수를 사용한 함수형 프로그래밍 기법에서는 제어문의 사용을 억제하여 복잡성을 해결하려고 노력한다.\n\n하지만 제어문을 바르게 이해하는 것은 코딩 스킬에 많은 영향을 준다.\n특히 for 문은 매우 중요하므로 확실히 살펴보도록 하자.\n\n## 블록문\n\n블록문은 0개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라고 부르기도 한다.\n자바스크립트는 블록문을 하나의 실행 단위로 취급한다.\n블록문은 단독으로 사용 가능하나 일반적으로 제어문이나 함수를 정의할 때 사용한다.\n\n문의 끝에는 세미콜론을 붙이는 것이 일반적이나 블록문은 자체 종결성을 갖기 때문에 블록문의 끝에는 세미콜론을 붙이지 않는다.\n\n```javascript\n// 블록문\n{\n  var foo = 10;\n}\n\n// 제어문\nvar x = 1;\nif (x < 10) {\n  x++;\n}\n\n// 함수 선언문\nfunction sum(a, b) {\n  return a + b;\n}\n```\n\n## 조건문\n\n조건문은 주어진 조건식의 평가 결과에 따라 코드 블록의 실행을 결정한다.\n조건식은 불리언 값으로 평가될 수 있는 표현식이다.\n\n자바스크립트는 if...else 문과 switch 문의 두 가지 조건문을 제공한다.\n\n### if...else 문\n\nif...else 문은 주어진 조건식의 평가 결과에 따라 실행할 코드 블록을 결정한다.\n조건식의 평가 결과가 true일 경우 if 문의 코드 블록이 실행되고 false일 경우 else 문의 코드 블록이 실행된다.\n\n<pre>\nif (조건식) {\n  // 조건식이 참이면 이 코드 블록이 실행\n} else {\n  // 조건식이 거짓이면 이 코드 블록이 실행\n}\n</pre>\n\nif 문의 조건식은 불리언 값으로 평가되어야 한다. 만약 if 문의 조건식이 불리언 값이 아닌 값으로 평가되면 자바스크립트 엔진에 의해 암묵적으로 불리언 값으로 강제 변환되어 실행할 코드 블록을 결정한다.\n\n만약 코드 블록 내의 문이 하나라면 중괄호를 생략할 수 있다.\n\n```javascript\nvar num = 2;\nvar kind;\n\nif (num > 0) kind = '양수';\nelse if (num < 0) kind = '음수';\nelse kind = '영';\n\nconsole.log(kind); // 양수\n```\n\n대부분의 if...else 문은 삼항 조건 연산자로 바꿔 쓸 수 있다.\n연산자에서도 살펴보았듯이 조건에 따라 단순히 값을 결정하여 변수에 할당하는 경우 if...else 문보다 삼항 조건 연산자를 사용하는 편이 가독성이 좋다.\n하지만 조건에 따라 실행해야 할 내용이 복잡하여 여러 줄의 문이 필요하다면 if...else 문을 사용하는 편이 가독성이 좋다.\n\n### switch 문\n\nswitch 문은 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 흐름을 옮긴다.\ncase 문은 상황을 의미하는 표현식을 지정하고 콜론으로 마친다. 그리고 그 뒤에 실행할 문들을 위치시킨다.\n\nswitch 문의 표현식과 일치하는 case 문이 없다면 실행 순서는 default 문으로 이동한다. default 문은 선택사항이다.\n\n<pre>\nswitch (표현식) {\n case 표현식1:\n  switch 문의 표현식과 표현식 1이 일치하면 실행될 문;\n  break;\n case 표현식2:\n  switch 문의 표현식과 표현식 2가 일치하면 실행될 문;\n  break;\n default:\n  switch 문의 표현식과 일치하는 case 문이 없을 때 실행될 문;\n}\n</pre>\n\nif...else 문의 조건식은 불리언 값으로 평가되어야 하지만 switch 문의 표현식은 불리언 값보다는 문자열이나 숫자 값인 경우가 많다.\n즉 switch 문은 논리적 참, 거짓보다는 다양한 상황(case)에 따라 실행할 코드 블록을 결정할 때 사용한다.\n\nswtich 문은 case, default, break 등 다양한 키워드를 사용해야 하고 폴스루가 발생한느 등 문법도 복잡하다.\n따라서 C 언어를 기반으로 하는 프로그래밍 언어는 대부분 switch 문을 지원하지만 파이썬과 같이 switch 문ㅇ을 지원하지 않는 프로그래밍 언어도 있다.\n\n만약 if...else 문으로 해결할 수 있다면 switch 문보다 if...else 문을 사용하는 편이 좋다.\n하지만 조건이 너무 많아 if...else 문보다 switch 문을 사용했을 때 가독성이 더 좋다면 switch문을 사용하는 편이 좋다.\n\n## 반복문\n\n반복문은 조건식의 평가 결과가 참인 경우 코드 블록을 실행한다. 그 후 조건식을 다시 평가하여 여전히 참인 경우 코드 블록을 다시 실행한다.\n이는 조건식이 거짓일 때까지 반복된다.\n\n자바스크립트는 for 문, while 문, do...while 문의 세 가지 반복문을 제공한다\n\n### for 문\n\nfor 문은 조건식이 거짓으로 평가될 때까지 코드 블록을 반복 실행한다. 가장 일반적으로 사용되는 for 문의 형태는 다음과 같다.\n\n<pre>\nfor (변수 선언문 또는 할당문; 조건식; 증감식) {\n 조건식이 참인 경우 반복 실행될 문;\n}\n</pre>\n\nfor 문은 매우 중요하므로 어떻게 동작하는지 많은 연습을 통해 확실히 이해해야 한다.\n\nfor 문의 변수 선언문, 조건식, 증감식은 모두 옵션이므로 반드시 사용할 필요는 없다. 단, 어떤 식도 선언하지 않으면 무한루프가 된다.\n\n```javascript\nfor (;;) {...} // 무한루프\n```\n\nfor 문 내에 for 문을 중첩해 사용할 수 있다. 이를 중첩 for 문이라 한다. 다음은 두 개의 주사위를 던졌을 때 두 눈의 합이 6이 되는 모든 경우의 수를 출력하기 위해 이중 중첩 for 문을 사용한 예다.\n\n```javascript\nfor (var i = 1; i <= 6; i++) {\n  for (var j = 1; j <= 6; j++) {\n    if (i + j === 6) console.log(`[${i}, ${j}]`);\n  }\n}\n// [1, 5] [2, 4] [3, 3] [4, 2] [5, 1]\n```\n\n### while 문\n\nwhile 문은 주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복 실행한다.\nfor 문은 반복 횟수가 명확할 때 주로 사용하고 while 문은 반복 횟수가 불명확할 때 주로 사용한다.\n\nwhile 문은 조건문의 평가 결과가 거짓이 되면 코드 블록을 실행하지 않고 종료한다. 만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 강제 변환하여 논리적 참, 거짓을 구별한다.\n\n```javascript\nvar count = 0;\n\nwhile (count < 3) {\n  console.log(count); // 0 1 2\n  count++;\n}\n```\n\n조건식의 평가 결과가 언제나 참이면 무한루프가 된다.\n무한루프에서 탈출하기 위해서는 코드 블록 내에 if 문으로 탈출 조건을 만들고 break 문으로 코드 블록을 탈출한다.\n\n```javascript\nvar count = 0;\n\n// 무한루프\nwhile (true) {\n  console.log(count); // 0 1 2\n  count++;\n\n  if (count === 3) break;\n}\n```\n\n### do...while 문\n\ndo...while 문은 코드 블록을 먼저 실행하고 조건식을 평가한다. 따라서 코드 블록은 무조건 한 번 이상 실행된다.\n\n```javascript\nvar count = 0;\n\ndo {\n  console.log(count); // 0 1 2\n  count++;\n} while (count < 3);\n```\n\n## break 문\n\nswitch 문과 while 문에서 살펴보았듯이 break 문은 코드 블록을 탈출한다.\n더 정확히 말하자면 레이블 문, 반복문 또는 switch 문의 코드 블록을 탈출한다. 레이블 문, 반복문, switch 문의 코드 블록 외에 break 문을 사용하면 SyntaxError가 발생한다.\n\n```javascript\nif (true) {\n  break; // Uncaught SyntaxError: Illegal break statement\n}\n```\n\n> 참고로 레이블 문은 식별자가 붙은 문을 말한다.\n> 레이블 문은 프로그램의 실행 순서를 제어하는데 사용한다. 사실 switch 문의 case 문과 default 문 역시 레이블 문이다.\n> 레이블 문을 탈출하려면 break 문에 레이블 식별자를 지정한다.\n>\n> ```javascript\n> foo: {\n>   console.log(1);\n>   break foo;\n>   console.log(2);\n> }\n>\n> console.log('Done!');\n> // 1\n> // Done!\n> ```\n>\n> 레이블 문을 사용하면 프로그램의 흐름이 복잡해져서 가독성이 나빠지고 오류를 발생시킬 가능성이 높아지기 때문에 일반적으로 권장하지 않는다.\n\n## continue 문\n\ncontinue 문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다.\nbreak 문처럼 반복문을 탈출하지는 않는다.\n\n다음은 문자열에서 특정 문자의 개수를 세는 예다.\n\n```javascript\nvar string = 'Hello World.';\nvar search = 'l';\nvar count = 0;\n\nfor (var i = 0; i < string.length; i++) {\n  if (string[i] !== search) continue; // 'l'이 아니면 현 지점에서 실행을 중단하고 반복문의 증감식으로 이동한다.\n  count++; // continue 문이 실행되면 이 문은 실행되지 않는다.\n}\n\nconsole.log(count); // 3\n```\n\n","slug":"Modern-JavaScript-Deep-Dive-Chapter-8-Control-Flow-Statement","published":1,"updated":"2022-10-20T12:35:12.188Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb08iq6d0009e4vkgn798aqz","content":"<h1 id=\"제어문\"><a href=\"#제어문\" class=\"headerlink\" title=\"제어문\"></a>제어문</h1><p>제어문은 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용한다.<br>일반적으로 코드는 위에서 아래 방향으로 순차적으로 실행된다.<br>제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어할 수 있다.</p>\n<p>하지만 코드의 실행 순서가 변경되는 것은 코드의 흐름을 혼란스럽게 만들어 가독성을 해치는 단점이 있다.<br>가독성이 좋지 않은 코드는 오류를 발생시키는 원인이 되므로 forEach, map, filter, reduce 같은 고차 함수를 사용한 함수형 프로그래밍 기법에서는 제어문의 사용을 억제하여 복잡성을 해결하려고 노력한다.</p>\n<p>하지만 제어문을 바르게 이해하는 것은 코딩 스킬에 많은 영향을 준다.<br>특히 for 문은 매우 중요하므로 확실히 살펴보도록 하자.</p>\n<h2 id=\"블록문\"><a href=\"#블록문\" class=\"headerlink\" title=\"블록문\"></a>블록문</h2><p>블록문은 0개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라고 부르기도 한다.<br>자바스크립트는 블록문을 하나의 실행 단위로 취급한다.<br>블록문은 단독으로 사용 가능하나 일반적으로 제어문이나 함수를 정의할 때 사용한다.</p>\n<p>문의 끝에는 세미콜론을 붙이는 것이 일반적이나 블록문은 자체 종결성을 갖기 때문에 블록문의 끝에는 세미콜론을 붙이지 않는다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 블록문</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> foo = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 제어문</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (x &lt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">  x++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 함수 선언문</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sum</span>(<span class=\"params\">a, b</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"조건문\"><a href=\"#조건문\" class=\"headerlink\" title=\"조건문\"></a>조건문</h2><p>조건문은 주어진 조건식의 평가 결과에 따라 코드 블록의 실행을 결정한다.<br>조건식은 불리언 값으로 평가될 수 있는 표현식이다.</p>\n<p>자바스크립트는 if…else 문과 switch 문의 두 가지 조건문을 제공한다.</p>\n<h3 id=\"if…else-문\"><a href=\"#if…else-문\" class=\"headerlink\" title=\"if…else 문\"></a>if…else 문</h3><p>if…else 문은 주어진 조건식의 평가 결과에 따라 실행할 코드 블록을 결정한다.<br>조건식의 평가 결과가 true일 경우 if 문의 코드 블록이 실행되고 false일 경우 else 문의 코드 블록이 실행된다.</p>\n<pre>\nif (조건식) {\n  // 조건식이 참이면 이 코드 블록이 실행\n} else {\n  // 조건식이 거짓이면 이 코드 블록이 실행\n}\n</pre>\n\n<p>if 문의 조건식은 불리언 값으로 평가되어야 한다. 만약 if 문의 조건식이 불리언 값이 아닌 값으로 평가되면 자바스크립트 엔진에 의해 암묵적으로 불리언 값으로 강제 변환되어 실행할 코드 블록을 결정한다.</p>\n<p>만약 코드 블록 내의 문이 하나라면 중괄호를 생략할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> kind;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (num &gt; <span class=\"number\">0</span>) kind = <span class=\"string\">&#x27;양수&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (num &lt; <span class=\"number\">0</span>) kind = <span class=\"string\">&#x27;음수&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">else</span> kind = <span class=\"string\">&#x27;영&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(kind); <span class=\"comment\">// 양수</span></span><br></pre></td></tr></table></figure>\n\n<p>대부분의 if…else 문은 삼항 조건 연산자로 바꿔 쓸 수 있다.<br>연산자에서도 살펴보았듯이 조건에 따라 단순히 값을 결정하여 변수에 할당하는 경우 if…else 문보다 삼항 조건 연산자를 사용하는 편이 가독성이 좋다.<br>하지만 조건에 따라 실행해야 할 내용이 복잡하여 여러 줄의 문이 필요하다면 if…else 문을 사용하는 편이 가독성이 좋다.</p>\n<h3 id=\"switch-문\"><a href=\"#switch-문\" class=\"headerlink\" title=\"switch 문\"></a>switch 문</h3><p>switch 문은 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 흐름을 옮긴다.<br>case 문은 상황을 의미하는 표현식을 지정하고 콜론으로 마친다. 그리고 그 뒤에 실행할 문들을 위치시킨다.</p>\n<p>switch 문의 표현식과 일치하는 case 문이 없다면 실행 순서는 default 문으로 이동한다. default 문은 선택사항이다.</p>\n<pre>\nswitch (표현식) {\n case 표현식1:\n  switch 문의 표현식과 표현식 1이 일치하면 실행될 문;\n  break;\n case 표현식2:\n  switch 문의 표현식과 표현식 2가 일치하면 실행될 문;\n  break;\n default:\n  switch 문의 표현식과 일치하는 case 문이 없을 때 실행될 문;\n}\n</pre>\n\n<p>if…else 문의 조건식은 불리언 값으로 평가되어야 하지만 switch 문의 표현식은 불리언 값보다는 문자열이나 숫자 값인 경우가 많다.<br>즉 switch 문은 논리적 참, 거짓보다는 다양한 상황(case)에 따라 실행할 코드 블록을 결정할 때 사용한다.</p>\n<p>swtich 문은 case, default, break 등 다양한 키워드를 사용해야 하고 폴스루가 발생한느 등 문법도 복잡하다.<br>따라서 C 언어를 기반으로 하는 프로그래밍 언어는 대부분 switch 문을 지원하지만 파이썬과 같이 switch 문ㅇ을 지원하지 않는 프로그래밍 언어도 있다.</p>\n<p>만약 if…else 문으로 해결할 수 있다면 switch 문보다 if…else 문을 사용하는 편이 좋다.<br>하지만 조건이 너무 많아 if…else 문보다 switch 문을 사용했을 때 가독성이 더 좋다면 switch문을 사용하는 편이 좋다.</p>\n<h2 id=\"반복문\"><a href=\"#반복문\" class=\"headerlink\" title=\"반복문\"></a>반복문</h2><p>반복문은 조건식의 평가 결과가 참인 경우 코드 블록을 실행한다. 그 후 조건식을 다시 평가하여 여전히 참인 경우 코드 블록을 다시 실행한다.<br>이는 조건식이 거짓일 때까지 반복된다.</p>\n<p>자바스크립트는 for 문, while 문, do…while 문의 세 가지 반복문을 제공한다</p>\n<h3 id=\"for-문\"><a href=\"#for-문\" class=\"headerlink\" title=\"for 문\"></a>for 문</h3><p>for 문은 조건식이 거짓으로 평가될 때까지 코드 블록을 반복 실행한다. 가장 일반적으로 사용되는 for 문의 형태는 다음과 같다.</p>\n<pre>\nfor (변수 선언문 또는 할당문; 조건식; 증감식) {\n 조건식이 참인 경우 반복 실행될 문;\n}\n</pre>\n\n<p>for 문은 매우 중요하므로 어떻게 동작하는지 많은 연습을 통해 확실히 이해해야 한다.</p>\n<p>for 문의 변수 선언문, 조건식, 증감식은 모두 옵션이므로 반드시 사용할 필요는 없다. 단, 어떤 식도 선언하지 않으면 무한루프가 된다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (;;) &#123;...&#125; <span class=\"comment\">// 무한루프</span></span><br></pre></td></tr></table></figure>\n\n<p>for 문 내에 for 문을 중첩해 사용할 수 있다. 이를 중첩 for 문이라 한다. 다음은 두 개의 주사위를 던졌을 때 두 눈의 합이 6이 되는 모든 경우의 수를 출력하기 위해 이중 중첩 for 문을 사용한 예다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">6</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">1</span>; j &lt;= <span class=\"number\">6</span>; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i + j === <span class=\"number\">6</span>) <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`[<span class=\"subst\">$&#123;i&#125;</span>, <span class=\"subst\">$&#123;j&#125;</span>]`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// [1, 5] [2, 4] [3, 3] [4, 2] [5, 1]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"while-문\"><a href=\"#while-문\" class=\"headerlink\" title=\"while 문\"></a>while 문</h3><p>while 문은 주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복 실행한다.<br>for 문은 반복 횟수가 명확할 때 주로 사용하고 while 문은 반복 횟수가 불명확할 때 주로 사용한다.</p>\n<p>while 문은 조건문의 평가 결과가 거짓이 되면 코드 블록을 실행하지 않고 종료한다. 만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 강제 변환하여 논리적 참, 거짓을 구별한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> (count &lt; <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(count); <span class=\"comment\">// 0 1 2</span></span><br><span class=\"line\">  count++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>조건식의 평가 결과가 언제나 참이면 무한루프가 된다.<br>무한루프에서 탈출하기 위해서는 코드 블록 내에 if 문으로 탈출 조건을 만들고 break 문으로 코드 블록을 탈출한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 무한루프</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(count); <span class=\"comment\">// 0 1 2</span></span><br><span class=\"line\">  count++;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (count === <span class=\"number\">3</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"do…while-문\"><a href=\"#do…while-문\" class=\"headerlink\" title=\"do…while 문\"></a>do…while 문</h3><p>do…while 문은 코드 블록을 먼저 실행하고 조건식을 평가한다. 따라서 코드 블록은 무조건 한 번 이상 실행된다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(count); <span class=\"comment\">// 0 1 2</span></span><br><span class=\"line\">  count++;</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> (count &lt; <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"break-문\"><a href=\"#break-문\" class=\"headerlink\" title=\"break 문\"></a>break 문</h2><p>switch 문과 while 문에서 살펴보았듯이 break 문은 코드 블록을 탈출한다.<br>더 정확히 말하자면 레이블 문, 반복문 또는 switch 문의 코드 블록을 탈출한다. 레이블 문, 반복문, switch 문의 코드 블록 외에 break 문을 사용하면 SyntaxError가 발생한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">break</span>; <span class=\"comment\">// Uncaught SyntaxError: Illegal break statement</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>참고로 레이블 문은 식별자가 붙은 문을 말한다.<br>레이블 문은 프로그램의 실행 순서를 제어하는데 사용한다. 사실 switch 문의 case 문과 default 문 역시 레이블 문이다.<br>레이블 문을 탈출하려면 break 문에 레이블 식별자를 지정한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">foo</span>: &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">break</span> foo;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Done!&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// Done!</span></span><br></pre></td></tr></table></figure>\n\n<p>레이블 문을 사용하면 프로그램의 흐름이 복잡해져서 가독성이 나빠지고 오류를 발생시킬 가능성이 높아지기 때문에 일반적으로 권장하지 않는다.</p>\n</blockquote>\n<h2 id=\"continue-문\"><a href=\"#continue-문\" class=\"headerlink\" title=\"continue 문\"></a>continue 문</h2><p>continue 문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다.<br>break 문처럼 반복문을 탈출하지는 않는다.</p>\n<p>다음은 문자열에서 특정 문자의 개수를 세는 예다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">&#x27;Hello World.&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> search = <span class=\"string\">&#x27;l&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; string.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (string[i] !== search) <span class=\"keyword\">continue</span>; <span class=\"comment\">// &#x27;l&#x27;이 아니면 현 지점에서 실행을 중단하고 반복문의 증감식으로 이동한다.</span></span><br><span class=\"line\">  count++; <span class=\"comment\">// continue 문이 실행되면 이 문은 실행되지 않는다.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(count); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"제어문\"><a href=\"#제어문\" class=\"headerlink\" title=\"제어문\"></a>제어문</h1><p>제어문은 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용한다.<br>일반적으로 코드는 위에서 아래 방향으로 순차적으로 실행된다.<br>제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어할 수 있다.</p>\n<p>하지만 코드의 실행 순서가 변경되는 것은 코드의 흐름을 혼란스럽게 만들어 가독성을 해치는 단점이 있다.<br>가독성이 좋지 않은 코드는 오류를 발생시키는 원인이 되므로 forEach, map, filter, reduce 같은 고차 함수를 사용한 함수형 프로그래밍 기법에서는 제어문의 사용을 억제하여 복잡성을 해결하려고 노력한다.</p>\n<p>하지만 제어문을 바르게 이해하는 것은 코딩 스킬에 많은 영향을 준다.<br>특히 for 문은 매우 중요하므로 확실히 살펴보도록 하자.</p>\n<h2 id=\"블록문\"><a href=\"#블록문\" class=\"headerlink\" title=\"블록문\"></a>블록문</h2><p>블록문은 0개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라고 부르기도 한다.<br>자바스크립트는 블록문을 하나의 실행 단위로 취급한다.<br>블록문은 단독으로 사용 가능하나 일반적으로 제어문이나 함수를 정의할 때 사용한다.</p>\n<p>문의 끝에는 세미콜론을 붙이는 것이 일반적이나 블록문은 자체 종결성을 갖기 때문에 블록문의 끝에는 세미콜론을 붙이지 않는다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 블록문</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> foo = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 제어문</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (x &lt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">  x++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 함수 선언문</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sum</span>(<span class=\"params\">a, b</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"조건문\"><a href=\"#조건문\" class=\"headerlink\" title=\"조건문\"></a>조건문</h2><p>조건문은 주어진 조건식의 평가 결과에 따라 코드 블록의 실행을 결정한다.<br>조건식은 불리언 값으로 평가될 수 있는 표현식이다.</p>\n<p>자바스크립트는 if…else 문과 switch 문의 두 가지 조건문을 제공한다.</p>\n<h3 id=\"if…else-문\"><a href=\"#if…else-문\" class=\"headerlink\" title=\"if…else 문\"></a>if…else 문</h3><p>if…else 문은 주어진 조건식의 평가 결과에 따라 실행할 코드 블록을 결정한다.<br>조건식의 평가 결과가 true일 경우 if 문의 코드 블록이 실행되고 false일 경우 else 문의 코드 블록이 실행된다.</p>\n<pre>\nif (조건식) {\n  // 조건식이 참이면 이 코드 블록이 실행\n} else {\n  // 조건식이 거짓이면 이 코드 블록이 실행\n}\n</pre>\n\n<p>if 문의 조건식은 불리언 값으로 평가되어야 한다. 만약 if 문의 조건식이 불리언 값이 아닌 값으로 평가되면 자바스크립트 엔진에 의해 암묵적으로 불리언 값으로 강제 변환되어 실행할 코드 블록을 결정한다.</p>\n<p>만약 코드 블록 내의 문이 하나라면 중괄호를 생략할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> kind;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (num &gt; <span class=\"number\">0</span>) kind = <span class=\"string\">&#x27;양수&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (num &lt; <span class=\"number\">0</span>) kind = <span class=\"string\">&#x27;음수&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">else</span> kind = <span class=\"string\">&#x27;영&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(kind); <span class=\"comment\">// 양수</span></span><br></pre></td></tr></table></figure>\n\n<p>대부분의 if…else 문은 삼항 조건 연산자로 바꿔 쓸 수 있다.<br>연산자에서도 살펴보았듯이 조건에 따라 단순히 값을 결정하여 변수에 할당하는 경우 if…else 문보다 삼항 조건 연산자를 사용하는 편이 가독성이 좋다.<br>하지만 조건에 따라 실행해야 할 내용이 복잡하여 여러 줄의 문이 필요하다면 if…else 문을 사용하는 편이 가독성이 좋다.</p>\n<h3 id=\"switch-문\"><a href=\"#switch-문\" class=\"headerlink\" title=\"switch 문\"></a>switch 문</h3><p>switch 문은 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 흐름을 옮긴다.<br>case 문은 상황을 의미하는 표현식을 지정하고 콜론으로 마친다. 그리고 그 뒤에 실행할 문들을 위치시킨다.</p>\n<p>switch 문의 표현식과 일치하는 case 문이 없다면 실행 순서는 default 문으로 이동한다. default 문은 선택사항이다.</p>\n<pre>\nswitch (표현식) {\n case 표현식1:\n  switch 문의 표현식과 표현식 1이 일치하면 실행될 문;\n  break;\n case 표현식2:\n  switch 문의 표현식과 표현식 2가 일치하면 실행될 문;\n  break;\n default:\n  switch 문의 표현식과 일치하는 case 문이 없을 때 실행될 문;\n}\n</pre>\n\n<p>if…else 문의 조건식은 불리언 값으로 평가되어야 하지만 switch 문의 표현식은 불리언 값보다는 문자열이나 숫자 값인 경우가 많다.<br>즉 switch 문은 논리적 참, 거짓보다는 다양한 상황(case)에 따라 실행할 코드 블록을 결정할 때 사용한다.</p>\n<p>swtich 문은 case, default, break 등 다양한 키워드를 사용해야 하고 폴스루가 발생한느 등 문법도 복잡하다.<br>따라서 C 언어를 기반으로 하는 프로그래밍 언어는 대부분 switch 문을 지원하지만 파이썬과 같이 switch 문ㅇ을 지원하지 않는 프로그래밍 언어도 있다.</p>\n<p>만약 if…else 문으로 해결할 수 있다면 switch 문보다 if…else 문을 사용하는 편이 좋다.<br>하지만 조건이 너무 많아 if…else 문보다 switch 문을 사용했을 때 가독성이 더 좋다면 switch문을 사용하는 편이 좋다.</p>\n<h2 id=\"반복문\"><a href=\"#반복문\" class=\"headerlink\" title=\"반복문\"></a>반복문</h2><p>반복문은 조건식의 평가 결과가 참인 경우 코드 블록을 실행한다. 그 후 조건식을 다시 평가하여 여전히 참인 경우 코드 블록을 다시 실행한다.<br>이는 조건식이 거짓일 때까지 반복된다.</p>\n<p>자바스크립트는 for 문, while 문, do…while 문의 세 가지 반복문을 제공한다</p>\n<h3 id=\"for-문\"><a href=\"#for-문\" class=\"headerlink\" title=\"for 문\"></a>for 문</h3><p>for 문은 조건식이 거짓으로 평가될 때까지 코드 블록을 반복 실행한다. 가장 일반적으로 사용되는 for 문의 형태는 다음과 같다.</p>\n<pre>\nfor (변수 선언문 또는 할당문; 조건식; 증감식) {\n 조건식이 참인 경우 반복 실행될 문;\n}\n</pre>\n\n<p>for 문은 매우 중요하므로 어떻게 동작하는지 많은 연습을 통해 확실히 이해해야 한다.</p>\n<p>for 문의 변수 선언문, 조건식, 증감식은 모두 옵션이므로 반드시 사용할 필요는 없다. 단, 어떤 식도 선언하지 않으면 무한루프가 된다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (;;) &#123;...&#125; <span class=\"comment\">// 무한루프</span></span><br></pre></td></tr></table></figure>\n\n<p>for 문 내에 for 문을 중첩해 사용할 수 있다. 이를 중첩 for 문이라 한다. 다음은 두 개의 주사위를 던졌을 때 두 눈의 합이 6이 되는 모든 경우의 수를 출력하기 위해 이중 중첩 for 문을 사용한 예다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">6</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">1</span>; j &lt;= <span class=\"number\">6</span>; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i + j === <span class=\"number\">6</span>) <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`[<span class=\"subst\">$&#123;i&#125;</span>, <span class=\"subst\">$&#123;j&#125;</span>]`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// [1, 5] [2, 4] [3, 3] [4, 2] [5, 1]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"while-문\"><a href=\"#while-문\" class=\"headerlink\" title=\"while 문\"></a>while 문</h3><p>while 문은 주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복 실행한다.<br>for 문은 반복 횟수가 명확할 때 주로 사용하고 while 문은 반복 횟수가 불명확할 때 주로 사용한다.</p>\n<p>while 문은 조건문의 평가 결과가 거짓이 되면 코드 블록을 실행하지 않고 종료한다. 만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 강제 변환하여 논리적 참, 거짓을 구별한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> (count &lt; <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(count); <span class=\"comment\">// 0 1 2</span></span><br><span class=\"line\">  count++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>조건식의 평가 결과가 언제나 참이면 무한루프가 된다.<br>무한루프에서 탈출하기 위해서는 코드 블록 내에 if 문으로 탈출 조건을 만들고 break 문으로 코드 블록을 탈출한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 무한루프</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(count); <span class=\"comment\">// 0 1 2</span></span><br><span class=\"line\">  count++;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (count === <span class=\"number\">3</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"do…while-문\"><a href=\"#do…while-문\" class=\"headerlink\" title=\"do…while 문\"></a>do…while 문</h3><p>do…while 문은 코드 블록을 먼저 실행하고 조건식을 평가한다. 따라서 코드 블록은 무조건 한 번 이상 실행된다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(count); <span class=\"comment\">// 0 1 2</span></span><br><span class=\"line\">  count++;</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> (count &lt; <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"break-문\"><a href=\"#break-문\" class=\"headerlink\" title=\"break 문\"></a>break 문</h2><p>switch 문과 while 문에서 살펴보았듯이 break 문은 코드 블록을 탈출한다.<br>더 정확히 말하자면 레이블 문, 반복문 또는 switch 문의 코드 블록을 탈출한다. 레이블 문, 반복문, switch 문의 코드 블록 외에 break 문을 사용하면 SyntaxError가 발생한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">break</span>; <span class=\"comment\">// Uncaught SyntaxError: Illegal break statement</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>참고로 레이블 문은 식별자가 붙은 문을 말한다.<br>레이블 문은 프로그램의 실행 순서를 제어하는데 사용한다. 사실 switch 문의 case 문과 default 문 역시 레이블 문이다.<br>레이블 문을 탈출하려면 break 문에 레이블 식별자를 지정한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">foo</span>: &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">break</span> foo;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Done!&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// Done!</span></span><br></pre></td></tr></table></figure>\n\n<p>레이블 문을 사용하면 프로그램의 흐름이 복잡해져서 가독성이 나빠지고 오류를 발생시킬 가능성이 높아지기 때문에 일반적으로 권장하지 않는다.</p>\n</blockquote>\n<h2 id=\"continue-문\"><a href=\"#continue-문\" class=\"headerlink\" title=\"continue 문\"></a>continue 문</h2><p>continue 문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다.<br>break 문처럼 반복문을 탈출하지는 않는다.</p>\n<p>다음은 문자열에서 특정 문자의 개수를 세는 예다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">&#x27;Hello World.&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> search = <span class=\"string\">&#x27;l&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; string.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (string[i] !== search) <span class=\"keyword\">continue</span>; <span class=\"comment\">// &#x27;l&#x27;이 아니면 현 지점에서 실행을 중단하고 반복문의 증감식으로 이동한다.</span></span><br><span class=\"line\">  count++; <span class=\"comment\">// continue 문이 실행되면 이 문은 실행되지 않는다.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(count); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n"},{"title":"[Deep Dive] 객체 리터럴","date":"2022-10-21T12:38:37.000Z","_content":"# 객체란?\n\n자바스크립트는 객체 기반의 프로그래밍 언어이며, 자바스크립트를 구성하는 거의 모든것이 객체이다.\n원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등)은 모두 객체다.\n\n원시 타입은 단 하나의 값만 나타내지만 객체타입은 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조다.\n원시 타입의 값은 변경 불가능한 값이지만 객체 타입의 값은 변경 가능한 값이다.\n\n객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키와 값으로 구성된다.\n\n자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있다. 자바스크립트의 함수는 일급 객체로 값으로 취급할 수 있다.\n따라서 함수도 프로퍼티 값으로 사용 가능한데, 프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라 한다.\n\n이처럼 객체는 프로퍼티와 메서드로 구성된 집합체이며 프로퍼티와 메서드의 역할은 다음과 같다.\n\n- 프로퍼티: 객체의 상태를 나타내는 값(data)\n- 메서드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)\n\n객체는 프로퍼티와 메서드를 통해 상태와 동작을 하나의 단위로 구조화할 수 있어 유용하다.\n\n## 객체 리터럴에 의한 객체 생성\n\nC++이나 자바와 같은 클래스 기반 객체지향 언어는 클래스를 사전에 정의하고 필요한 시점에 new 연산자와 함께 생성자를 호출하여 인스턴스를 생성하는 방식으로 객체를 생성한다.\n\n자바스크립트는 프로토타입 기반 객체지향 언어로 클래스 기반 객체지향 언어와는 달리 다양한 객체 생성 방법을 지원한다.\n\n- 객체 리터럴\n- Object 생성자 함수\n- 생성자 함수\n- Object.create 메서드\n- 클래스(ES6)\n\n객체 생성 방법 중에서 가장 일반적이고 간단한 방법은 객체 리터럴을 사용하는 방법이다.\n객체 리터럴은 중괄호({...}) 내에 0개 이상의 프로퍼티를 정의한다. 자바스크립트 엔진은 변수에 할당되는 시점에 객체 리터럴을 해석해 객체를 생성한다.\n\n```javascript\nvar person = {\n  name: 'rongrong',\n  sayHello: function () {\n    console.log(`Hello! my name is ${this.name}.`);\n  },\n};\n\nconsole.log(typeof person); // object\nconsole.log(person); // {name: 'rongrong', sayHello: f}\n```\n\n객체 리터럴의 중괄호는 코드 블록을 의미하지 않는다는것에 주의하자. 코드 블록의 닫는 중괄호 뒤에는 세미콜론을 붙이지 않는다.\n하지만 객체 리터럴은 값으로 평가되는 표현식으로 객체 리터럴의 닫는 괄호 뒤에는 세미콜론을 붙인다.\n\n객체 리터럴은 자바스크립트의 유연함과 강력함을 대표하는 객체 생성 방식으로 객체 리터럴에 프로퍼티를 포함시켜 객체를 생성함과 동시에 프로퍼티를 만들 수도 있고, 객체를 생성한 이후에 프로퍼티를 동적으로 추가할 수도 있다.\n\n그렇다면 프로퍼티에 대해 자세히 알아보자.\n\n## 프로퍼티\n\n객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.\n프로퍼티를 나열할 때는 쉼표로 구분한다. 일반적으로 마지막 프로퍼티 뒤에는 쉼표를 사용하지 않지만 사용해도 괜찮다.\n\n프로퍼티 키와 프로퍼티 값으로 사용할 수 있는 값은 다음과 같다.\n\n- 프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 또는 심벌 값\n- 프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값\n\n프로퍼티 키는 프로퍼티 값에 접근할 수 있는 이름으로 식별자의 역할을 한다. 하지만 반드시 식별자 네이밍규칙을 따라야 하는 것은 아니다.\n단, 식별자 네이밍 규칙을 준수하는 프로퍼티 키와 그렇지 않은 키에는 차이가 존재한다.\n\n심벌 값도 프로퍼티 키로 사용할 수 있지만 일반적으로 문자열을 사용한다. 이때 프로퍼티 키는 문자열이므로 따옴표로 묶어야 한다.\n하지만 식별자 네이밍 규칙을 준수하는 이름은 따옴표를 생략할 수 있다. 반대로 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야 한다.\n\n```javascript\nvar person = {\n  firstName: 'rong', // 식별자 네이밍 규칙을 준수한 프로퍼티 키\n  'last-name': 'rong', // 식별자 네이밍 규칙을 준수하지 않은 프로퍼티 키\n};\n\nconsole.log(person); // {firstName: 'rong', last-name: 'rong'}\n```\n\n프로퍼티 키로 사용한 firstName은 식별자 네이밍 규칙을 준수하므로 따옴표를 생략할 수 있다.\n하지만 last-name은 식별자 네이밍 규칙을 주수하지 않으므로 따옴표를 생략할 수 없다. 자바스크립트 엔진은 따옴표를 생략한 last-name을 - 연산자가 있는 표현식으로 해석한다.\n\n```javascript\nvar person = {\n  firstName: 'rong',\n  last-name: 'rong', // SyntaxError: Unexpected token -\n};\n```\n\n문자열 또는 문자열로 평가할 수 있는 표현식을 사용해 프로퍼티 키를 동적으로 생성 가능하다. 이 경우에는 프로퍼티 키로 사용할 표현식을 대괄호로 묶어야 한다.\n\n```javascript\nvar obj = {};\nvar key = 'hello';\n\nobj[key] = 'world';\n\nconsole.log(obj); // {hello: 'world'}\n```\n\n이미 존재하는 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다.\n이때 에러가 발생하지 않으니 주의해야 한다.\n\n```javascript\nvar foo = {\n  name: 'Lee',\n  name: 'Kim',\n};\n\nconsole.log(foo); // {name: 'Kim'}\n```\n\n## 메서드\n\n자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값으로 사용할 수 있다고 했다.\n자바스크립트의 함수는 일급객체로 값으로 취급할 수 있기 때문에 프로퍼티 값으로 사용 가능하다.\n\n프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라 부르는데 즉 메서드는 객체에 묶여 있는 함수를 의미한다.\n\n```javascript\nvar circle = {\n  radius: 5, // 프로퍼티\n  // 원의 지름을 구하는 메서드\n  getDiameter: function () {\n    return 2 * this.radius;\n  },\n};\n\nconsole.log(circle.getDiameter()); // 10\n```\n\n## 프로퍼티 접근\n\n프로퍼티에 접근하는 방법은 다음과 같이 두 가지이다.\n\n- 마침표 프로퍼티 접근 연산자(.)를 사용하는 마침표 표기법\n- 대괄호 프로퍼티 접근 연산자([...])를 사용하는 대괄호 표기법\n\n프로퍼티 키가 식별자 네이밍 규칙을 준수하는 이름이면 마침표 표기법과 대괄호 표기법을 모두 사용할 수 있다.\n\n대괄호 표기법을 사용하는 경우 대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다.\n대괄호 프로퍼티 접근 연산자 내에 따옴표로 감싸지 않은 이름을 프로퍼티 키로 사용하면 자바스크립트 엔진은 식별자로 해석한다.\n\n```javascript\nvar person = {\n  name: 'rongrong',\n};\n\nconsole.log(person.name); // 'rongrong'\nconsole.log(person['name']); // 'rongrong'\n\nconsole.log(person[name]); // ReferenceError: name is not defined\n```\n\n위 코드에서 ReferenceError가 발생한 이유는 대괄호 연산자 내의 따옴표로 감싸지 않은 이름, 즉 식별자 name을 평가하기 위해 선언된 name을 찾았지만 찾지 못했기 때문이다.\n\n객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환한다. 이때 ReferenceError가 발생하지 않는데에 주의하자\n\n```javascript\nvar person = {\n  name: 'rongrong',\n};\n\nconsole.log(person.age); // undefined\n```\n\n프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않으면 반드시 대괄호 표기법을 사용해야 한다.\n단 프로퍼티 키가 숫자로 이루어진 문자열인 경우 따옴표를 생략할 수 있다.\n\n## 프로퍼티 값 갱신\n\n이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신된다\n\n```javascript\nvar person = {\n  name: 'Lee',\n};\n\nperson.name = 'Kim';\n\nconsole.log(person); // {name: \"Kim\"}\n```\n\n## 프로퍼티 동적 생성\n\n존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다.\n\n```javascript\nvar person = {\n  name: 'rongrong',\n};\n\nperson.age = 25;\n\nconsole.log(person); // {name: 'rongrong', age: 25}\n```\n\n## 프로퍼티 삭제\n\ndelete 연산자는 객체의 프로퍼티를 삭제한다. 이때 delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이어야 한다.\n이때 존재하지 않는 프로퍼티를 삭제해도 아무런 에러 없이 무시된다.\n\n```javascript\nvar person = {\n  name: 'rongrong',\n};\n\nperson.age = 25;\n\ndelete person.age; // 프로퍼티 동적 생성 후 삭제\n\ndelete person.address; // 존재하지 않는 프로퍼티 삭제, 에러 없이 무시\n\nconsole.log(person); // {name: 'rongrong'}\n```\n\n## ES6에서 추가된 객체 리터럴의 확장 기능\n\nES6에서는 더욱 간편하고 표현력 있는 객체 리터럴의 확장 기능을 제공한다.\n\n### 프로퍼티 축약 표현\n\n객체 리터럴의 프로퍼티는 프로퍼티 키와 프로퍼티 값으로 구성된다. 프로퍼티 값은 변수에 할당된 값, 즉 식별자 표현식일 수도 있다.\n\nES6에서는 프로퍼티 값으로 변수를 사용하는 경우 변수 이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티 키를 생략할 수 있다.\n이때 프로퍼티 키는 변수 이름으로 자동 생성된다.\n\n```javascript\nlet x = 1,\n  y = 2;\n\nconst obj = { x, y };\n\nconsole.log(obj); {x: 1, y: 2}\n```\n\n### 메서드 축약 표현\n\nES5에서 메서드를 정의하려면 프로퍼티 값으로 함수를 할당한다.\n\nES6에서는 메서드를 정의할 때 function 키워드를 생략한 축약 표현을 사용할 수 있다.\n\n```javascript\nconst obj = {\n  name: 'rongrong',\n  sayHi() {\n    console.log('Hi! ' + this.name);\n  },\n};\n\nobj.sayHi(); // 'Hi! rongrong'\n```\n\nES6의 메서드 축약 표현으로 정의한 메서드는 프로퍼티에 할당한 함수와 다르게 동작한다.\n\n","source":"_posts/Modern-Javascript-Deep-Dive-Chapter-10-Summary.md","raw":"---\ntitle: \"[Deep Dive] 객체 리터럴\"\ndate: 2022-10-21 21:38:37\ntags:\n- 개발\n- 자바스크립트\n- 모던 자바스크립트 Deep Dive\n---\n# 객체란?\n\n자바스크립트는 객체 기반의 프로그래밍 언어이며, 자바스크립트를 구성하는 거의 모든것이 객체이다.\n원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등)은 모두 객체다.\n\n원시 타입은 단 하나의 값만 나타내지만 객체타입은 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조다.\n원시 타입의 값은 변경 불가능한 값이지만 객체 타입의 값은 변경 가능한 값이다.\n\n객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키와 값으로 구성된다.\n\n자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있다. 자바스크립트의 함수는 일급 객체로 값으로 취급할 수 있다.\n따라서 함수도 프로퍼티 값으로 사용 가능한데, 프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라 한다.\n\n이처럼 객체는 프로퍼티와 메서드로 구성된 집합체이며 프로퍼티와 메서드의 역할은 다음과 같다.\n\n- 프로퍼티: 객체의 상태를 나타내는 값(data)\n- 메서드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)\n\n객체는 프로퍼티와 메서드를 통해 상태와 동작을 하나의 단위로 구조화할 수 있어 유용하다.\n\n## 객체 리터럴에 의한 객체 생성\n\nC++이나 자바와 같은 클래스 기반 객체지향 언어는 클래스를 사전에 정의하고 필요한 시점에 new 연산자와 함께 생성자를 호출하여 인스턴스를 생성하는 방식으로 객체를 생성한다.\n\n자바스크립트는 프로토타입 기반 객체지향 언어로 클래스 기반 객체지향 언어와는 달리 다양한 객체 생성 방법을 지원한다.\n\n- 객체 리터럴\n- Object 생성자 함수\n- 생성자 함수\n- Object.create 메서드\n- 클래스(ES6)\n\n객체 생성 방법 중에서 가장 일반적이고 간단한 방법은 객체 리터럴을 사용하는 방법이다.\n객체 리터럴은 중괄호({...}) 내에 0개 이상의 프로퍼티를 정의한다. 자바스크립트 엔진은 변수에 할당되는 시점에 객체 리터럴을 해석해 객체를 생성한다.\n\n```javascript\nvar person = {\n  name: 'rongrong',\n  sayHello: function () {\n    console.log(`Hello! my name is ${this.name}.`);\n  },\n};\n\nconsole.log(typeof person); // object\nconsole.log(person); // {name: 'rongrong', sayHello: f}\n```\n\n객체 리터럴의 중괄호는 코드 블록을 의미하지 않는다는것에 주의하자. 코드 블록의 닫는 중괄호 뒤에는 세미콜론을 붙이지 않는다.\n하지만 객체 리터럴은 값으로 평가되는 표현식으로 객체 리터럴의 닫는 괄호 뒤에는 세미콜론을 붙인다.\n\n객체 리터럴은 자바스크립트의 유연함과 강력함을 대표하는 객체 생성 방식으로 객체 리터럴에 프로퍼티를 포함시켜 객체를 생성함과 동시에 프로퍼티를 만들 수도 있고, 객체를 생성한 이후에 프로퍼티를 동적으로 추가할 수도 있다.\n\n그렇다면 프로퍼티에 대해 자세히 알아보자.\n\n## 프로퍼티\n\n객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.\n프로퍼티를 나열할 때는 쉼표로 구분한다. 일반적으로 마지막 프로퍼티 뒤에는 쉼표를 사용하지 않지만 사용해도 괜찮다.\n\n프로퍼티 키와 프로퍼티 값으로 사용할 수 있는 값은 다음과 같다.\n\n- 프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 또는 심벌 값\n- 프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값\n\n프로퍼티 키는 프로퍼티 값에 접근할 수 있는 이름으로 식별자의 역할을 한다. 하지만 반드시 식별자 네이밍규칙을 따라야 하는 것은 아니다.\n단, 식별자 네이밍 규칙을 준수하는 프로퍼티 키와 그렇지 않은 키에는 차이가 존재한다.\n\n심벌 값도 프로퍼티 키로 사용할 수 있지만 일반적으로 문자열을 사용한다. 이때 프로퍼티 키는 문자열이므로 따옴표로 묶어야 한다.\n하지만 식별자 네이밍 규칙을 준수하는 이름은 따옴표를 생략할 수 있다. 반대로 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야 한다.\n\n```javascript\nvar person = {\n  firstName: 'rong', // 식별자 네이밍 규칙을 준수한 프로퍼티 키\n  'last-name': 'rong', // 식별자 네이밍 규칙을 준수하지 않은 프로퍼티 키\n};\n\nconsole.log(person); // {firstName: 'rong', last-name: 'rong'}\n```\n\n프로퍼티 키로 사용한 firstName은 식별자 네이밍 규칙을 준수하므로 따옴표를 생략할 수 있다.\n하지만 last-name은 식별자 네이밍 규칙을 주수하지 않으므로 따옴표를 생략할 수 없다. 자바스크립트 엔진은 따옴표를 생략한 last-name을 - 연산자가 있는 표현식으로 해석한다.\n\n```javascript\nvar person = {\n  firstName: 'rong',\n  last-name: 'rong', // SyntaxError: Unexpected token -\n};\n```\n\n문자열 또는 문자열로 평가할 수 있는 표현식을 사용해 프로퍼티 키를 동적으로 생성 가능하다. 이 경우에는 프로퍼티 키로 사용할 표현식을 대괄호로 묶어야 한다.\n\n```javascript\nvar obj = {};\nvar key = 'hello';\n\nobj[key] = 'world';\n\nconsole.log(obj); // {hello: 'world'}\n```\n\n이미 존재하는 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다.\n이때 에러가 발생하지 않으니 주의해야 한다.\n\n```javascript\nvar foo = {\n  name: 'Lee',\n  name: 'Kim',\n};\n\nconsole.log(foo); // {name: 'Kim'}\n```\n\n## 메서드\n\n자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값으로 사용할 수 있다고 했다.\n자바스크립트의 함수는 일급객체로 값으로 취급할 수 있기 때문에 프로퍼티 값으로 사용 가능하다.\n\n프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라 부르는데 즉 메서드는 객체에 묶여 있는 함수를 의미한다.\n\n```javascript\nvar circle = {\n  radius: 5, // 프로퍼티\n  // 원의 지름을 구하는 메서드\n  getDiameter: function () {\n    return 2 * this.radius;\n  },\n};\n\nconsole.log(circle.getDiameter()); // 10\n```\n\n## 프로퍼티 접근\n\n프로퍼티에 접근하는 방법은 다음과 같이 두 가지이다.\n\n- 마침표 프로퍼티 접근 연산자(.)를 사용하는 마침표 표기법\n- 대괄호 프로퍼티 접근 연산자([...])를 사용하는 대괄호 표기법\n\n프로퍼티 키가 식별자 네이밍 규칙을 준수하는 이름이면 마침표 표기법과 대괄호 표기법을 모두 사용할 수 있다.\n\n대괄호 표기법을 사용하는 경우 대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다.\n대괄호 프로퍼티 접근 연산자 내에 따옴표로 감싸지 않은 이름을 프로퍼티 키로 사용하면 자바스크립트 엔진은 식별자로 해석한다.\n\n```javascript\nvar person = {\n  name: 'rongrong',\n};\n\nconsole.log(person.name); // 'rongrong'\nconsole.log(person['name']); // 'rongrong'\n\nconsole.log(person[name]); // ReferenceError: name is not defined\n```\n\n위 코드에서 ReferenceError가 발생한 이유는 대괄호 연산자 내의 따옴표로 감싸지 않은 이름, 즉 식별자 name을 평가하기 위해 선언된 name을 찾았지만 찾지 못했기 때문이다.\n\n객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환한다. 이때 ReferenceError가 발생하지 않는데에 주의하자\n\n```javascript\nvar person = {\n  name: 'rongrong',\n};\n\nconsole.log(person.age); // undefined\n```\n\n프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않으면 반드시 대괄호 표기법을 사용해야 한다.\n단 프로퍼티 키가 숫자로 이루어진 문자열인 경우 따옴표를 생략할 수 있다.\n\n## 프로퍼티 값 갱신\n\n이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신된다\n\n```javascript\nvar person = {\n  name: 'Lee',\n};\n\nperson.name = 'Kim';\n\nconsole.log(person); // {name: \"Kim\"}\n```\n\n## 프로퍼티 동적 생성\n\n존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다.\n\n```javascript\nvar person = {\n  name: 'rongrong',\n};\n\nperson.age = 25;\n\nconsole.log(person); // {name: 'rongrong', age: 25}\n```\n\n## 프로퍼티 삭제\n\ndelete 연산자는 객체의 프로퍼티를 삭제한다. 이때 delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이어야 한다.\n이때 존재하지 않는 프로퍼티를 삭제해도 아무런 에러 없이 무시된다.\n\n```javascript\nvar person = {\n  name: 'rongrong',\n};\n\nperson.age = 25;\n\ndelete person.age; // 프로퍼티 동적 생성 후 삭제\n\ndelete person.address; // 존재하지 않는 프로퍼티 삭제, 에러 없이 무시\n\nconsole.log(person); // {name: 'rongrong'}\n```\n\n## ES6에서 추가된 객체 리터럴의 확장 기능\n\nES6에서는 더욱 간편하고 표현력 있는 객체 리터럴의 확장 기능을 제공한다.\n\n### 프로퍼티 축약 표현\n\n객체 리터럴의 프로퍼티는 프로퍼티 키와 프로퍼티 값으로 구성된다. 프로퍼티 값은 변수에 할당된 값, 즉 식별자 표현식일 수도 있다.\n\nES6에서는 프로퍼티 값으로 변수를 사용하는 경우 변수 이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티 키를 생략할 수 있다.\n이때 프로퍼티 키는 변수 이름으로 자동 생성된다.\n\n```javascript\nlet x = 1,\n  y = 2;\n\nconst obj = { x, y };\n\nconsole.log(obj); {x: 1, y: 2}\n```\n\n### 메서드 축약 표현\n\nES5에서 메서드를 정의하려면 프로퍼티 값으로 함수를 할당한다.\n\nES6에서는 메서드를 정의할 때 function 키워드를 생략한 축약 표현을 사용할 수 있다.\n\n```javascript\nconst obj = {\n  name: 'rongrong',\n  sayHi() {\n    console.log('Hi! ' + this.name);\n  },\n};\n\nobj.sayHi(); // 'Hi! rongrong'\n```\n\nES6의 메서드 축약 표현으로 정의한 메서드는 프로퍼티에 할당한 함수와 다르게 동작한다.\n\n","slug":"Modern-Javascript-Deep-Dive-Chapter-10-Summary","published":1,"updated":"2022-10-21T12:39:27.462Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb08iq6e000be4vkdf7901i5","content":"<h1 id=\"객체란\"><a href=\"#객체란\" class=\"headerlink\" title=\"객체란?\"></a>객체란?</h1><p>자바스크립트는 객체 기반의 프로그래밍 언어이며, 자바스크립트를 구성하는 거의 모든것이 객체이다.<br>원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등)은 모두 객체다.</p>\n<p>원시 타입은 단 하나의 값만 나타내지만 객체타입은 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조다.<br>원시 타입의 값은 변경 불가능한 값이지만 객체 타입의 값은 변경 가능한 값이다.</p>\n<p>객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키와 값으로 구성된다.</p>\n<p>자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있다. 자바스크립트의 함수는 일급 객체로 값으로 취급할 수 있다.<br>따라서 함수도 프로퍼티 값으로 사용 가능한데, 프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라 한다.</p>\n<p>이처럼 객체는 프로퍼티와 메서드로 구성된 집합체이며 프로퍼티와 메서드의 역할은 다음과 같다.</p>\n<ul>\n<li>프로퍼티: 객체의 상태를 나타내는 값(data)</li>\n<li>메서드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)</li>\n</ul>\n<p>객체는 프로퍼티와 메서드를 통해 상태와 동작을 하나의 단위로 구조화할 수 있어 유용하다.</p>\n<h2 id=\"객체-리터럴에-의한-객체-생성\"><a href=\"#객체-리터럴에-의한-객체-생성\" class=\"headerlink\" title=\"객체 리터럴에 의한 객체 생성\"></a>객체 리터럴에 의한 객체 생성</h2><p>C++이나 자바와 같은 클래스 기반 객체지향 언어는 클래스를 사전에 정의하고 필요한 시점에 new 연산자와 함께 생성자를 호출하여 인스턴스를 생성하는 방식으로 객체를 생성한다.</p>\n<p>자바스크립트는 프로토타입 기반 객체지향 언어로 클래스 기반 객체지향 언어와는 달리 다양한 객체 생성 방법을 지원한다.</p>\n<ul>\n<li>객체 리터럴</li>\n<li>Object 생성자 함수</li>\n<li>생성자 함수</li>\n<li>Object.create 메서드</li>\n<li>클래스(ES6)</li>\n</ul>\n<p>객체 생성 방법 중에서 가장 일반적이고 간단한 방법은 객체 리터럴을 사용하는 방법이다.<br>객체 리터럴은 중괄호({…}) 내에 0개 이상의 프로퍼티를 정의한다. 자바스크립트 엔진은 변수에 할당되는 시점에 객체 리터럴을 해석해 객체를 생성한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;rongrong&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">sayHello</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello! my name is <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.name&#125;</span>.`</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> person); <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person); <span class=\"comment\">// &#123;name: &#x27;rongrong&#x27;, sayHello: f&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>객체 리터럴의 중괄호는 코드 블록을 의미하지 않는다는것에 주의하자. 코드 블록의 닫는 중괄호 뒤에는 세미콜론을 붙이지 않는다.<br>하지만 객체 리터럴은 값으로 평가되는 표현식으로 객체 리터럴의 닫는 괄호 뒤에는 세미콜론을 붙인다.</p>\n<p>객체 리터럴은 자바스크립트의 유연함과 강력함을 대표하는 객체 생성 방식으로 객체 리터럴에 프로퍼티를 포함시켜 객체를 생성함과 동시에 프로퍼티를 만들 수도 있고, 객체를 생성한 이후에 프로퍼티를 동적으로 추가할 수도 있다.</p>\n<p>그렇다면 프로퍼티에 대해 자세히 알아보자.</p>\n<h2 id=\"프로퍼티\"><a href=\"#프로퍼티\" class=\"headerlink\" title=\"프로퍼티\"></a>프로퍼티</h2><p>객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.<br>프로퍼티를 나열할 때는 쉼표로 구분한다. 일반적으로 마지막 프로퍼티 뒤에는 쉼표를 사용하지 않지만 사용해도 괜찮다.</p>\n<p>프로퍼티 키와 프로퍼티 값으로 사용할 수 있는 값은 다음과 같다.</p>\n<ul>\n<li>프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 또는 심벌 값</li>\n<li>프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값</li>\n</ul>\n<p>프로퍼티 키는 프로퍼티 값에 접근할 수 있는 이름으로 식별자의 역할을 한다. 하지만 반드시 식별자 네이밍규칙을 따라야 하는 것은 아니다.<br>단, 식별자 네이밍 규칙을 준수하는 프로퍼티 키와 그렇지 않은 키에는 차이가 존재한다.</p>\n<p>심벌 값도 프로퍼티 키로 사용할 수 있지만 일반적으로 문자열을 사용한다. 이때 프로퍼티 키는 문자열이므로 따옴표로 묶어야 한다.<br>하지만 식별자 네이밍 규칙을 준수하는 이름은 따옴표를 생략할 수 있다. 반대로 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야 한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">firstName</span>: <span class=\"string\">&#x27;rong&#x27;</span>, <span class=\"comment\">// 식별자 네이밍 규칙을 준수한 프로퍼티 키</span></span><br><span class=\"line\">  <span class=\"string\">&#x27;last-name&#x27;</span>: <span class=\"string\">&#x27;rong&#x27;</span>, <span class=\"comment\">// 식별자 네이밍 규칙을 준수하지 않은 프로퍼티 키</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person); <span class=\"comment\">// &#123;firstName: &#x27;rong&#x27;, last-name: &#x27;rong&#x27;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>프로퍼티 키로 사용한 firstName은 식별자 네이밍 규칙을 준수하므로 따옴표를 생략할 수 있다.<br>하지만 last-name은 식별자 네이밍 규칙을 주수하지 않으므로 따옴표를 생략할 수 없다. 자바스크립트 엔진은 따옴표를 생략한 last-name을 - 연산자가 있는 표현식으로 해석한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">firstName</span>: <span class=\"string\">&#x27;rong&#x27;</span>,</span><br><span class=\"line\">  last-<span class=\"attr\">name</span>: <span class=\"string\">&#x27;rong&#x27;</span>, <span class=\"comment\">// SyntaxError: Unexpected token -</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>문자열 또는 문자열로 평가할 수 있는 표현식을 사용해 프로퍼티 키를 동적으로 생성 가능하다. 이 경우에는 프로퍼티 키로 사용할 표현식을 대괄호로 묶어야 한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> key = <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">obj[key] = <span class=\"string\">&#x27;world&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj); <span class=\"comment\">// &#123;hello: &#x27;world&#x27;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>이미 존재하는 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다.<br>이때 에러가 발생하지 않으니 주의해야 한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Lee&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Kim&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(foo); <span class=\"comment\">// &#123;name: &#x27;Kim&#x27;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"메서드\"><a href=\"#메서드\" class=\"headerlink\" title=\"메서드\"></a>메서드</h2><p>자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값으로 사용할 수 있다고 했다.<br>자바스크립트의 함수는 일급객체로 값으로 취급할 수 있기 때문에 프로퍼티 값으로 사용 가능하다.</p>\n<p>프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라 부르는데 즉 메서드는 객체에 묶여 있는 함수를 의미한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> circle = &#123;</span><br><span class=\"line\">  <span class=\"attr\">radius</span>: <span class=\"number\">5</span>, <span class=\"comment\">// 프로퍼티</span></span><br><span class=\"line\">  <span class=\"comment\">// 원의 지름을 구하는 메서드</span></span><br><span class=\"line\">  <span class=\"attr\">getDiameter</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span> * <span class=\"variable language_\">this</span>.<span class=\"property\">radius</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(circle.<span class=\"title function_\">getDiameter</span>()); <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"프로퍼티-접근\"><a href=\"#프로퍼티-접근\" class=\"headerlink\" title=\"프로퍼티 접근\"></a>프로퍼티 접근</h2><p>프로퍼티에 접근하는 방법은 다음과 같이 두 가지이다.</p>\n<ul>\n<li>마침표 프로퍼티 접근 연산자(.)를 사용하는 마침표 표기법</li>\n<li>대괄호 프로퍼티 접근 연산자([…])를 사용하는 대괄호 표기법</li>\n</ul>\n<p>프로퍼티 키가 식별자 네이밍 규칙을 준수하는 이름이면 마침표 표기법과 대괄호 표기법을 모두 사용할 수 있다.</p>\n<p>대괄호 표기법을 사용하는 경우 대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다.<br>대괄호 프로퍼티 접근 연산자 내에 따옴표로 감싸지 않은 이름을 프로퍼티 키로 사용하면 자바스크립트 엔진은 식별자로 해석한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;rongrong&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person.<span class=\"property\">name</span>); <span class=\"comment\">// &#x27;rongrong&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person[<span class=\"string\">&#x27;name&#x27;</span>]); <span class=\"comment\">// &#x27;rongrong&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person[name]); <span class=\"comment\">// ReferenceError: name is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>위 코드에서 ReferenceError가 발생한 이유는 대괄호 연산자 내의 따옴표로 감싸지 않은 이름, 즉 식별자 name을 평가하기 위해 선언된 name을 찾았지만 찾지 못했기 때문이다.</p>\n<p>객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환한다. 이때 ReferenceError가 발생하지 않는데에 주의하자</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;rongrong&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person.<span class=\"property\">age</span>); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않으면 반드시 대괄호 표기법을 사용해야 한다.<br>단 프로퍼티 키가 숫자로 이루어진 문자열인 경우 따옴표를 생략할 수 있다.</p>\n<h2 id=\"프로퍼티-값-갱신\"><a href=\"#프로퍼티-값-갱신\" class=\"headerlink\" title=\"프로퍼티 값 갱신\"></a>프로퍼티 값 갱신</h2><p>이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신된다</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Lee&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">person.<span class=\"property\">name</span> = <span class=\"string\">&#x27;Kim&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person); <span class=\"comment\">// &#123;name: &quot;Kim&quot;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"프로퍼티-동적-생성\"><a href=\"#프로퍼티-동적-생성\" class=\"headerlink\" title=\"프로퍼티 동적 생성\"></a>프로퍼티 동적 생성</h2><p>존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;rongrong&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">person.<span class=\"property\">age</span> = <span class=\"number\">25</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person); <span class=\"comment\">// &#123;name: &#x27;rongrong&#x27;, age: 25&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"프로퍼티-삭제\"><a href=\"#프로퍼티-삭제\" class=\"headerlink\" title=\"프로퍼티 삭제\"></a>프로퍼티 삭제</h2><p>delete 연산자는 객체의 프로퍼티를 삭제한다. 이때 delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이어야 한다.<br>이때 존재하지 않는 프로퍼티를 삭제해도 아무런 에러 없이 무시된다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;rongrong&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">person.<span class=\"property\">age</span> = <span class=\"number\">25</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> person.<span class=\"property\">age</span>; <span class=\"comment\">// 프로퍼티 동적 생성 후 삭제</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> person.<span class=\"property\">address</span>; <span class=\"comment\">// 존재하지 않는 프로퍼티 삭제, 에러 없이 무시</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person); <span class=\"comment\">// &#123;name: &#x27;rongrong&#x27;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ES6에서-추가된-객체-리터럴의-확장-기능\"><a href=\"#ES6에서-추가된-객체-리터럴의-확장-기능\" class=\"headerlink\" title=\"ES6에서 추가된 객체 리터럴의 확장 기능\"></a>ES6에서 추가된 객체 리터럴의 확장 기능</h2><p>ES6에서는 더욱 간편하고 표현력 있는 객체 리터럴의 확장 기능을 제공한다.</p>\n<h3 id=\"프로퍼티-축약-표현\"><a href=\"#프로퍼티-축약-표현\" class=\"headerlink\" title=\"프로퍼티 축약 표현\"></a>프로퍼티 축약 표현</h3><p>객체 리터럴의 프로퍼티는 프로퍼티 키와 프로퍼티 값으로 구성된다. 프로퍼티 값은 변수에 할당된 값, 즉 식별자 표현식일 수도 있다.</p>\n<p>ES6에서는 프로퍼티 값으로 변수를 사용하는 경우 변수 이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티 키를 생략할 수 있다.<br>이때 프로퍼티 키는 변수 이름으로 자동 생성된다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">1</span>,</span><br><span class=\"line\">  y = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; x, y &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj); &#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"메서드-축약-표현\"><a href=\"#메서드-축약-표현\" class=\"headerlink\" title=\"메서드 축약 표현\"></a>메서드 축약 표현</h3><p>ES5에서 메서드를 정의하려면 프로퍼티 값으로 함수를 할당한다.</p>\n<p>ES6에서는 메서드를 정의할 때 function 키워드를 생략한 축약 표현을 사용할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;rongrong&#x27;</span>,</span><br><span class=\"line\">  <span class=\"title function_\">sayHi</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hi! &#x27;</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">name</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.<span class=\"title function_\">sayHi</span>(); <span class=\"comment\">// &#x27;Hi! rongrong&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>ES6의 메서드 축약 표현으로 정의한 메서드는 프로퍼티에 할당한 함수와 다르게 동작한다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"객체란\"><a href=\"#객체란\" class=\"headerlink\" title=\"객체란?\"></a>객체란?</h1><p>자바스크립트는 객체 기반의 프로그래밍 언어이며, 자바스크립트를 구성하는 거의 모든것이 객체이다.<br>원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등)은 모두 객체다.</p>\n<p>원시 타입은 단 하나의 값만 나타내지만 객체타입은 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조다.<br>원시 타입의 값은 변경 불가능한 값이지만 객체 타입의 값은 변경 가능한 값이다.</p>\n<p>객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키와 값으로 구성된다.</p>\n<p>자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있다. 자바스크립트의 함수는 일급 객체로 값으로 취급할 수 있다.<br>따라서 함수도 프로퍼티 값으로 사용 가능한데, 프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라 한다.</p>\n<p>이처럼 객체는 프로퍼티와 메서드로 구성된 집합체이며 프로퍼티와 메서드의 역할은 다음과 같다.</p>\n<ul>\n<li>프로퍼티: 객체의 상태를 나타내는 값(data)</li>\n<li>메서드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)</li>\n</ul>\n<p>객체는 프로퍼티와 메서드를 통해 상태와 동작을 하나의 단위로 구조화할 수 있어 유용하다.</p>\n<h2 id=\"객체-리터럴에-의한-객체-생성\"><a href=\"#객체-리터럴에-의한-객체-생성\" class=\"headerlink\" title=\"객체 리터럴에 의한 객체 생성\"></a>객체 리터럴에 의한 객체 생성</h2><p>C++이나 자바와 같은 클래스 기반 객체지향 언어는 클래스를 사전에 정의하고 필요한 시점에 new 연산자와 함께 생성자를 호출하여 인스턴스를 생성하는 방식으로 객체를 생성한다.</p>\n<p>자바스크립트는 프로토타입 기반 객체지향 언어로 클래스 기반 객체지향 언어와는 달리 다양한 객체 생성 방법을 지원한다.</p>\n<ul>\n<li>객체 리터럴</li>\n<li>Object 생성자 함수</li>\n<li>생성자 함수</li>\n<li>Object.create 메서드</li>\n<li>클래스(ES6)</li>\n</ul>\n<p>객체 생성 방법 중에서 가장 일반적이고 간단한 방법은 객체 리터럴을 사용하는 방법이다.<br>객체 리터럴은 중괄호({…}) 내에 0개 이상의 프로퍼티를 정의한다. 자바스크립트 엔진은 변수에 할당되는 시점에 객체 리터럴을 해석해 객체를 생성한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;rongrong&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">sayHello</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello! my name is <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.name&#125;</span>.`</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> person); <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person); <span class=\"comment\">// &#123;name: &#x27;rongrong&#x27;, sayHello: f&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>객체 리터럴의 중괄호는 코드 블록을 의미하지 않는다는것에 주의하자. 코드 블록의 닫는 중괄호 뒤에는 세미콜론을 붙이지 않는다.<br>하지만 객체 리터럴은 값으로 평가되는 표현식으로 객체 리터럴의 닫는 괄호 뒤에는 세미콜론을 붙인다.</p>\n<p>객체 리터럴은 자바스크립트의 유연함과 강력함을 대표하는 객체 생성 방식으로 객체 리터럴에 프로퍼티를 포함시켜 객체를 생성함과 동시에 프로퍼티를 만들 수도 있고, 객체를 생성한 이후에 프로퍼티를 동적으로 추가할 수도 있다.</p>\n<p>그렇다면 프로퍼티에 대해 자세히 알아보자.</p>\n<h2 id=\"프로퍼티\"><a href=\"#프로퍼티\" class=\"headerlink\" title=\"프로퍼티\"></a>프로퍼티</h2><p>객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.<br>프로퍼티를 나열할 때는 쉼표로 구분한다. 일반적으로 마지막 프로퍼티 뒤에는 쉼표를 사용하지 않지만 사용해도 괜찮다.</p>\n<p>프로퍼티 키와 프로퍼티 값으로 사용할 수 있는 값은 다음과 같다.</p>\n<ul>\n<li>프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 또는 심벌 값</li>\n<li>프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값</li>\n</ul>\n<p>프로퍼티 키는 프로퍼티 값에 접근할 수 있는 이름으로 식별자의 역할을 한다. 하지만 반드시 식별자 네이밍규칙을 따라야 하는 것은 아니다.<br>단, 식별자 네이밍 규칙을 준수하는 프로퍼티 키와 그렇지 않은 키에는 차이가 존재한다.</p>\n<p>심벌 값도 프로퍼티 키로 사용할 수 있지만 일반적으로 문자열을 사용한다. 이때 프로퍼티 키는 문자열이므로 따옴표로 묶어야 한다.<br>하지만 식별자 네이밍 규칙을 준수하는 이름은 따옴표를 생략할 수 있다. 반대로 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야 한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">firstName</span>: <span class=\"string\">&#x27;rong&#x27;</span>, <span class=\"comment\">// 식별자 네이밍 규칙을 준수한 프로퍼티 키</span></span><br><span class=\"line\">  <span class=\"string\">&#x27;last-name&#x27;</span>: <span class=\"string\">&#x27;rong&#x27;</span>, <span class=\"comment\">// 식별자 네이밍 규칙을 준수하지 않은 프로퍼티 키</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person); <span class=\"comment\">// &#123;firstName: &#x27;rong&#x27;, last-name: &#x27;rong&#x27;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>프로퍼티 키로 사용한 firstName은 식별자 네이밍 규칙을 준수하므로 따옴표를 생략할 수 있다.<br>하지만 last-name은 식별자 네이밍 규칙을 주수하지 않으므로 따옴표를 생략할 수 없다. 자바스크립트 엔진은 따옴표를 생략한 last-name을 - 연산자가 있는 표현식으로 해석한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">firstName</span>: <span class=\"string\">&#x27;rong&#x27;</span>,</span><br><span class=\"line\">  last-<span class=\"attr\">name</span>: <span class=\"string\">&#x27;rong&#x27;</span>, <span class=\"comment\">// SyntaxError: Unexpected token -</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>문자열 또는 문자열로 평가할 수 있는 표현식을 사용해 프로퍼티 키를 동적으로 생성 가능하다. 이 경우에는 프로퍼티 키로 사용할 표현식을 대괄호로 묶어야 한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> key = <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">obj[key] = <span class=\"string\">&#x27;world&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj); <span class=\"comment\">// &#123;hello: &#x27;world&#x27;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>이미 존재하는 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다.<br>이때 에러가 발생하지 않으니 주의해야 한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Lee&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Kim&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(foo); <span class=\"comment\">// &#123;name: &#x27;Kim&#x27;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"메서드\"><a href=\"#메서드\" class=\"headerlink\" title=\"메서드\"></a>메서드</h2><p>자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값으로 사용할 수 있다고 했다.<br>자바스크립트의 함수는 일급객체로 값으로 취급할 수 있기 때문에 프로퍼티 값으로 사용 가능하다.</p>\n<p>프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라 부르는데 즉 메서드는 객체에 묶여 있는 함수를 의미한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> circle = &#123;</span><br><span class=\"line\">  <span class=\"attr\">radius</span>: <span class=\"number\">5</span>, <span class=\"comment\">// 프로퍼티</span></span><br><span class=\"line\">  <span class=\"comment\">// 원의 지름을 구하는 메서드</span></span><br><span class=\"line\">  <span class=\"attr\">getDiameter</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span> * <span class=\"variable language_\">this</span>.<span class=\"property\">radius</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(circle.<span class=\"title function_\">getDiameter</span>()); <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"프로퍼티-접근\"><a href=\"#프로퍼티-접근\" class=\"headerlink\" title=\"프로퍼티 접근\"></a>프로퍼티 접근</h2><p>프로퍼티에 접근하는 방법은 다음과 같이 두 가지이다.</p>\n<ul>\n<li>마침표 프로퍼티 접근 연산자(.)를 사용하는 마침표 표기법</li>\n<li>대괄호 프로퍼티 접근 연산자([…])를 사용하는 대괄호 표기법</li>\n</ul>\n<p>프로퍼티 키가 식별자 네이밍 규칙을 준수하는 이름이면 마침표 표기법과 대괄호 표기법을 모두 사용할 수 있다.</p>\n<p>대괄호 표기법을 사용하는 경우 대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다.<br>대괄호 프로퍼티 접근 연산자 내에 따옴표로 감싸지 않은 이름을 프로퍼티 키로 사용하면 자바스크립트 엔진은 식별자로 해석한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;rongrong&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person.<span class=\"property\">name</span>); <span class=\"comment\">// &#x27;rongrong&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person[<span class=\"string\">&#x27;name&#x27;</span>]); <span class=\"comment\">// &#x27;rongrong&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person[name]); <span class=\"comment\">// ReferenceError: name is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>위 코드에서 ReferenceError가 발생한 이유는 대괄호 연산자 내의 따옴표로 감싸지 않은 이름, 즉 식별자 name을 평가하기 위해 선언된 name을 찾았지만 찾지 못했기 때문이다.</p>\n<p>객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환한다. 이때 ReferenceError가 발생하지 않는데에 주의하자</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;rongrong&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person.<span class=\"property\">age</span>); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않으면 반드시 대괄호 표기법을 사용해야 한다.<br>단 프로퍼티 키가 숫자로 이루어진 문자열인 경우 따옴표를 생략할 수 있다.</p>\n<h2 id=\"프로퍼티-값-갱신\"><a href=\"#프로퍼티-값-갱신\" class=\"headerlink\" title=\"프로퍼티 값 갱신\"></a>프로퍼티 값 갱신</h2><p>이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신된다</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Lee&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">person.<span class=\"property\">name</span> = <span class=\"string\">&#x27;Kim&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person); <span class=\"comment\">// &#123;name: &quot;Kim&quot;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"프로퍼티-동적-생성\"><a href=\"#프로퍼티-동적-생성\" class=\"headerlink\" title=\"프로퍼티 동적 생성\"></a>프로퍼티 동적 생성</h2><p>존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;rongrong&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">person.<span class=\"property\">age</span> = <span class=\"number\">25</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person); <span class=\"comment\">// &#123;name: &#x27;rongrong&#x27;, age: 25&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"프로퍼티-삭제\"><a href=\"#프로퍼티-삭제\" class=\"headerlink\" title=\"프로퍼티 삭제\"></a>프로퍼티 삭제</h2><p>delete 연산자는 객체의 프로퍼티를 삭제한다. 이때 delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이어야 한다.<br>이때 존재하지 않는 프로퍼티를 삭제해도 아무런 에러 없이 무시된다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;rongrong&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">person.<span class=\"property\">age</span> = <span class=\"number\">25</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> person.<span class=\"property\">age</span>; <span class=\"comment\">// 프로퍼티 동적 생성 후 삭제</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> person.<span class=\"property\">address</span>; <span class=\"comment\">// 존재하지 않는 프로퍼티 삭제, 에러 없이 무시</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person); <span class=\"comment\">// &#123;name: &#x27;rongrong&#x27;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ES6에서-추가된-객체-리터럴의-확장-기능\"><a href=\"#ES6에서-추가된-객체-리터럴의-확장-기능\" class=\"headerlink\" title=\"ES6에서 추가된 객체 리터럴의 확장 기능\"></a>ES6에서 추가된 객체 리터럴의 확장 기능</h2><p>ES6에서는 더욱 간편하고 표현력 있는 객체 리터럴의 확장 기능을 제공한다.</p>\n<h3 id=\"프로퍼티-축약-표현\"><a href=\"#프로퍼티-축약-표현\" class=\"headerlink\" title=\"프로퍼티 축약 표현\"></a>프로퍼티 축약 표현</h3><p>객체 리터럴의 프로퍼티는 프로퍼티 키와 프로퍼티 값으로 구성된다. 프로퍼티 값은 변수에 할당된 값, 즉 식별자 표현식일 수도 있다.</p>\n<p>ES6에서는 프로퍼티 값으로 변수를 사용하는 경우 변수 이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티 키를 생략할 수 있다.<br>이때 프로퍼티 키는 변수 이름으로 자동 생성된다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">1</span>,</span><br><span class=\"line\">  y = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; x, y &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj); &#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"메서드-축약-표현\"><a href=\"#메서드-축약-표현\" class=\"headerlink\" title=\"메서드 축약 표현\"></a>메서드 축약 표현</h3><p>ES5에서 메서드를 정의하려면 프로퍼티 값으로 함수를 할당한다.</p>\n<p>ES6에서는 메서드를 정의할 때 function 키워드를 생략한 축약 표현을 사용할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;rongrong&#x27;</span>,</span><br><span class=\"line\">  <span class=\"title function_\">sayHi</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hi! &#x27;</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">name</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.<span class=\"title function_\">sayHi</span>(); <span class=\"comment\">// &#x27;Hi! rongrong&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>ES6의 메서드 축약 표현으로 정의한 메서드는 프로퍼티에 할당한 함수와 다르게 동작한다.</p>\n"},{"title":"[Deep Dive] 표현식과 문","date":"2022-10-18T11:52:43.000Z","_content":"변수에 대해 살펴보면서 지속적으로 값이라는 용어가 등장했다. 표현식과 문에 대해 알아보기 이전에 값이란 무엇인지 알아보자.\n\n<hr>\n\n# 값\n\n값이란 (표현)식이 평가되어 생성된 결과를 말한다.\n평가란 식을 해석해서 값을 생성하거나 참조하는 것을 의미한다.\n\n변수란 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이였다. 즉 변수에 할당되는 것은 값이다.\n\n값이란 어떻게 생성할 수 있을까? 가장 기본적인 방법은 리터럴을 사용하는 것이다.\n\n<hr>\n\n# 리터럴\n\n리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법이다.\n\n리터럴은 문자 또는 미리 약속된 기호로 표기한 코드이며 자바스크립트 엔진은 코드가 실행되는 시점인 런타임에 리터럴을 평가해 값을 생성한다.\n\n리터럴을 사용해 다양한 종류의 값을 생성할 수 있다.\n\n## 엔진은 어떻게 리터럴을 구별할까?\n\n리터럴은 값을 생성하기 위해 미리 약속한 표기법으로 자바스크립트 엔진 내부에 리터럴을 구분해 값을 생성 할 수 있도록 하드코딩 되어있다.\n\n<hr>\n\n리터럴 이외에 값을 생성하는 또 다른 방법에는 무엇이 있을까? 값에 대해 살펴보면서 언급했듯이 표현식이 존재한다.\n\n# 표현식\n\n표현식은 값으로 평가될 수 있는 문이다. 즉 표현식이 평가되면 새로운 값을 생성하거나 값을 참조한다.\n\n앞서 살펴본 리터럴은 값으로 평가된다. 그러므로 리터럴도 사실 표현식이다.\n\n표현식은 값으로 평가되는데, 이때 표현식과 표현식이 평가된 값은 동등한 관계이다.\n\n다음 예시를 살펴보자. 예를들어, 산술 연산자 + 의 좌항과 우항에는 숫자 값이 위치해야 한다. 이 때 표현식이 숫자 값으로 평가될 수 있다면 숫자 값 대신 사용할 수 있다.\n\n```javascript\nvar x = 1 + 2;\n\nx + 3; // 6\n```\n\n위 코드의 x + 3에서 + 연산자의 좌항과 우항에는 숫자 값이 위치해야 한다. 이 때 좌항 x 는 식별자 표현식이다. 즉 x는 할당되어 있는 숫자 값 3 으로 평가된다. 즉 표현식과 표현식이 평가된 값은 동치이며 이처럼 표현식은 다른 표현식의 일부가 되어 새로운 값을 만들어 낼 수 있다.\n\n<hr>\n\n앞서 표현식은 값으로 평가될 수 있는 문이라고 했다. 그럼 문이란 무엇일까?\n\n# 문\n\n문은 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다. 문은 여러 토큰으로 구성되는데, 토큰이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.\n\n문을 명령문이라고도 부른다. 문이 실행되면 명령이 실행되고 무슨 일인가가 일어나게 된다.\n\n문은 선언문, 할당문, 조건문, 반복문등 다양한 종류로 나누어진다.\n\n세미콜론을 통해 문의 종료를 나타낼 수 있다. 즉 자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행한다. 단 중괄호로 묶은 코드 블록은 자체 종결성을 가지므로 세미콜론을 붙이지 않는다.\n\n문의 끝에 붙이는 세미콜론은 옵션이다. 이는 자바스크립트 엔진이 소스코드를 해석하며 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 삽입하는 ASI를 수행하기 때문이다.\n\n<hr>\n\n그렇다면 표현식과 문은 어떻게 구별 할 수 있을까? 표현식도 문의 일부니 정확히 말하자면 표현식인 문과 표현식이 아닌 문을 어떻게 구별 할 수 있을까?\n\n# 표현식인 문과 표현식이 아닌 문\n\n표현식인 문은 값으로 평가될 수 있는 문이며, 표현식이 아닌 문은 값으로 평가될 수 없는 문을 말한다. 예를들어, 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아닌 문이다.\n\n표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단한 방법은 변수에 할당해 보는 것이다.\n\n변수는 값을 저장하기 위한 메모리 공간이였으므로 변수에 할당할 수 있는 문은 즉 값으로 평가된는 표현식이라고 볼 수 있다.\n\n","source":"_posts/Modern-Javascript-Deep-Dive-Chapter-5-Summary.md","raw":"---\ntitle: \"[Deep Dive] 표현식과 문\"\ndate: 2022-10-18 20:52:43\ntags:\n- 개발\n- 자바스크립트\n- 모던 자바스크립트 Deep Dive\n---\n변수에 대해 살펴보면서 지속적으로 값이라는 용어가 등장했다. 표현식과 문에 대해 알아보기 이전에 값이란 무엇인지 알아보자.\n\n<hr>\n\n# 값\n\n값이란 (표현)식이 평가되어 생성된 결과를 말한다.\n평가란 식을 해석해서 값을 생성하거나 참조하는 것을 의미한다.\n\n변수란 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이였다. 즉 변수에 할당되는 것은 값이다.\n\n값이란 어떻게 생성할 수 있을까? 가장 기본적인 방법은 리터럴을 사용하는 것이다.\n\n<hr>\n\n# 리터럴\n\n리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법이다.\n\n리터럴은 문자 또는 미리 약속된 기호로 표기한 코드이며 자바스크립트 엔진은 코드가 실행되는 시점인 런타임에 리터럴을 평가해 값을 생성한다.\n\n리터럴을 사용해 다양한 종류의 값을 생성할 수 있다.\n\n## 엔진은 어떻게 리터럴을 구별할까?\n\n리터럴은 값을 생성하기 위해 미리 약속한 표기법으로 자바스크립트 엔진 내부에 리터럴을 구분해 값을 생성 할 수 있도록 하드코딩 되어있다.\n\n<hr>\n\n리터럴 이외에 값을 생성하는 또 다른 방법에는 무엇이 있을까? 값에 대해 살펴보면서 언급했듯이 표현식이 존재한다.\n\n# 표현식\n\n표현식은 값으로 평가될 수 있는 문이다. 즉 표현식이 평가되면 새로운 값을 생성하거나 값을 참조한다.\n\n앞서 살펴본 리터럴은 값으로 평가된다. 그러므로 리터럴도 사실 표현식이다.\n\n표현식은 값으로 평가되는데, 이때 표현식과 표현식이 평가된 값은 동등한 관계이다.\n\n다음 예시를 살펴보자. 예를들어, 산술 연산자 + 의 좌항과 우항에는 숫자 값이 위치해야 한다. 이 때 표현식이 숫자 값으로 평가될 수 있다면 숫자 값 대신 사용할 수 있다.\n\n```javascript\nvar x = 1 + 2;\n\nx + 3; // 6\n```\n\n위 코드의 x + 3에서 + 연산자의 좌항과 우항에는 숫자 값이 위치해야 한다. 이 때 좌항 x 는 식별자 표현식이다. 즉 x는 할당되어 있는 숫자 값 3 으로 평가된다. 즉 표현식과 표현식이 평가된 값은 동치이며 이처럼 표현식은 다른 표현식의 일부가 되어 새로운 값을 만들어 낼 수 있다.\n\n<hr>\n\n앞서 표현식은 값으로 평가될 수 있는 문이라고 했다. 그럼 문이란 무엇일까?\n\n# 문\n\n문은 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다. 문은 여러 토큰으로 구성되는데, 토큰이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.\n\n문을 명령문이라고도 부른다. 문이 실행되면 명령이 실행되고 무슨 일인가가 일어나게 된다.\n\n문은 선언문, 할당문, 조건문, 반복문등 다양한 종류로 나누어진다.\n\n세미콜론을 통해 문의 종료를 나타낼 수 있다. 즉 자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행한다. 단 중괄호로 묶은 코드 블록은 자체 종결성을 가지므로 세미콜론을 붙이지 않는다.\n\n문의 끝에 붙이는 세미콜론은 옵션이다. 이는 자바스크립트 엔진이 소스코드를 해석하며 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 삽입하는 ASI를 수행하기 때문이다.\n\n<hr>\n\n그렇다면 표현식과 문은 어떻게 구별 할 수 있을까? 표현식도 문의 일부니 정확히 말하자면 표현식인 문과 표현식이 아닌 문을 어떻게 구별 할 수 있을까?\n\n# 표현식인 문과 표현식이 아닌 문\n\n표현식인 문은 값으로 평가될 수 있는 문이며, 표현식이 아닌 문은 값으로 평가될 수 없는 문을 말한다. 예를들어, 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아닌 문이다.\n\n표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단한 방법은 변수에 할당해 보는 것이다.\n\n변수는 값을 저장하기 위한 메모리 공간이였으므로 변수에 할당할 수 있는 문은 즉 값으로 평가된는 표현식이라고 볼 수 있다.\n\n","slug":"Modern-Javascript-Deep-Dive-Chapter-5-Summary","published":1,"updated":"2022-10-18T11:54:32.282Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb08iq6f000de4vk289d0odc","content":"<p>변수에 대해 살펴보면서 지속적으로 값이라는 용어가 등장했다. 표현식과 문에 대해 알아보기 이전에 값이란 무엇인지 알아보자.</p>\n<hr>\n\n<h1 id=\"값\"><a href=\"#값\" class=\"headerlink\" title=\"값\"></a>값</h1><p>값이란 (표현)식이 평가되어 생성된 결과를 말한다.<br>평가란 식을 해석해서 값을 생성하거나 참조하는 것을 의미한다.</p>\n<p>변수란 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이였다. 즉 변수에 할당되는 것은 값이다.</p>\n<p>값이란 어떻게 생성할 수 있을까? 가장 기본적인 방법은 리터럴을 사용하는 것이다.</p>\n<hr>\n\n<h1 id=\"리터럴\"><a href=\"#리터럴\" class=\"headerlink\" title=\"리터럴\"></a>리터럴</h1><p>리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법이다.</p>\n<p>리터럴은 문자 또는 미리 약속된 기호로 표기한 코드이며 자바스크립트 엔진은 코드가 실행되는 시점인 런타임에 리터럴을 평가해 값을 생성한다.</p>\n<p>리터럴을 사용해 다양한 종류의 값을 생성할 수 있다.</p>\n<h2 id=\"엔진은-어떻게-리터럴을-구별할까\"><a href=\"#엔진은-어떻게-리터럴을-구별할까\" class=\"headerlink\" title=\"엔진은 어떻게 리터럴을 구별할까?\"></a>엔진은 어떻게 리터럴을 구별할까?</h2><p>리터럴은 값을 생성하기 위해 미리 약속한 표기법으로 자바스크립트 엔진 내부에 리터럴을 구분해 값을 생성 할 수 있도록 하드코딩 되어있다.</p>\n<hr>\n\n<p>리터럴 이외에 값을 생성하는 또 다른 방법에는 무엇이 있을까? 값에 대해 살펴보면서 언급했듯이 표현식이 존재한다.</p>\n<h1 id=\"표현식\"><a href=\"#표현식\" class=\"headerlink\" title=\"표현식\"></a>표현식</h1><p>표현식은 값으로 평가될 수 있는 문이다. 즉 표현식이 평가되면 새로운 값을 생성하거나 값을 참조한다.</p>\n<p>앞서 살펴본 리터럴은 값으로 평가된다. 그러므로 리터럴도 사실 표현식이다.</p>\n<p>표현식은 값으로 평가되는데, 이때 표현식과 표현식이 평가된 값은 동등한 관계이다.</p>\n<p>다음 예시를 살펴보자. 예를들어, 산술 연산자 + 의 좌항과 우항에는 숫자 값이 위치해야 한다. 이 때 표현식이 숫자 값으로 평가될 수 있다면 숫자 값 대신 사용할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">x + <span class=\"number\">3</span>; <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n\n<p>위 코드의 x + 3에서 + 연산자의 좌항과 우항에는 숫자 값이 위치해야 한다. 이 때 좌항 x 는 식별자 표현식이다. 즉 x는 할당되어 있는 숫자 값 3 으로 평가된다. 즉 표현식과 표현식이 평가된 값은 동치이며 이처럼 표현식은 다른 표현식의 일부가 되어 새로운 값을 만들어 낼 수 있다.</p>\n<hr>\n\n<p>앞서 표현식은 값으로 평가될 수 있는 문이라고 했다. 그럼 문이란 무엇일까?</p>\n<h1 id=\"문\"><a href=\"#문\" class=\"headerlink\" title=\"문\"></a>문</h1><p>문은 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다. 문은 여러 토큰으로 구성되는데, 토큰이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.</p>\n<p>문을 명령문이라고도 부른다. 문이 실행되면 명령이 실행되고 무슨 일인가가 일어나게 된다.</p>\n<p>문은 선언문, 할당문, 조건문, 반복문등 다양한 종류로 나누어진다.</p>\n<p>세미콜론을 통해 문의 종료를 나타낼 수 있다. 즉 자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행한다. 단 중괄호로 묶은 코드 블록은 자체 종결성을 가지므로 세미콜론을 붙이지 않는다.</p>\n<p>문의 끝에 붙이는 세미콜론은 옵션이다. 이는 자바스크립트 엔진이 소스코드를 해석하며 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 삽입하는 ASI를 수행하기 때문이다.</p>\n<hr>\n\n<p>그렇다면 표현식과 문은 어떻게 구별 할 수 있을까? 표현식도 문의 일부니 정확히 말하자면 표현식인 문과 표현식이 아닌 문을 어떻게 구별 할 수 있을까?</p>\n<h1 id=\"표현식인-문과-표현식이-아닌-문\"><a href=\"#표현식인-문과-표현식이-아닌-문\" class=\"headerlink\" title=\"표현식인 문과 표현식이 아닌 문\"></a>표현식인 문과 표현식이 아닌 문</h1><p>표현식인 문은 값으로 평가될 수 있는 문이며, 표현식이 아닌 문은 값으로 평가될 수 없는 문을 말한다. 예를들어, 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아닌 문이다.</p>\n<p>표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단한 방법은 변수에 할당해 보는 것이다.</p>\n<p>변수는 값을 저장하기 위한 메모리 공간이였으므로 변수에 할당할 수 있는 문은 즉 값으로 평가된는 표현식이라고 볼 수 있다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>변수에 대해 살펴보면서 지속적으로 값이라는 용어가 등장했다. 표현식과 문에 대해 알아보기 이전에 값이란 무엇인지 알아보자.</p>\n<hr>\n\n<h1 id=\"값\"><a href=\"#값\" class=\"headerlink\" title=\"값\"></a>값</h1><p>값이란 (표현)식이 평가되어 생성된 결과를 말한다.<br>평가란 식을 해석해서 값을 생성하거나 참조하는 것을 의미한다.</p>\n<p>변수란 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이였다. 즉 변수에 할당되는 것은 값이다.</p>\n<p>값이란 어떻게 생성할 수 있을까? 가장 기본적인 방법은 리터럴을 사용하는 것이다.</p>\n<hr>\n\n<h1 id=\"리터럴\"><a href=\"#리터럴\" class=\"headerlink\" title=\"리터럴\"></a>리터럴</h1><p>리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법이다.</p>\n<p>리터럴은 문자 또는 미리 약속된 기호로 표기한 코드이며 자바스크립트 엔진은 코드가 실행되는 시점인 런타임에 리터럴을 평가해 값을 생성한다.</p>\n<p>리터럴을 사용해 다양한 종류의 값을 생성할 수 있다.</p>\n<h2 id=\"엔진은-어떻게-리터럴을-구별할까\"><a href=\"#엔진은-어떻게-리터럴을-구별할까\" class=\"headerlink\" title=\"엔진은 어떻게 리터럴을 구별할까?\"></a>엔진은 어떻게 리터럴을 구별할까?</h2><p>리터럴은 값을 생성하기 위해 미리 약속한 표기법으로 자바스크립트 엔진 내부에 리터럴을 구분해 값을 생성 할 수 있도록 하드코딩 되어있다.</p>\n<hr>\n\n<p>리터럴 이외에 값을 생성하는 또 다른 방법에는 무엇이 있을까? 값에 대해 살펴보면서 언급했듯이 표현식이 존재한다.</p>\n<h1 id=\"표현식\"><a href=\"#표현식\" class=\"headerlink\" title=\"표현식\"></a>표현식</h1><p>표현식은 값으로 평가될 수 있는 문이다. 즉 표현식이 평가되면 새로운 값을 생성하거나 값을 참조한다.</p>\n<p>앞서 살펴본 리터럴은 값으로 평가된다. 그러므로 리터럴도 사실 표현식이다.</p>\n<p>표현식은 값으로 평가되는데, 이때 표현식과 표현식이 평가된 값은 동등한 관계이다.</p>\n<p>다음 예시를 살펴보자. 예를들어, 산술 연산자 + 의 좌항과 우항에는 숫자 값이 위치해야 한다. 이 때 표현식이 숫자 값으로 평가될 수 있다면 숫자 값 대신 사용할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">x + <span class=\"number\">3</span>; <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n\n<p>위 코드의 x + 3에서 + 연산자의 좌항과 우항에는 숫자 값이 위치해야 한다. 이 때 좌항 x 는 식별자 표현식이다. 즉 x는 할당되어 있는 숫자 값 3 으로 평가된다. 즉 표현식과 표현식이 평가된 값은 동치이며 이처럼 표현식은 다른 표현식의 일부가 되어 새로운 값을 만들어 낼 수 있다.</p>\n<hr>\n\n<p>앞서 표현식은 값으로 평가될 수 있는 문이라고 했다. 그럼 문이란 무엇일까?</p>\n<h1 id=\"문\"><a href=\"#문\" class=\"headerlink\" title=\"문\"></a>문</h1><p>문은 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다. 문은 여러 토큰으로 구성되는데, 토큰이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.</p>\n<p>문을 명령문이라고도 부른다. 문이 실행되면 명령이 실행되고 무슨 일인가가 일어나게 된다.</p>\n<p>문은 선언문, 할당문, 조건문, 반복문등 다양한 종류로 나누어진다.</p>\n<p>세미콜론을 통해 문의 종료를 나타낼 수 있다. 즉 자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행한다. 단 중괄호로 묶은 코드 블록은 자체 종결성을 가지므로 세미콜론을 붙이지 않는다.</p>\n<p>문의 끝에 붙이는 세미콜론은 옵션이다. 이는 자바스크립트 엔진이 소스코드를 해석하며 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 삽입하는 ASI를 수행하기 때문이다.</p>\n<hr>\n\n<p>그렇다면 표현식과 문은 어떻게 구별 할 수 있을까? 표현식도 문의 일부니 정확히 말하자면 표현식인 문과 표현식이 아닌 문을 어떻게 구별 할 수 있을까?</p>\n<h1 id=\"표현식인-문과-표현식이-아닌-문\"><a href=\"#표현식인-문과-표현식이-아닌-문\" class=\"headerlink\" title=\"표현식인 문과 표현식이 아닌 문\"></a>표현식인 문과 표현식이 아닌 문</h1><p>표현식인 문은 값으로 평가될 수 있는 문이며, 표현식이 아닌 문은 값으로 평가될 수 없는 문을 말한다. 예를들어, 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아닌 문이다.</p>\n<p>표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단한 방법은 변수에 할당해 보는 것이다.</p>\n<p>변수는 값을 저장하기 위한 메모리 공간이였으므로 변수에 할당할 수 있는 문은 즉 값으로 평가된는 표현식이라고 볼 수 있다.</p>\n"},{"title":"[Deep Dive] 데이터 타입","date":"2022-10-19T12:48:29.000Z","_content":"데이터 타입은 값의 종류를 말한다. 자바스크립트의 모든 값은 데이터 타입을 갖는다. 자바스크립트는 8개의 데이터 타입을 가지며 7개의 원시 타입(primitive type)과 1개의 객체 타입(object/reference type)으로 분류 가능하다.\n\n데이터 타입의 종류에 따른 특징에 대해 살펴보고 데이터 타입이 왜 필요한지에 대해 알아보자.\n\n<hr>\n\n먼저 원시 타입에 대해 알아보자.\n\n# 원시 타입\n\n원시 타입에는 숫자(Number) 타입, Bigint 타입, 문자열(String) 타입, 불리언(Boolean) 타입, undefined 타입, null 타입, 심벌(Symbol) 타입이 존재한다. 순서대로 각 타입에 대해 살펴보겠다.\n\n## 숫자 타입\n\n타 프로그래밍 언어에서는 정수(소수점 이하가 없는 숫자)와 실수(소수점 이하가 있는 숫자)를 구분해 int, long, float, double 등과 같은 다양한 숫자 타입을 제공한다. 하지만 자바스크립트는 독특하게 하나의 숫자 타입만 존재한다.\n\n자바스크립트의 숫자 타입의 값은 배정밀도 64비트 부동소수점 형식을 따르기 때문에 모든 수를 실수로 처리한다.\n\n숫자 타입은 추가적으로 세가지 특별한 값을 표현할 수 있다.\n\n> - Infinity : 양의 무한대\n> - -Infinity : 음의 무한대\n> - NaN : 산술 연산 불가(Not-a-Number)\n\n자바스크립트는 대소문자를 구별하므로 NaN을 NAN,Nan,nan과 같이 표현하면 에러가 발생한다. 자바스크립트는 NAN,Nan,nan을 식별자로 해석한다.\n\n```javascript\nvar x = nan; // ReferenceError: nan is not defined\n```\n\n### 부동소수점 형식이란?\n\n부동소수점 형식은 실수를 컴퓨터 상에서 근사하여 표현할 때 소수점의 위치를 고정하지 않고 그 위치를 나타내는 수를 따로 적는 것으로, 유효숫자를 나타내는 가수와 소수점의 위치를 풀이하는 지수로 나누어 표현한다.\n\n몇 비트를 기반으로 하는지에 따라 정밀도가 달라지며 32비트를 단정밀도, 64비트를 배정밀도라 한다.\n\n32비트의 경우는 부호 1비트 + 지수 8비트 + 가수 23비트로 나누어지며 64비트는 부호 1비트 + 지수 11비트 + 가수 52비트로 나누어진다.\n\n지수부 계산시 bias를 더해줌으로 음수값을 가지는 지수와 양수값을 가지는 지수를 폭 넓게 표현 가능하다. (bias: 32비트-127, 64비트-1023)\n\n## Bigint 타입\n\n자바스크립트의 숫자 타입은 64비트 부동소수점 형식의 2진수로 저장된다고 했다. 64비트 부동소수점 형식으로 안정적으로 나타낼 수 있는 최대치는 2^53^ - 1이다.\n\n대부분의 소규모 프로그래밍이나 웹 개발에서 안정적으로 나타낼 수 있는 수의 최대치가 존재하는것이 큰 문제는 아니었다.\n하지만 자바스크립트가 백엔드 언어로서도 점점 유용해지고 데이터베이스에서도 사용하게 되면서 큰 정수 ID나 고정밀 타임 스탬프를 표현해야 하는 일이 생기게 되었다.\n\nES11에서는 기존의 숫자 타입보다 큰 수를 표현할 수 있도록 새로운 원시 값인 Bigint 타입을 추가하게 되었다.\n\nBigint 값은 정수 리터럴 뒤에 n을 붙이거나 Bigint 함수를 호출해 생성할 수 있다.\n\n```javascript\nvar a = 10n;\nvar b = BigInt(10);\n```\n\n## 문자열 타입\n\n문자열 타입은 텍스트 데이터를 나타내는 데 사용한다. 문자열은 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합이다.\n\n문자열은 작은따옴표(''), 큰 따옴표(\"\"), 백틱(``)으로 텍스트를 감싼다.\n\n다른 타입의 값과 달리 문자열을 따옴표로 감싸는 이유는 키워드나 식별자와 같은 토큰과 구분하기 위함이다. 만약 문자열을 따옴표로 감싸지 않으면 자바스크립트 엔진은 이를 키워드나 식별자 같은 토큰으로 인식한다.\n\n```javascript\nvar str = hello; // ReferenceError: hello is not defined\n```\n\n### 템플릿 리터럴\n\nES6부터 템플릿 리터럴이라고 하는 새로운 문자열 표기법이 도입되었다.\n\n템플릿(template)의 뜻은 주형이며 리터럴(literal)의 뜻은 정확한이다. 이를 해석해보면 정확한 주형이란 뜻이 되는데 템플릿 리터럴은 해석 그대로 리터럴 내부의 문자열을 정확히 표현한다고 생각하면 편하다.\n\n템플릿 리터럴은 백틱(``)으로 감싸 표현하며 멀티라인 문자열, 표현식 삽입, 태그드 템플릿과 같은 편리한 문자열 처리 기능을 제공한다.\n\n### 일반 문자열과는 어떤 차이가 있을까?\n\n템플릿 리터럴은 멀티라인 문자열, 표현식 삽입과 같은 편리한 기능을 제공한다고 했다. 그럼 위 기능들이 제공되지 않는다는 소리인데 일반 문자열은 어떻게 개행과 문자열의 연결을 수행했을까?\n\n> 일반 문자열은 공백과 같은 특수 문자를 표현하기 위해 백스페이스(\\)로 시작하는 이스케이프 시퀀스를 이용한다.\n>\n> - `\\0(null), \\b(백스페이스), \\f(폼 피드, 프린터로 출력시 다음 페이지 시작지점으로 이동), \\n(개행 LF), \\r(개행 CR), \\t(수평 탭), \\v(수직 탭), \\'(작은 따옴표), \\\"(큰 따옴표), \\\\(백슬래시)`\n\n> 일반 문자열은 문자열 연결 연산자 +를 이용하지만 템플릿 리터럴은 표현식 삽입(${})을 이용해 문자열을 연결한다.\n>\n> ```javascript\n> var fisrst = 'rong';\n> var last = 'rong';\n>\n> console.log('My name is ' + first + last + '.'); // ES5의 문자열 연결, My name is rongrong.\n>\n> console.log(`My name is ${first}${last}.`); // ES6 템플릿 리터럴의 표현식 삽입, My name is rongrong.\n> ```\n\n## 불리언 타입\n\n불리언 타입의 값은 논리적 참, 거짓을 나타내는 true와 false가 있다.\n\n불리언 타입의 값은 참과 거짓으로 구분되는 조건에 의해 프로그램의 흐름을 제어하는 조건문에서 자주 사용된다.\n\n## undefined 타입\n\nundefined 타입의 값은 undefined가 유일하다.\n\n앞서서 var 키워드로 선언한 변수는 암묵적으로 undefined로 초기화 되는것을 살펴보았다.\n이처럼 undefined는 개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화 할 때 사용하는 값이다.\n변수를 참조했을 때 undefined가 반환된다면 참조한 변수가 선언 이후 초기화되지 않은 변수임을 알 수 있다.\n\nundefined를 개발자가 의도적으로 변수에 할당하는 것은 본래 취지와 어긋날뿐더러 혼란을 줄 수 있으므로 좋지 않다.\n\n그렇다면 변수에 값이 없다는 것을 명시하고 싶을 때는 어떻게 하면 좋을까? null을 할당해주면 된다.\n\n## null 타입\n\nnull 타입의 값은 null이 유일하다. 자바스크립트는 대소문자를 구별하므로 null은 Null, NULL 등과 다르다.\n\n프로그래밍 언어에서 null은 변수에 값이 없다는 것을 의도적으로 명시할 때 사용한다. 변수에 null을 할당하는 것은 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미이다.\n\n함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 한다. 예를들어, HTML 요소를 검색해 반환하는 document.querySelector 메서드는 조건에 부합하는 HTML 요소를 검색할 수 없는 경우 에러가 아닌 null을 반환한다.\n\n```HTML\n<!DOCTYPE html>\n<html>\n<body>\n  <script>\n    var element = document.querySelector('.myClass');\n\n    console.log(element); // null\n  </script>\n</body>\n</html>\n```\n\n## 심벌 타입\n\n심벌은 ES6에서 추가된 타입으로, 변경 불가능한 원시 타입의 값이다. 심벌 값은 다른 값과 중복되지 않는 유일무이한 값이다.\n따라서 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.\n\n심벌값은 리터럴이 아닌 Symbol 함수를 호출해 생성한다.\n\n<hr>\n\n# 객체 타입\n\n자바스크립트는 크게 원시 타입과 객체 타입으로 분류한다. 이는 객체 타입이 다른 원시 타입들과는 다른 특성을 가짐을 의미한다.\n\n객체 타입에 대해서는 다음에 자세하게 알아보도록 하겠다.\n\n<hr>\n\n지금 까지 자바스크립트의 8가지 데이터 타입에 대해 알아보았다. 그렇다면 데이터 타입은 왜 필요한 것일까?\n\n# 데이터 타입의 필요성\n\n값은 메모리에 저장하고 참조할 수 있어야 한다. 값을 메모리에 저장하기 위해서는 값이 들어가기 위한 메모리 공간의 크기를 결정해야 한다.\n즉 몇 바이트의 메모리 공간을 사용해야 낭비와 손실 없이 값을 저장할 수 있는지 알아야 한다.\n\n다음과 같은 코드를 실행해보자.\n\n```javascript\nvar score = 100;\n```\n\n자바스크립트 엔진은 정수 리터럴 100을 평가해 숫자 타입의 값 100을 만들어 score라는 변수에 할당한다.\n자바스크립트의 숫자 타입은 64비트 부동소수점 방식을 따른다고 했으니 숫자 타입의 값을 저장하기 위해서는 8바이트의 공간이 필요할 것이다.\n\n이처럼 자바스크립트 엔진은 데이터 타입, 즉 값의 종류에 따라 정해진 크기의 메모리 공간을 확보한다.\n\n이번에는 값을 참조하는 경우를 생각해보자. 식별자 score를 통해 숫자 타입의 값 100이 저장되어 있는 메모리 공간의 주소를 찾아갈 수 있다.\n이 때 값을 참조하려면 한 번에 읽어 들여야 할 메모리 공간의 크기를 알아야 한다. score 변수의 경우, 저장되어 있는 값이 숫자 타입이므로 8바이트 단위로 읽어 들이지 않는다면 값이 훼손될 것이다.\n\n역시 자바스크립트 엔진은 데이터 타입을 통해 한번에 읽어 들여야 할 메모리 공간의 크기를 결정한다.\n\n아직 문제가 남아 있다. 메모리에서 읽어 들인 2진수를 어떻게 해석해야 하느냐다.\n모든 값은 데이터 타입을 가지며 메모리에 2진수로 저장된다. 메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있다. 예를 들어, 메모리에 저장된 값 0100 0001을 숫자로 해석하면 65지만 문자열로 해석하면 'A'이다.\n\n자바스크립트 엔진은 데이터 타입에 따라 메모리 공간에서 읽어들인 2진수를 해석한다.\n\n정리하자면 다음과 같은 이유로 데이터 타입이 필요하다고 할 수 있다.\n\n> - 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해\n> - 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해\n> - 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해\n\n<hr>\n\n자바스크립트의 모든 값은 데이터 타입을 가진다. 그렇다면 변수 역시 데이터 타입을 가질까?\n\nC나 자바와 같은 정적 타입 언어는 변수를 선언할 때 변수에 할당할 수 있는 값의 종류(데이터 타입)을 사전에 선언해야 한다. 이를 명시적 타입 선언이라 한다.\n\n정적 타입 언어는 변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있다.\n\n자바스크립트는 정적 타입 언어와 다르게 변수를 선언할 때 타입을 선언하지 않고 var, let, const 키워드만 사용해 변수를 선언한다.\n자바스크립트의 변수는 어떠한 데이터 타입의 값이라도 자유롭게 할당할 수 있다. 따라서 자바스크립트의 데이터 타입은 정적 타입 언어의 데이터 타입과는 개념이 다르다.\n\n자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론)된다. 그리고 재할당에 의해 변수의 데이터 타입이 언제든지 동적으로 변할 수 있다. 이러한 특징을 동적 타이핑이라 하며, 정적 타입 언어와 구분하기 위해 동적 타입 언어라 한다.\n\n동적 타입 언어는 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당 가능하므로 편리하다. 하지만 이로 인한 구조적인 단점 역시 존재한다.\n변수 값은 언제든지 변경될 수 있기 때문에 복잡한 프로그램에서는 변화하는 변수 값을 추적하기 어려울 수 있다.\n\n그 뿐만 아니라 값의 변경에 의해서도 타입도 언제든 변경될 수 있다. 따라서 동적 타입 언어의 변수는 값을 확인하기 전 타입을 확신할 수 없다.\n또 자바스크립트는 개발자의 의도와는 관계없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환하는 경우도 존재한다.\n\n이처럼 동적 타입 언어는 유연성은 높지만 신뢰성은 떨어진다.\n\n> 이러한 단점을 해결하기 위해 자바스크립트를 정적 타입 언어처럼 사용할 수 있는 타입스크립트가 등장했다. 웹의 규모가 커지면서 더 복잡한 프로그램을 만들어야 하는 경우가 많아지고 있고 따라서 타입스크립트를 다룬 경험을 요구하는 기업 또한 많아지고 있다. 자바스크립트의 동적인 부분이 단점으로 다가오는 경우가 많은것 같다. 이런 부분에 대해서도 고민이 필요할 것 같다.\n\n","source":"_posts/Modern-Javascript-Deep-Dive-Chapter-6-Data-Type-Summary.md","raw":"---\ntitle: \"[Deep Dive] 데이터 타입\"\ndate: 2022-10-19 21:48:29\ntags:\n- 개발\n- 자바스크립트\n- 모던 자바스크립트 Deep Dive\n---\n데이터 타입은 값의 종류를 말한다. 자바스크립트의 모든 값은 데이터 타입을 갖는다. 자바스크립트는 8개의 데이터 타입을 가지며 7개의 원시 타입(primitive type)과 1개의 객체 타입(object/reference type)으로 분류 가능하다.\n\n데이터 타입의 종류에 따른 특징에 대해 살펴보고 데이터 타입이 왜 필요한지에 대해 알아보자.\n\n<hr>\n\n먼저 원시 타입에 대해 알아보자.\n\n# 원시 타입\n\n원시 타입에는 숫자(Number) 타입, Bigint 타입, 문자열(String) 타입, 불리언(Boolean) 타입, undefined 타입, null 타입, 심벌(Symbol) 타입이 존재한다. 순서대로 각 타입에 대해 살펴보겠다.\n\n## 숫자 타입\n\n타 프로그래밍 언어에서는 정수(소수점 이하가 없는 숫자)와 실수(소수점 이하가 있는 숫자)를 구분해 int, long, float, double 등과 같은 다양한 숫자 타입을 제공한다. 하지만 자바스크립트는 독특하게 하나의 숫자 타입만 존재한다.\n\n자바스크립트의 숫자 타입의 값은 배정밀도 64비트 부동소수점 형식을 따르기 때문에 모든 수를 실수로 처리한다.\n\n숫자 타입은 추가적으로 세가지 특별한 값을 표현할 수 있다.\n\n> - Infinity : 양의 무한대\n> - -Infinity : 음의 무한대\n> - NaN : 산술 연산 불가(Not-a-Number)\n\n자바스크립트는 대소문자를 구별하므로 NaN을 NAN,Nan,nan과 같이 표현하면 에러가 발생한다. 자바스크립트는 NAN,Nan,nan을 식별자로 해석한다.\n\n```javascript\nvar x = nan; // ReferenceError: nan is not defined\n```\n\n### 부동소수점 형식이란?\n\n부동소수점 형식은 실수를 컴퓨터 상에서 근사하여 표현할 때 소수점의 위치를 고정하지 않고 그 위치를 나타내는 수를 따로 적는 것으로, 유효숫자를 나타내는 가수와 소수점의 위치를 풀이하는 지수로 나누어 표현한다.\n\n몇 비트를 기반으로 하는지에 따라 정밀도가 달라지며 32비트를 단정밀도, 64비트를 배정밀도라 한다.\n\n32비트의 경우는 부호 1비트 + 지수 8비트 + 가수 23비트로 나누어지며 64비트는 부호 1비트 + 지수 11비트 + 가수 52비트로 나누어진다.\n\n지수부 계산시 bias를 더해줌으로 음수값을 가지는 지수와 양수값을 가지는 지수를 폭 넓게 표현 가능하다. (bias: 32비트-127, 64비트-1023)\n\n## Bigint 타입\n\n자바스크립트의 숫자 타입은 64비트 부동소수점 형식의 2진수로 저장된다고 했다. 64비트 부동소수점 형식으로 안정적으로 나타낼 수 있는 최대치는 2^53^ - 1이다.\n\n대부분의 소규모 프로그래밍이나 웹 개발에서 안정적으로 나타낼 수 있는 수의 최대치가 존재하는것이 큰 문제는 아니었다.\n하지만 자바스크립트가 백엔드 언어로서도 점점 유용해지고 데이터베이스에서도 사용하게 되면서 큰 정수 ID나 고정밀 타임 스탬프를 표현해야 하는 일이 생기게 되었다.\n\nES11에서는 기존의 숫자 타입보다 큰 수를 표현할 수 있도록 새로운 원시 값인 Bigint 타입을 추가하게 되었다.\n\nBigint 값은 정수 리터럴 뒤에 n을 붙이거나 Bigint 함수를 호출해 생성할 수 있다.\n\n```javascript\nvar a = 10n;\nvar b = BigInt(10);\n```\n\n## 문자열 타입\n\n문자열 타입은 텍스트 데이터를 나타내는 데 사용한다. 문자열은 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합이다.\n\n문자열은 작은따옴표(''), 큰 따옴표(\"\"), 백틱(``)으로 텍스트를 감싼다.\n\n다른 타입의 값과 달리 문자열을 따옴표로 감싸는 이유는 키워드나 식별자와 같은 토큰과 구분하기 위함이다. 만약 문자열을 따옴표로 감싸지 않으면 자바스크립트 엔진은 이를 키워드나 식별자 같은 토큰으로 인식한다.\n\n```javascript\nvar str = hello; // ReferenceError: hello is not defined\n```\n\n### 템플릿 리터럴\n\nES6부터 템플릿 리터럴이라고 하는 새로운 문자열 표기법이 도입되었다.\n\n템플릿(template)의 뜻은 주형이며 리터럴(literal)의 뜻은 정확한이다. 이를 해석해보면 정확한 주형이란 뜻이 되는데 템플릿 리터럴은 해석 그대로 리터럴 내부의 문자열을 정확히 표현한다고 생각하면 편하다.\n\n템플릿 리터럴은 백틱(``)으로 감싸 표현하며 멀티라인 문자열, 표현식 삽입, 태그드 템플릿과 같은 편리한 문자열 처리 기능을 제공한다.\n\n### 일반 문자열과는 어떤 차이가 있을까?\n\n템플릿 리터럴은 멀티라인 문자열, 표현식 삽입과 같은 편리한 기능을 제공한다고 했다. 그럼 위 기능들이 제공되지 않는다는 소리인데 일반 문자열은 어떻게 개행과 문자열의 연결을 수행했을까?\n\n> 일반 문자열은 공백과 같은 특수 문자를 표현하기 위해 백스페이스(\\)로 시작하는 이스케이프 시퀀스를 이용한다.\n>\n> - `\\0(null), \\b(백스페이스), \\f(폼 피드, 프린터로 출력시 다음 페이지 시작지점으로 이동), \\n(개행 LF), \\r(개행 CR), \\t(수평 탭), \\v(수직 탭), \\'(작은 따옴표), \\\"(큰 따옴표), \\\\(백슬래시)`\n\n> 일반 문자열은 문자열 연결 연산자 +를 이용하지만 템플릿 리터럴은 표현식 삽입(${})을 이용해 문자열을 연결한다.\n>\n> ```javascript\n> var fisrst = 'rong';\n> var last = 'rong';\n>\n> console.log('My name is ' + first + last + '.'); // ES5의 문자열 연결, My name is rongrong.\n>\n> console.log(`My name is ${first}${last}.`); // ES6 템플릿 리터럴의 표현식 삽입, My name is rongrong.\n> ```\n\n## 불리언 타입\n\n불리언 타입의 값은 논리적 참, 거짓을 나타내는 true와 false가 있다.\n\n불리언 타입의 값은 참과 거짓으로 구분되는 조건에 의해 프로그램의 흐름을 제어하는 조건문에서 자주 사용된다.\n\n## undefined 타입\n\nundefined 타입의 값은 undefined가 유일하다.\n\n앞서서 var 키워드로 선언한 변수는 암묵적으로 undefined로 초기화 되는것을 살펴보았다.\n이처럼 undefined는 개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화 할 때 사용하는 값이다.\n변수를 참조했을 때 undefined가 반환된다면 참조한 변수가 선언 이후 초기화되지 않은 변수임을 알 수 있다.\n\nundefined를 개발자가 의도적으로 변수에 할당하는 것은 본래 취지와 어긋날뿐더러 혼란을 줄 수 있으므로 좋지 않다.\n\n그렇다면 변수에 값이 없다는 것을 명시하고 싶을 때는 어떻게 하면 좋을까? null을 할당해주면 된다.\n\n## null 타입\n\nnull 타입의 값은 null이 유일하다. 자바스크립트는 대소문자를 구별하므로 null은 Null, NULL 등과 다르다.\n\n프로그래밍 언어에서 null은 변수에 값이 없다는 것을 의도적으로 명시할 때 사용한다. 변수에 null을 할당하는 것은 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미이다.\n\n함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 한다. 예를들어, HTML 요소를 검색해 반환하는 document.querySelector 메서드는 조건에 부합하는 HTML 요소를 검색할 수 없는 경우 에러가 아닌 null을 반환한다.\n\n```HTML\n<!DOCTYPE html>\n<html>\n<body>\n  <script>\n    var element = document.querySelector('.myClass');\n\n    console.log(element); // null\n  </script>\n</body>\n</html>\n```\n\n## 심벌 타입\n\n심벌은 ES6에서 추가된 타입으로, 변경 불가능한 원시 타입의 값이다. 심벌 값은 다른 값과 중복되지 않는 유일무이한 값이다.\n따라서 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.\n\n심벌값은 리터럴이 아닌 Symbol 함수를 호출해 생성한다.\n\n<hr>\n\n# 객체 타입\n\n자바스크립트는 크게 원시 타입과 객체 타입으로 분류한다. 이는 객체 타입이 다른 원시 타입들과는 다른 특성을 가짐을 의미한다.\n\n객체 타입에 대해서는 다음에 자세하게 알아보도록 하겠다.\n\n<hr>\n\n지금 까지 자바스크립트의 8가지 데이터 타입에 대해 알아보았다. 그렇다면 데이터 타입은 왜 필요한 것일까?\n\n# 데이터 타입의 필요성\n\n값은 메모리에 저장하고 참조할 수 있어야 한다. 값을 메모리에 저장하기 위해서는 값이 들어가기 위한 메모리 공간의 크기를 결정해야 한다.\n즉 몇 바이트의 메모리 공간을 사용해야 낭비와 손실 없이 값을 저장할 수 있는지 알아야 한다.\n\n다음과 같은 코드를 실행해보자.\n\n```javascript\nvar score = 100;\n```\n\n자바스크립트 엔진은 정수 리터럴 100을 평가해 숫자 타입의 값 100을 만들어 score라는 변수에 할당한다.\n자바스크립트의 숫자 타입은 64비트 부동소수점 방식을 따른다고 했으니 숫자 타입의 값을 저장하기 위해서는 8바이트의 공간이 필요할 것이다.\n\n이처럼 자바스크립트 엔진은 데이터 타입, 즉 값의 종류에 따라 정해진 크기의 메모리 공간을 확보한다.\n\n이번에는 값을 참조하는 경우를 생각해보자. 식별자 score를 통해 숫자 타입의 값 100이 저장되어 있는 메모리 공간의 주소를 찾아갈 수 있다.\n이 때 값을 참조하려면 한 번에 읽어 들여야 할 메모리 공간의 크기를 알아야 한다. score 변수의 경우, 저장되어 있는 값이 숫자 타입이므로 8바이트 단위로 읽어 들이지 않는다면 값이 훼손될 것이다.\n\n역시 자바스크립트 엔진은 데이터 타입을 통해 한번에 읽어 들여야 할 메모리 공간의 크기를 결정한다.\n\n아직 문제가 남아 있다. 메모리에서 읽어 들인 2진수를 어떻게 해석해야 하느냐다.\n모든 값은 데이터 타입을 가지며 메모리에 2진수로 저장된다. 메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있다. 예를 들어, 메모리에 저장된 값 0100 0001을 숫자로 해석하면 65지만 문자열로 해석하면 'A'이다.\n\n자바스크립트 엔진은 데이터 타입에 따라 메모리 공간에서 읽어들인 2진수를 해석한다.\n\n정리하자면 다음과 같은 이유로 데이터 타입이 필요하다고 할 수 있다.\n\n> - 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해\n> - 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해\n> - 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해\n\n<hr>\n\n자바스크립트의 모든 값은 데이터 타입을 가진다. 그렇다면 변수 역시 데이터 타입을 가질까?\n\nC나 자바와 같은 정적 타입 언어는 변수를 선언할 때 변수에 할당할 수 있는 값의 종류(데이터 타입)을 사전에 선언해야 한다. 이를 명시적 타입 선언이라 한다.\n\n정적 타입 언어는 변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있다.\n\n자바스크립트는 정적 타입 언어와 다르게 변수를 선언할 때 타입을 선언하지 않고 var, let, const 키워드만 사용해 변수를 선언한다.\n자바스크립트의 변수는 어떠한 데이터 타입의 값이라도 자유롭게 할당할 수 있다. 따라서 자바스크립트의 데이터 타입은 정적 타입 언어의 데이터 타입과는 개념이 다르다.\n\n자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론)된다. 그리고 재할당에 의해 변수의 데이터 타입이 언제든지 동적으로 변할 수 있다. 이러한 특징을 동적 타이핑이라 하며, 정적 타입 언어와 구분하기 위해 동적 타입 언어라 한다.\n\n동적 타입 언어는 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당 가능하므로 편리하다. 하지만 이로 인한 구조적인 단점 역시 존재한다.\n변수 값은 언제든지 변경될 수 있기 때문에 복잡한 프로그램에서는 변화하는 변수 값을 추적하기 어려울 수 있다.\n\n그 뿐만 아니라 값의 변경에 의해서도 타입도 언제든 변경될 수 있다. 따라서 동적 타입 언어의 변수는 값을 확인하기 전 타입을 확신할 수 없다.\n또 자바스크립트는 개발자의 의도와는 관계없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환하는 경우도 존재한다.\n\n이처럼 동적 타입 언어는 유연성은 높지만 신뢰성은 떨어진다.\n\n> 이러한 단점을 해결하기 위해 자바스크립트를 정적 타입 언어처럼 사용할 수 있는 타입스크립트가 등장했다. 웹의 규모가 커지면서 더 복잡한 프로그램을 만들어야 하는 경우가 많아지고 있고 따라서 타입스크립트를 다룬 경험을 요구하는 기업 또한 많아지고 있다. 자바스크립트의 동적인 부분이 단점으로 다가오는 경우가 많은것 같다. 이런 부분에 대해서도 고민이 필요할 것 같다.\n\n","slug":"Modern-Javascript-Deep-Dive-Chapter-6-Data-Type-Summary","published":1,"updated":"2022-10-20T08:37:02.877Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb08iq6g000ge4vk22zyclq8","content":"<p>데이터 타입은 값의 종류를 말한다. 자바스크립트의 모든 값은 데이터 타입을 갖는다. 자바스크립트는 8개의 데이터 타입을 가지며 7개의 원시 타입(primitive type)과 1개의 객체 타입(object&#x2F;reference type)으로 분류 가능하다.</p>\n<p>데이터 타입의 종류에 따른 특징에 대해 살펴보고 데이터 타입이 왜 필요한지에 대해 알아보자.</p>\n<hr>\n\n<p>먼저 원시 타입에 대해 알아보자.</p>\n<h1 id=\"원시-타입\"><a href=\"#원시-타입\" class=\"headerlink\" title=\"원시 타입\"></a>원시 타입</h1><p>원시 타입에는 숫자(Number) 타입, Bigint 타입, 문자열(String) 타입, 불리언(Boolean) 타입, undefined 타입, null 타입, 심벌(Symbol) 타입이 존재한다. 순서대로 각 타입에 대해 살펴보겠다.</p>\n<h2 id=\"숫자-타입\"><a href=\"#숫자-타입\" class=\"headerlink\" title=\"숫자 타입\"></a>숫자 타입</h2><p>타 프로그래밍 언어에서는 정수(소수점 이하가 없는 숫자)와 실수(소수점 이하가 있는 숫자)를 구분해 int, long, float, double 등과 같은 다양한 숫자 타입을 제공한다. 하지만 자바스크립트는 독특하게 하나의 숫자 타입만 존재한다.</p>\n<p>자바스크립트의 숫자 타입의 값은 배정밀도 64비트 부동소수점 형식을 따르기 때문에 모든 수를 실수로 처리한다.</p>\n<p>숫자 타입은 추가적으로 세가지 특별한 값을 표현할 수 있다.</p>\n<blockquote>\n<ul>\n<li>Infinity : 양의 무한대</li>\n<li>-Infinity : 음의 무한대</li>\n<li>NaN : 산술 연산 불가(Not-a-Number)</li>\n</ul>\n</blockquote>\n<p>자바스크립트는 대소문자를 구별하므로 NaN을 NAN,Nan,nan과 같이 표현하면 에러가 발생한다. 자바스크립트는 NAN,Nan,nan을 식별자로 해석한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = nan; <span class=\"comment\">// ReferenceError: nan is not defined</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"부동소수점-형식이란\"><a href=\"#부동소수점-형식이란\" class=\"headerlink\" title=\"부동소수점 형식이란?\"></a>부동소수점 형식이란?</h3><p>부동소수점 형식은 실수를 컴퓨터 상에서 근사하여 표현할 때 소수점의 위치를 고정하지 않고 그 위치를 나타내는 수를 따로 적는 것으로, 유효숫자를 나타내는 가수와 소수점의 위치를 풀이하는 지수로 나누어 표현한다.</p>\n<p>몇 비트를 기반으로 하는지에 따라 정밀도가 달라지며 32비트를 단정밀도, 64비트를 배정밀도라 한다.</p>\n<p>32비트의 경우는 부호 1비트 + 지수 8비트 + 가수 23비트로 나누어지며 64비트는 부호 1비트 + 지수 11비트 + 가수 52비트로 나누어진다.</p>\n<p>지수부 계산시 bias를 더해줌으로 음수값을 가지는 지수와 양수값을 가지는 지수를 폭 넓게 표현 가능하다. (bias: 32비트-127, 64비트-1023)</p>\n<h2 id=\"Bigint-타입\"><a href=\"#Bigint-타입\" class=\"headerlink\" title=\"Bigint 타입\"></a>Bigint 타입</h2><p>자바스크립트의 숫자 타입은 64비트 부동소수점 형식의 2진수로 저장된다고 했다. 64비트 부동소수점 형식으로 안정적으로 나타낼 수 있는 최대치는 2^53^ - 1이다.</p>\n<p>대부분의 소규모 프로그래밍이나 웹 개발에서 안정적으로 나타낼 수 있는 수의 최대치가 존재하는것이 큰 문제는 아니었다.<br>하지만 자바스크립트가 백엔드 언어로서도 점점 유용해지고 데이터베이스에서도 사용하게 되면서 큰 정수 ID나 고정밀 타임 스탬프를 표현해야 하는 일이 생기게 되었다.</p>\n<p>ES11에서는 기존의 숫자 타입보다 큰 수를 표현할 수 있도록 새로운 원시 값인 Bigint 타입을 추가하게 되었다.</p>\n<p>Bigint 값은 정수 리터럴 뒤에 n을 붙이거나 Bigint 함수를 호출해 생성할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10n</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"title class_\">BigInt</span>(<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"문자열-타입\"><a href=\"#문자열-타입\" class=\"headerlink\" title=\"문자열 타입\"></a>문자열 타입</h2><p>문자열 타입은 텍스트 데이터를 나타내는 데 사용한다. 문자열은 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합이다.</p>\n<p>문자열은 작은따옴표(‘’), 큰 따옴표(“”), 백틱(&#96;&#96;)으로 텍스트를 감싼다.</p>\n<p>다른 타입의 값과 달리 문자열을 따옴표로 감싸는 이유는 키워드나 식별자와 같은 토큰과 구분하기 위함이다. 만약 문자열을 따옴표로 감싸지 않으면 자바스크립트 엔진은 이를 키워드나 식별자 같은 토큰으로 인식한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = hello; <span class=\"comment\">// ReferenceError: hello is not defined</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"템플릿-리터럴\"><a href=\"#템플릿-리터럴\" class=\"headerlink\" title=\"템플릿 리터럴\"></a>템플릿 리터럴</h3><p>ES6부터 템플릿 리터럴이라고 하는 새로운 문자열 표기법이 도입되었다.</p>\n<p>템플릿(template)의 뜻은 주형이며 리터럴(literal)의 뜻은 정확한이다. 이를 해석해보면 정확한 주형이란 뜻이 되는데 템플릿 리터럴은 해석 그대로 리터럴 내부의 문자열을 정확히 표현한다고 생각하면 편하다.</p>\n<p>템플릿 리터럴은 백틱(&#96;&#96;)으로 감싸 표현하며 멀티라인 문자열, 표현식 삽입, 태그드 템플릿과 같은 편리한 문자열 처리 기능을 제공한다.</p>\n<h3 id=\"일반-문자열과는-어떤-차이가-있을까\"><a href=\"#일반-문자열과는-어떤-차이가-있을까\" class=\"headerlink\" title=\"일반 문자열과는 어떤 차이가 있을까?\"></a>일반 문자열과는 어떤 차이가 있을까?</h3><p>템플릿 리터럴은 멀티라인 문자열, 표현식 삽입과 같은 편리한 기능을 제공한다고 했다. 그럼 위 기능들이 제공되지 않는다는 소리인데 일반 문자열은 어떻게 개행과 문자열의 연결을 수행했을까?</p>\n<blockquote>\n<p>일반 문자열은 공백과 같은 특수 문자를 표현하기 위해 백스페이스()로 시작하는 이스케이프 시퀀스를 이용한다.</p>\n<ul>\n<li><code>\\0(null), \\b(백스페이스), \\f(폼 피드, 프린터로 출력시 다음 페이지 시작지점으로 이동), \\n(개행 LF), \\r(개행 CR), \\t(수평 탭), \\v(수직 탭), \\&#39;(작은 따옴표), \\&quot;(큰 따옴표), \\\\(백슬래시)</code></li>\n</ul>\n</blockquote>\n<blockquote>\n<p>일반 문자열은 문자열 연결 연산자 +를 이용하지만 템플릿 리터럴은 표현식 삽입(${})을 이용해 문자열을 연결한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fisrst = <span class=\"string\">&#x27;rong&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> last = <span class=\"string\">&#x27;rong&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;My name is &#x27;</span> + first + last + <span class=\"string\">&#x27;.&#x27;</span>); <span class=\"comment\">// ES5의 문자열 연결, My name is rongrong.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`My name is <span class=\"subst\">$&#123;first&#125;</span><span class=\"subst\">$&#123;last&#125;</span>.`</span>); <span class=\"comment\">// ES6 템플릿 리터럴의 표현식 삽입, My name is rongrong.</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"불리언-타입\"><a href=\"#불리언-타입\" class=\"headerlink\" title=\"불리언 타입\"></a>불리언 타입</h2><p>불리언 타입의 값은 논리적 참, 거짓을 나타내는 true와 false가 있다.</p>\n<p>불리언 타입의 값은 참과 거짓으로 구분되는 조건에 의해 프로그램의 흐름을 제어하는 조건문에서 자주 사용된다.</p>\n<h2 id=\"undefined-타입\"><a href=\"#undefined-타입\" class=\"headerlink\" title=\"undefined 타입\"></a>undefined 타입</h2><p>undefined 타입의 값은 undefined가 유일하다.</p>\n<p>앞서서 var 키워드로 선언한 변수는 암묵적으로 undefined로 초기화 되는것을 살펴보았다.<br>이처럼 undefined는 개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화 할 때 사용하는 값이다.<br>변수를 참조했을 때 undefined가 반환된다면 참조한 변수가 선언 이후 초기화되지 않은 변수임을 알 수 있다.</p>\n<p>undefined를 개발자가 의도적으로 변수에 할당하는 것은 본래 취지와 어긋날뿐더러 혼란을 줄 수 있으므로 좋지 않다.</p>\n<p>그렇다면 변수에 값이 없다는 것을 명시하고 싶을 때는 어떻게 하면 좋을까? null을 할당해주면 된다.</p>\n<h2 id=\"null-타입\"><a href=\"#null-타입\" class=\"headerlink\" title=\"null 타입\"></a>null 타입</h2><p>null 타입의 값은 null이 유일하다. 자바스크립트는 대소문자를 구별하므로 null은 Null, NULL 등과 다르다.</p>\n<p>프로그래밍 언어에서 null은 변수에 값이 없다는 것을 의도적으로 명시할 때 사용한다. 변수에 null을 할당하는 것은 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미이다.</p>\n<p>함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 한다. 예를들어, HTML 요소를 검색해 반환하는 document.querySelector 메서드는 조건에 부합하는 HTML 요소를 검색할 수 없는 경우 에러가 아닌 null을 반환한다.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">var</span> element = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&#x27;.myClass&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(element); <span class=\"comment\">// null</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"심벌-타입\"><a href=\"#심벌-타입\" class=\"headerlink\" title=\"심벌 타입\"></a>심벌 타입</h2><p>심벌은 ES6에서 추가된 타입으로, 변경 불가능한 원시 타입의 값이다. 심벌 값은 다른 값과 중복되지 않는 유일무이한 값이다.<br>따라서 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.</p>\n<p>심벌값은 리터럴이 아닌 Symbol 함수를 호출해 생성한다.</p>\n<hr>\n\n<h1 id=\"객체-타입\"><a href=\"#객체-타입\" class=\"headerlink\" title=\"객체 타입\"></a>객체 타입</h1><p>자바스크립트는 크게 원시 타입과 객체 타입으로 분류한다. 이는 객체 타입이 다른 원시 타입들과는 다른 특성을 가짐을 의미한다.</p>\n<p>객체 타입에 대해서는 다음에 자세하게 알아보도록 하겠다.</p>\n<hr>\n\n<p>지금 까지 자바스크립트의 8가지 데이터 타입에 대해 알아보았다. 그렇다면 데이터 타입은 왜 필요한 것일까?</p>\n<h1 id=\"데이터-타입의-필요성\"><a href=\"#데이터-타입의-필요성\" class=\"headerlink\" title=\"데이터 타입의 필요성\"></a>데이터 타입의 필요성</h1><p>값은 메모리에 저장하고 참조할 수 있어야 한다. 값을 메모리에 저장하기 위해서는 값이 들어가기 위한 메모리 공간의 크기를 결정해야 한다.<br>즉 몇 바이트의 메모리 공간을 사용해야 낭비와 손실 없이 값을 저장할 수 있는지 알아야 한다.</p>\n<p>다음과 같은 코드를 실행해보자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> score = <span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure>\n\n<p>자바스크립트 엔진은 정수 리터럴 100을 평가해 숫자 타입의 값 100을 만들어 score라는 변수에 할당한다.<br>자바스크립트의 숫자 타입은 64비트 부동소수점 방식을 따른다고 했으니 숫자 타입의 값을 저장하기 위해서는 8바이트의 공간이 필요할 것이다.</p>\n<p>이처럼 자바스크립트 엔진은 데이터 타입, 즉 값의 종류에 따라 정해진 크기의 메모리 공간을 확보한다.</p>\n<p>이번에는 값을 참조하는 경우를 생각해보자. 식별자 score를 통해 숫자 타입의 값 100이 저장되어 있는 메모리 공간의 주소를 찾아갈 수 있다.<br>이 때 값을 참조하려면 한 번에 읽어 들여야 할 메모리 공간의 크기를 알아야 한다. score 변수의 경우, 저장되어 있는 값이 숫자 타입이므로 8바이트 단위로 읽어 들이지 않는다면 값이 훼손될 것이다.</p>\n<p>역시 자바스크립트 엔진은 데이터 타입을 통해 한번에 읽어 들여야 할 메모리 공간의 크기를 결정한다.</p>\n<p>아직 문제가 남아 있다. 메모리에서 읽어 들인 2진수를 어떻게 해석해야 하느냐다.<br>모든 값은 데이터 타입을 가지며 메모리에 2진수로 저장된다. 메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있다. 예를 들어, 메모리에 저장된 값 0100 0001을 숫자로 해석하면 65지만 문자열로 해석하면 ‘A’이다.</p>\n<p>자바스크립트 엔진은 데이터 타입에 따라 메모리 공간에서 읽어들인 2진수를 해석한다.</p>\n<p>정리하자면 다음과 같은 이유로 데이터 타입이 필요하다고 할 수 있다.</p>\n<blockquote>\n<ul>\n<li>값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해</li>\n<li>값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해</li>\n<li>메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해</li>\n</ul>\n</blockquote>\n<hr>\n\n<p>자바스크립트의 모든 값은 데이터 타입을 가진다. 그렇다면 변수 역시 데이터 타입을 가질까?</p>\n<p>C나 자바와 같은 정적 타입 언어는 변수를 선언할 때 변수에 할당할 수 있는 값의 종류(데이터 타입)을 사전에 선언해야 한다. 이를 명시적 타입 선언이라 한다.</p>\n<p>정적 타입 언어는 변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있다.</p>\n<p>자바스크립트는 정적 타입 언어와 다르게 변수를 선언할 때 타입을 선언하지 않고 var, let, const 키워드만 사용해 변수를 선언한다.<br>자바스크립트의 변수는 어떠한 데이터 타입의 값이라도 자유롭게 할당할 수 있다. 따라서 자바스크립트의 데이터 타입은 정적 타입 언어의 데이터 타입과는 개념이 다르다.</p>\n<p>자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론)된다. 그리고 재할당에 의해 변수의 데이터 타입이 언제든지 동적으로 변할 수 있다. 이러한 특징을 동적 타이핑이라 하며, 정적 타입 언어와 구분하기 위해 동적 타입 언어라 한다.</p>\n<p>동적 타입 언어는 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당 가능하므로 편리하다. 하지만 이로 인한 구조적인 단점 역시 존재한다.<br>변수 값은 언제든지 변경될 수 있기 때문에 복잡한 프로그램에서는 변화하는 변수 값을 추적하기 어려울 수 있다.</p>\n<p>그 뿐만 아니라 값의 변경에 의해서도 타입도 언제든 변경될 수 있다. 따라서 동적 타입 언어의 변수는 값을 확인하기 전 타입을 확신할 수 없다.<br>또 자바스크립트는 개발자의 의도와는 관계없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환하는 경우도 존재한다.</p>\n<p>이처럼 동적 타입 언어는 유연성은 높지만 신뢰성은 떨어진다.</p>\n<blockquote>\n<p>이러한 단점을 해결하기 위해 자바스크립트를 정적 타입 언어처럼 사용할 수 있는 타입스크립트가 등장했다. 웹의 규모가 커지면서 더 복잡한 프로그램을 만들어야 하는 경우가 많아지고 있고 따라서 타입스크립트를 다룬 경험을 요구하는 기업 또한 많아지고 있다. 자바스크립트의 동적인 부분이 단점으로 다가오는 경우가 많은것 같다. 이런 부분에 대해서도 고민이 필요할 것 같다.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>데이터 타입은 값의 종류를 말한다. 자바스크립트의 모든 값은 데이터 타입을 갖는다. 자바스크립트는 8개의 데이터 타입을 가지며 7개의 원시 타입(primitive type)과 1개의 객체 타입(object&#x2F;reference type)으로 분류 가능하다.</p>\n<p>데이터 타입의 종류에 따른 특징에 대해 살펴보고 데이터 타입이 왜 필요한지에 대해 알아보자.</p>\n<hr>\n\n<p>먼저 원시 타입에 대해 알아보자.</p>\n<h1 id=\"원시-타입\"><a href=\"#원시-타입\" class=\"headerlink\" title=\"원시 타입\"></a>원시 타입</h1><p>원시 타입에는 숫자(Number) 타입, Bigint 타입, 문자열(String) 타입, 불리언(Boolean) 타입, undefined 타입, null 타입, 심벌(Symbol) 타입이 존재한다. 순서대로 각 타입에 대해 살펴보겠다.</p>\n<h2 id=\"숫자-타입\"><a href=\"#숫자-타입\" class=\"headerlink\" title=\"숫자 타입\"></a>숫자 타입</h2><p>타 프로그래밍 언어에서는 정수(소수점 이하가 없는 숫자)와 실수(소수점 이하가 있는 숫자)를 구분해 int, long, float, double 등과 같은 다양한 숫자 타입을 제공한다. 하지만 자바스크립트는 독특하게 하나의 숫자 타입만 존재한다.</p>\n<p>자바스크립트의 숫자 타입의 값은 배정밀도 64비트 부동소수점 형식을 따르기 때문에 모든 수를 실수로 처리한다.</p>\n<p>숫자 타입은 추가적으로 세가지 특별한 값을 표현할 수 있다.</p>\n<blockquote>\n<ul>\n<li>Infinity : 양의 무한대</li>\n<li>-Infinity : 음의 무한대</li>\n<li>NaN : 산술 연산 불가(Not-a-Number)</li>\n</ul>\n</blockquote>\n<p>자바스크립트는 대소문자를 구별하므로 NaN을 NAN,Nan,nan과 같이 표현하면 에러가 발생한다. 자바스크립트는 NAN,Nan,nan을 식별자로 해석한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = nan; <span class=\"comment\">// ReferenceError: nan is not defined</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"부동소수점-형식이란\"><a href=\"#부동소수점-형식이란\" class=\"headerlink\" title=\"부동소수점 형식이란?\"></a>부동소수점 형식이란?</h3><p>부동소수점 형식은 실수를 컴퓨터 상에서 근사하여 표현할 때 소수점의 위치를 고정하지 않고 그 위치를 나타내는 수를 따로 적는 것으로, 유효숫자를 나타내는 가수와 소수점의 위치를 풀이하는 지수로 나누어 표현한다.</p>\n<p>몇 비트를 기반으로 하는지에 따라 정밀도가 달라지며 32비트를 단정밀도, 64비트를 배정밀도라 한다.</p>\n<p>32비트의 경우는 부호 1비트 + 지수 8비트 + 가수 23비트로 나누어지며 64비트는 부호 1비트 + 지수 11비트 + 가수 52비트로 나누어진다.</p>\n<p>지수부 계산시 bias를 더해줌으로 음수값을 가지는 지수와 양수값을 가지는 지수를 폭 넓게 표현 가능하다. (bias: 32비트-127, 64비트-1023)</p>\n<h2 id=\"Bigint-타입\"><a href=\"#Bigint-타입\" class=\"headerlink\" title=\"Bigint 타입\"></a>Bigint 타입</h2><p>자바스크립트의 숫자 타입은 64비트 부동소수점 형식의 2진수로 저장된다고 했다. 64비트 부동소수점 형식으로 안정적으로 나타낼 수 있는 최대치는 2^53^ - 1이다.</p>\n<p>대부분의 소규모 프로그래밍이나 웹 개발에서 안정적으로 나타낼 수 있는 수의 최대치가 존재하는것이 큰 문제는 아니었다.<br>하지만 자바스크립트가 백엔드 언어로서도 점점 유용해지고 데이터베이스에서도 사용하게 되면서 큰 정수 ID나 고정밀 타임 스탬프를 표현해야 하는 일이 생기게 되었다.</p>\n<p>ES11에서는 기존의 숫자 타입보다 큰 수를 표현할 수 있도록 새로운 원시 값인 Bigint 타입을 추가하게 되었다.</p>\n<p>Bigint 값은 정수 리터럴 뒤에 n을 붙이거나 Bigint 함수를 호출해 생성할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10n</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"title class_\">BigInt</span>(<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"문자열-타입\"><a href=\"#문자열-타입\" class=\"headerlink\" title=\"문자열 타입\"></a>문자열 타입</h2><p>문자열 타입은 텍스트 데이터를 나타내는 데 사용한다. 문자열은 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합이다.</p>\n<p>문자열은 작은따옴표(‘’), 큰 따옴표(“”), 백틱(&#96;&#96;)으로 텍스트를 감싼다.</p>\n<p>다른 타입의 값과 달리 문자열을 따옴표로 감싸는 이유는 키워드나 식별자와 같은 토큰과 구분하기 위함이다. 만약 문자열을 따옴표로 감싸지 않으면 자바스크립트 엔진은 이를 키워드나 식별자 같은 토큰으로 인식한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = hello; <span class=\"comment\">// ReferenceError: hello is not defined</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"템플릿-리터럴\"><a href=\"#템플릿-리터럴\" class=\"headerlink\" title=\"템플릿 리터럴\"></a>템플릿 리터럴</h3><p>ES6부터 템플릿 리터럴이라고 하는 새로운 문자열 표기법이 도입되었다.</p>\n<p>템플릿(template)의 뜻은 주형이며 리터럴(literal)의 뜻은 정확한이다. 이를 해석해보면 정확한 주형이란 뜻이 되는데 템플릿 리터럴은 해석 그대로 리터럴 내부의 문자열을 정확히 표현한다고 생각하면 편하다.</p>\n<p>템플릿 리터럴은 백틱(&#96;&#96;)으로 감싸 표현하며 멀티라인 문자열, 표현식 삽입, 태그드 템플릿과 같은 편리한 문자열 처리 기능을 제공한다.</p>\n<h3 id=\"일반-문자열과는-어떤-차이가-있을까\"><a href=\"#일반-문자열과는-어떤-차이가-있을까\" class=\"headerlink\" title=\"일반 문자열과는 어떤 차이가 있을까?\"></a>일반 문자열과는 어떤 차이가 있을까?</h3><p>템플릿 리터럴은 멀티라인 문자열, 표현식 삽입과 같은 편리한 기능을 제공한다고 했다. 그럼 위 기능들이 제공되지 않는다는 소리인데 일반 문자열은 어떻게 개행과 문자열의 연결을 수행했을까?</p>\n<blockquote>\n<p>일반 문자열은 공백과 같은 특수 문자를 표현하기 위해 백스페이스()로 시작하는 이스케이프 시퀀스를 이용한다.</p>\n<ul>\n<li><code>\\0(null), \\b(백스페이스), \\f(폼 피드, 프린터로 출력시 다음 페이지 시작지점으로 이동), \\n(개행 LF), \\r(개행 CR), \\t(수평 탭), \\v(수직 탭), \\&#39;(작은 따옴표), \\&quot;(큰 따옴표), \\\\(백슬래시)</code></li>\n</ul>\n</blockquote>\n<blockquote>\n<p>일반 문자열은 문자열 연결 연산자 +를 이용하지만 템플릿 리터럴은 표현식 삽입(${})을 이용해 문자열을 연결한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fisrst = <span class=\"string\">&#x27;rong&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> last = <span class=\"string\">&#x27;rong&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;My name is &#x27;</span> + first + last + <span class=\"string\">&#x27;.&#x27;</span>); <span class=\"comment\">// ES5의 문자열 연결, My name is rongrong.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`My name is <span class=\"subst\">$&#123;first&#125;</span><span class=\"subst\">$&#123;last&#125;</span>.`</span>); <span class=\"comment\">// ES6 템플릿 리터럴의 표현식 삽입, My name is rongrong.</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"불리언-타입\"><a href=\"#불리언-타입\" class=\"headerlink\" title=\"불리언 타입\"></a>불리언 타입</h2><p>불리언 타입의 값은 논리적 참, 거짓을 나타내는 true와 false가 있다.</p>\n<p>불리언 타입의 값은 참과 거짓으로 구분되는 조건에 의해 프로그램의 흐름을 제어하는 조건문에서 자주 사용된다.</p>\n<h2 id=\"undefined-타입\"><a href=\"#undefined-타입\" class=\"headerlink\" title=\"undefined 타입\"></a>undefined 타입</h2><p>undefined 타입의 값은 undefined가 유일하다.</p>\n<p>앞서서 var 키워드로 선언한 변수는 암묵적으로 undefined로 초기화 되는것을 살펴보았다.<br>이처럼 undefined는 개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화 할 때 사용하는 값이다.<br>변수를 참조했을 때 undefined가 반환된다면 참조한 변수가 선언 이후 초기화되지 않은 변수임을 알 수 있다.</p>\n<p>undefined를 개발자가 의도적으로 변수에 할당하는 것은 본래 취지와 어긋날뿐더러 혼란을 줄 수 있으므로 좋지 않다.</p>\n<p>그렇다면 변수에 값이 없다는 것을 명시하고 싶을 때는 어떻게 하면 좋을까? null을 할당해주면 된다.</p>\n<h2 id=\"null-타입\"><a href=\"#null-타입\" class=\"headerlink\" title=\"null 타입\"></a>null 타입</h2><p>null 타입의 값은 null이 유일하다. 자바스크립트는 대소문자를 구별하므로 null은 Null, NULL 등과 다르다.</p>\n<p>프로그래밍 언어에서 null은 변수에 값이 없다는 것을 의도적으로 명시할 때 사용한다. 변수에 null을 할당하는 것은 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미이다.</p>\n<p>함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 한다. 예를들어, HTML 요소를 검색해 반환하는 document.querySelector 메서드는 조건에 부합하는 HTML 요소를 검색할 수 없는 경우 에러가 아닌 null을 반환한다.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">var</span> element = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&#x27;.myClass&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(element); <span class=\"comment\">// null</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"심벌-타입\"><a href=\"#심벌-타입\" class=\"headerlink\" title=\"심벌 타입\"></a>심벌 타입</h2><p>심벌은 ES6에서 추가된 타입으로, 변경 불가능한 원시 타입의 값이다. 심벌 값은 다른 값과 중복되지 않는 유일무이한 값이다.<br>따라서 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.</p>\n<p>심벌값은 리터럴이 아닌 Symbol 함수를 호출해 생성한다.</p>\n<hr>\n\n<h1 id=\"객체-타입\"><a href=\"#객체-타입\" class=\"headerlink\" title=\"객체 타입\"></a>객체 타입</h1><p>자바스크립트는 크게 원시 타입과 객체 타입으로 분류한다. 이는 객체 타입이 다른 원시 타입들과는 다른 특성을 가짐을 의미한다.</p>\n<p>객체 타입에 대해서는 다음에 자세하게 알아보도록 하겠다.</p>\n<hr>\n\n<p>지금 까지 자바스크립트의 8가지 데이터 타입에 대해 알아보았다. 그렇다면 데이터 타입은 왜 필요한 것일까?</p>\n<h1 id=\"데이터-타입의-필요성\"><a href=\"#데이터-타입의-필요성\" class=\"headerlink\" title=\"데이터 타입의 필요성\"></a>데이터 타입의 필요성</h1><p>값은 메모리에 저장하고 참조할 수 있어야 한다. 값을 메모리에 저장하기 위해서는 값이 들어가기 위한 메모리 공간의 크기를 결정해야 한다.<br>즉 몇 바이트의 메모리 공간을 사용해야 낭비와 손실 없이 값을 저장할 수 있는지 알아야 한다.</p>\n<p>다음과 같은 코드를 실행해보자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> score = <span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure>\n\n<p>자바스크립트 엔진은 정수 리터럴 100을 평가해 숫자 타입의 값 100을 만들어 score라는 변수에 할당한다.<br>자바스크립트의 숫자 타입은 64비트 부동소수점 방식을 따른다고 했으니 숫자 타입의 값을 저장하기 위해서는 8바이트의 공간이 필요할 것이다.</p>\n<p>이처럼 자바스크립트 엔진은 데이터 타입, 즉 값의 종류에 따라 정해진 크기의 메모리 공간을 확보한다.</p>\n<p>이번에는 값을 참조하는 경우를 생각해보자. 식별자 score를 통해 숫자 타입의 값 100이 저장되어 있는 메모리 공간의 주소를 찾아갈 수 있다.<br>이 때 값을 참조하려면 한 번에 읽어 들여야 할 메모리 공간의 크기를 알아야 한다. score 변수의 경우, 저장되어 있는 값이 숫자 타입이므로 8바이트 단위로 읽어 들이지 않는다면 값이 훼손될 것이다.</p>\n<p>역시 자바스크립트 엔진은 데이터 타입을 통해 한번에 읽어 들여야 할 메모리 공간의 크기를 결정한다.</p>\n<p>아직 문제가 남아 있다. 메모리에서 읽어 들인 2진수를 어떻게 해석해야 하느냐다.<br>모든 값은 데이터 타입을 가지며 메모리에 2진수로 저장된다. 메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있다. 예를 들어, 메모리에 저장된 값 0100 0001을 숫자로 해석하면 65지만 문자열로 해석하면 ‘A’이다.</p>\n<p>자바스크립트 엔진은 데이터 타입에 따라 메모리 공간에서 읽어들인 2진수를 해석한다.</p>\n<p>정리하자면 다음과 같은 이유로 데이터 타입이 필요하다고 할 수 있다.</p>\n<blockquote>\n<ul>\n<li>값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해</li>\n<li>값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해</li>\n<li>메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해</li>\n</ul>\n</blockquote>\n<hr>\n\n<p>자바스크립트의 모든 값은 데이터 타입을 가진다. 그렇다면 변수 역시 데이터 타입을 가질까?</p>\n<p>C나 자바와 같은 정적 타입 언어는 변수를 선언할 때 변수에 할당할 수 있는 값의 종류(데이터 타입)을 사전에 선언해야 한다. 이를 명시적 타입 선언이라 한다.</p>\n<p>정적 타입 언어는 변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있다.</p>\n<p>자바스크립트는 정적 타입 언어와 다르게 변수를 선언할 때 타입을 선언하지 않고 var, let, const 키워드만 사용해 변수를 선언한다.<br>자바스크립트의 변수는 어떠한 데이터 타입의 값이라도 자유롭게 할당할 수 있다. 따라서 자바스크립트의 데이터 타입은 정적 타입 언어의 데이터 타입과는 개념이 다르다.</p>\n<p>자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론)된다. 그리고 재할당에 의해 변수의 데이터 타입이 언제든지 동적으로 변할 수 있다. 이러한 특징을 동적 타이핑이라 하며, 정적 타입 언어와 구분하기 위해 동적 타입 언어라 한다.</p>\n<p>동적 타입 언어는 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당 가능하므로 편리하다. 하지만 이로 인한 구조적인 단점 역시 존재한다.<br>변수 값은 언제든지 변경될 수 있기 때문에 복잡한 프로그램에서는 변화하는 변수 값을 추적하기 어려울 수 있다.</p>\n<p>그 뿐만 아니라 값의 변경에 의해서도 타입도 언제든 변경될 수 있다. 따라서 동적 타입 언어의 변수는 값을 확인하기 전 타입을 확신할 수 없다.<br>또 자바스크립트는 개발자의 의도와는 관계없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환하는 경우도 존재한다.</p>\n<p>이처럼 동적 타입 언어는 유연성은 높지만 신뢰성은 떨어진다.</p>\n<blockquote>\n<p>이러한 단점을 해결하기 위해 자바스크립트를 정적 타입 언어처럼 사용할 수 있는 타입스크립트가 등장했다. 웹의 규모가 커지면서 더 복잡한 프로그램을 만들어야 하는 경우가 많아지고 있고 따라서 타입스크립트를 다룬 경험을 요구하는 기업 또한 많아지고 있다. 자바스크립트의 동적인 부분이 단점으로 다가오는 경우가 많은것 같다. 이런 부분에 대해서도 고민이 필요할 것 같다.</p>\n</blockquote>\n"},{"title":"백준 Node.js 입출력법","date":"2022-08-06T08:08:05.000Z","_content":"\n지금까지 leetcode와 프로그래머스를 통해 코딩테스트 공부를 하고 있었는데 leetcode는 영어 해석의, 프로그래머스는 적은 문제수의 단점을 가지고 있어 백준을 통해 코딩테스트 연습을 시작해보았다.\n\n백준에서는 javascript로 코딩테스트를 준비하기 위해 node.js를 선택해야 했는데 프로그래머스에서는 함수만 작성하면 되었던 반면에 백준에서는 입출력을 직접 해주어야 했다.\n\n백준에서 node.js로 입력을 받는 방법은 크게 두가지로 readline 모듈을 사용하는 것과 fs 모듈을 사용하는 것이다. fs 모듈의 경우 readline 모듈보다 코드가 간단하고 더 빠르다고 해 fs 모듈의 대해 찾아보았다.\n\n<hr>\n\n# **fs**\n\nFileSystem의 약자인 fs 모듈은 파일 처리와 관련된 모듈이다. [BOJ 도움말](https://help.acmicpc.net/)에서는 다음과 같은 코드로 fs 모듈을 통한 입력을 소개하고 있다.\n\n```javascript\nlet fs = require('fs');\nlet input = fs.readFileSync('/dev/stdin').toString().split(' ');\nlet a = parseInt(input[0]);\nlet b = parseInt(input[1]);\nconsole.log(a+b);\n```\n\n하지만 위 코드를 이용할때에도 입력되는 값에 따라 에러가 발생하는 경우가 있어 다양한 방식의 입력법에 대해 정리해 보았다.\n\n```javascript\n1. 하나의 값을 입력받을 때\nconst fs = require('fs');\nconst input = fs.readFileSync(\"/dev/stdin\").toString().trim();\n\n2. 공백으로 구분된 한 줄의 값들을 입력받을 때\nconst fs = require('fs');\nconst input = fs.readFileSync(\"/dev/stdin\").toString().trim().split(\" \");\n\n3. 여러 줄의 값들을 입력받을 때\nconst fs = require('fs');\nconst input = fs.readFileSync(\"/dev/stdin\").toString().trim().split(\"\\n\");\n\n4. 첫 번째 줄에 자연수 n을 입력받고, 그 다음줄에 공백으로 구분된 n개의 값들을 입력받을 때\nconst fs = require('fs');\nconst [n, ...arr] = fs.readFileSync(\"/dev/stdin\").toString().trim().split(/\\s/);\n\n5. 첫 번째 줄에 자연수 n을 입력받고, 그 다음줄부터 n개의 줄에 걸쳐 한 줄에 하나의 값을 입력받을 때\nconst fs = require('fs');\nconst [n, ...arr] = fs.readFileSync(\"/dev/stdin\").toString().trim().split(\"\\n\");\n\n6. 하나의 값 또는 공백으로 구분된 여러 값들을 여러 줄에 걸쳐 뒤죽박죽 섞여서 입력받을 때\n  ex) n 입력 - 공백으로 구분된 n개의 값 입력 - m 입력 - 여러 줄에 걸쳐 m개의 값 입력\nconst fs = require('fs');\nconst input = fs.readFileSync(\"/dev/stdin\").toString().trim().split(/\\s/);\nconst n = input[0];\nconst n_arr = input.slice(1, n+1);\nconst [m, ...m_arr] = input.slice(n+1);\n```\n최종 결과 확인을 위해선 **console.log()** 를 통해 값을 출력해주면 된다.\n<hr>\n\n## 참고\n\n[[알고리즘] 백준 0.nodejs 입력하기](https://overcome-the-limits.tistory.com/25)\n[Node.js로 백준(BOJ) 문제 풀 때 유의할 점들](https://tesseractjh.tistory.com/39)\n\n","source":"_posts/Node-js-input-and-output-in-Baekjoon-Online-Judge.md","raw":"---\ntitle: 백준 Node.js 입출력법\ndate: 2022-08-06 17:08:05\ntags:\n- 개발\n- JavaScript\n- 코딩테스트\n\n---\n\n지금까지 leetcode와 프로그래머스를 통해 코딩테스트 공부를 하고 있었는데 leetcode는 영어 해석의, 프로그래머스는 적은 문제수의 단점을 가지고 있어 백준을 통해 코딩테스트 연습을 시작해보았다.\n\n백준에서는 javascript로 코딩테스트를 준비하기 위해 node.js를 선택해야 했는데 프로그래머스에서는 함수만 작성하면 되었던 반면에 백준에서는 입출력을 직접 해주어야 했다.\n\n백준에서 node.js로 입력을 받는 방법은 크게 두가지로 readline 모듈을 사용하는 것과 fs 모듈을 사용하는 것이다. fs 모듈의 경우 readline 모듈보다 코드가 간단하고 더 빠르다고 해 fs 모듈의 대해 찾아보았다.\n\n<hr>\n\n# **fs**\n\nFileSystem의 약자인 fs 모듈은 파일 처리와 관련된 모듈이다. [BOJ 도움말](https://help.acmicpc.net/)에서는 다음과 같은 코드로 fs 모듈을 통한 입력을 소개하고 있다.\n\n```javascript\nlet fs = require('fs');\nlet input = fs.readFileSync('/dev/stdin').toString().split(' ');\nlet a = parseInt(input[0]);\nlet b = parseInt(input[1]);\nconsole.log(a+b);\n```\n\n하지만 위 코드를 이용할때에도 입력되는 값에 따라 에러가 발생하는 경우가 있어 다양한 방식의 입력법에 대해 정리해 보았다.\n\n```javascript\n1. 하나의 값을 입력받을 때\nconst fs = require('fs');\nconst input = fs.readFileSync(\"/dev/stdin\").toString().trim();\n\n2. 공백으로 구분된 한 줄의 값들을 입력받을 때\nconst fs = require('fs');\nconst input = fs.readFileSync(\"/dev/stdin\").toString().trim().split(\" \");\n\n3. 여러 줄의 값들을 입력받을 때\nconst fs = require('fs');\nconst input = fs.readFileSync(\"/dev/stdin\").toString().trim().split(\"\\n\");\n\n4. 첫 번째 줄에 자연수 n을 입력받고, 그 다음줄에 공백으로 구분된 n개의 값들을 입력받을 때\nconst fs = require('fs');\nconst [n, ...arr] = fs.readFileSync(\"/dev/stdin\").toString().trim().split(/\\s/);\n\n5. 첫 번째 줄에 자연수 n을 입력받고, 그 다음줄부터 n개의 줄에 걸쳐 한 줄에 하나의 값을 입력받을 때\nconst fs = require('fs');\nconst [n, ...arr] = fs.readFileSync(\"/dev/stdin\").toString().trim().split(\"\\n\");\n\n6. 하나의 값 또는 공백으로 구분된 여러 값들을 여러 줄에 걸쳐 뒤죽박죽 섞여서 입력받을 때\n  ex) n 입력 - 공백으로 구분된 n개의 값 입력 - m 입력 - 여러 줄에 걸쳐 m개의 값 입력\nconst fs = require('fs');\nconst input = fs.readFileSync(\"/dev/stdin\").toString().trim().split(/\\s/);\nconst n = input[0];\nconst n_arr = input.slice(1, n+1);\nconst [m, ...m_arr] = input.slice(n+1);\n```\n최종 결과 확인을 위해선 **console.log()** 를 통해 값을 출력해주면 된다.\n<hr>\n\n## 참고\n\n[[알고리즘] 백준 0.nodejs 입력하기](https://overcome-the-limits.tistory.com/25)\n[Node.js로 백준(BOJ) 문제 풀 때 유의할 점들](https://tesseractjh.tistory.com/39)\n\n","slug":"Node-js-input-and-output-in-Baekjoon-Online-Judge","published":1,"updated":"2022-10-05T08:14:18.767Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb08iq6g000he4vkhdxz4etd","content":"<p>지금까지 leetcode와 프로그래머스를 통해 코딩테스트 공부를 하고 있었는데 leetcode는 영어 해석의, 프로그래머스는 적은 문제수의 단점을 가지고 있어 백준을 통해 코딩테스트 연습을 시작해보았다.</p>\n<p>백준에서는 javascript로 코딩테스트를 준비하기 위해 node.js를 선택해야 했는데 프로그래머스에서는 함수만 작성하면 되었던 반면에 백준에서는 입출력을 직접 해주어야 했다.</p>\n<p>백준에서 node.js로 입력을 받는 방법은 크게 두가지로 readline 모듈을 사용하는 것과 fs 모듈을 사용하는 것이다. fs 모듈의 경우 readline 모듈보다 코드가 간단하고 더 빠르다고 해 fs 모듈의 대해 찾아보았다.</p>\n<hr>\n\n<h1 id=\"fs\"><a href=\"#fs\" class=\"headerlink\" title=\"fs\"></a><strong>fs</strong></h1><p>FileSystem의 약자인 fs 모듈은 파일 처리와 관련된 모듈이다. <a href=\"https://help.acmicpc.net/\">BOJ 도움말</a>에서는 다음과 같은 코드로 fs 모듈을 통한 입력을 소개하고 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> input = fs.<span class=\"title function_\">readFileSync</span>(<span class=\"string\">&#x27;/dev/stdin&#x27;</span>).<span class=\"title function_\">toString</span>().<span class=\"title function_\">split</span>(<span class=\"string\">&#x27; &#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"built_in\">parseInt</span>(input[<span class=\"number\">0</span>]);</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"built_in\">parseInt</span>(input[<span class=\"number\">1</span>]);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a+b);</span><br></pre></td></tr></table></figure>\n\n<p>하지만 위 코드를 이용할때에도 입력되는 값에 따라 에러가 발생하는 경우가 있어 다양한 방식의 입력법에 대해 정리해 보았다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 하나의 값을 입력받을 때</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = fs.<span class=\"title function_\">readFileSync</span>(<span class=\"string\">&quot;/dev/stdin&quot;</span>).<span class=\"title function_\">toString</span>().<span class=\"title function_\">trim</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span> 공백으로 구분된 한 줄의 값들을 입력받을 때</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = fs.<span class=\"title function_\">readFileSync</span>(<span class=\"string\">&quot;/dev/stdin&quot;</span>).<span class=\"title function_\">toString</span>().<span class=\"title function_\">trim</span>().<span class=\"title function_\">split</span>(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span> 여러 줄의 값들을 입력받을 때</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = fs.<span class=\"title function_\">readFileSync</span>(<span class=\"string\">&quot;/dev/stdin&quot;</span>).<span class=\"title function_\">toString</span>().<span class=\"title function_\">trim</span>().<span class=\"title function_\">split</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4.</span> 첫 번째 줄에 자연수 n을 입력받고, 그 다음줄에 공백으로 구분된 n개의 값들을 입력받을 때</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> [n, ...arr] = fs.<span class=\"title function_\">readFileSync</span>(<span class=\"string\">&quot;/dev/stdin&quot;</span>).<span class=\"title function_\">toString</span>().<span class=\"title function_\">trim</span>().<span class=\"title function_\">split</span>(<span class=\"regexp\">/\\s/</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">5.</span> 첫 번째 줄에 자연수 n을 입력받고, 그 다음줄부터 n개의 줄에 걸쳐 한 줄에 하나의 값을 입력받을 때</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> [n, ...arr] = fs.<span class=\"title function_\">readFileSync</span>(<span class=\"string\">&quot;/dev/stdin&quot;</span>).<span class=\"title function_\">toString</span>().<span class=\"title function_\">trim</span>().<span class=\"title function_\">split</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">6.</span> 하나의 값 또는 공백으로 구분된 여러 값들을 여러 줄에 걸쳐 뒤죽박죽 섞여서 입력받을 때</span><br><span class=\"line\">  ex) n 입력 - 공백으로 구분된 n개의 값 입력 - m 입력 - 여러 줄에 걸쳐 m개의 값 입력</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = fs.<span class=\"title function_\">readFileSync</span>(<span class=\"string\">&quot;/dev/stdin&quot;</span>).<span class=\"title function_\">toString</span>().<span class=\"title function_\">trim</span>().<span class=\"title function_\">split</span>(<span class=\"regexp\">/\\s/</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> n = input[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> n_arr = input.<span class=\"title function_\">slice</span>(<span class=\"number\">1</span>, n+<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> [m, ...m_arr] = input.<span class=\"title function_\">slice</span>(n+<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>최종 결과 확인을 위해선 <strong>console.log()</strong> 를 통해 값을 출력해주면 된다.</p>\n<hr>\n\n<h2 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h2><p><a href=\"https://overcome-the-limits.tistory.com/25\">[알고리즘] 백준 0.nodejs 입력하기</a><br><a href=\"https://tesseractjh.tistory.com/39\">Node.js로 백준(BOJ) 문제 풀 때 유의할 점들</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>지금까지 leetcode와 프로그래머스를 통해 코딩테스트 공부를 하고 있었는데 leetcode는 영어 해석의, 프로그래머스는 적은 문제수의 단점을 가지고 있어 백준을 통해 코딩테스트 연습을 시작해보았다.</p>\n<p>백준에서는 javascript로 코딩테스트를 준비하기 위해 node.js를 선택해야 했는데 프로그래머스에서는 함수만 작성하면 되었던 반면에 백준에서는 입출력을 직접 해주어야 했다.</p>\n<p>백준에서 node.js로 입력을 받는 방법은 크게 두가지로 readline 모듈을 사용하는 것과 fs 모듈을 사용하는 것이다. fs 모듈의 경우 readline 모듈보다 코드가 간단하고 더 빠르다고 해 fs 모듈의 대해 찾아보았다.</p>\n<hr>\n\n<h1 id=\"fs\"><a href=\"#fs\" class=\"headerlink\" title=\"fs\"></a><strong>fs</strong></h1><p>FileSystem의 약자인 fs 모듈은 파일 처리와 관련된 모듈이다. <a href=\"https://help.acmicpc.net/\">BOJ 도움말</a>에서는 다음과 같은 코드로 fs 모듈을 통한 입력을 소개하고 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> input = fs.<span class=\"title function_\">readFileSync</span>(<span class=\"string\">&#x27;/dev/stdin&#x27;</span>).<span class=\"title function_\">toString</span>().<span class=\"title function_\">split</span>(<span class=\"string\">&#x27; &#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"built_in\">parseInt</span>(input[<span class=\"number\">0</span>]);</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"built_in\">parseInt</span>(input[<span class=\"number\">1</span>]);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a+b);</span><br></pre></td></tr></table></figure>\n\n<p>하지만 위 코드를 이용할때에도 입력되는 값에 따라 에러가 발생하는 경우가 있어 다양한 방식의 입력법에 대해 정리해 보았다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 하나의 값을 입력받을 때</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = fs.<span class=\"title function_\">readFileSync</span>(<span class=\"string\">&quot;/dev/stdin&quot;</span>).<span class=\"title function_\">toString</span>().<span class=\"title function_\">trim</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span> 공백으로 구분된 한 줄의 값들을 입력받을 때</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = fs.<span class=\"title function_\">readFileSync</span>(<span class=\"string\">&quot;/dev/stdin&quot;</span>).<span class=\"title function_\">toString</span>().<span class=\"title function_\">trim</span>().<span class=\"title function_\">split</span>(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span> 여러 줄의 값들을 입력받을 때</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = fs.<span class=\"title function_\">readFileSync</span>(<span class=\"string\">&quot;/dev/stdin&quot;</span>).<span class=\"title function_\">toString</span>().<span class=\"title function_\">trim</span>().<span class=\"title function_\">split</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4.</span> 첫 번째 줄에 자연수 n을 입력받고, 그 다음줄에 공백으로 구분된 n개의 값들을 입력받을 때</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> [n, ...arr] = fs.<span class=\"title function_\">readFileSync</span>(<span class=\"string\">&quot;/dev/stdin&quot;</span>).<span class=\"title function_\">toString</span>().<span class=\"title function_\">trim</span>().<span class=\"title function_\">split</span>(<span class=\"regexp\">/\\s/</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">5.</span> 첫 번째 줄에 자연수 n을 입력받고, 그 다음줄부터 n개의 줄에 걸쳐 한 줄에 하나의 값을 입력받을 때</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> [n, ...arr] = fs.<span class=\"title function_\">readFileSync</span>(<span class=\"string\">&quot;/dev/stdin&quot;</span>).<span class=\"title function_\">toString</span>().<span class=\"title function_\">trim</span>().<span class=\"title function_\">split</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">6.</span> 하나의 값 또는 공백으로 구분된 여러 값들을 여러 줄에 걸쳐 뒤죽박죽 섞여서 입력받을 때</span><br><span class=\"line\">  ex) n 입력 - 공백으로 구분된 n개의 값 입력 - m 입력 - 여러 줄에 걸쳐 m개의 값 입력</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = fs.<span class=\"title function_\">readFileSync</span>(<span class=\"string\">&quot;/dev/stdin&quot;</span>).<span class=\"title function_\">toString</span>().<span class=\"title function_\">trim</span>().<span class=\"title function_\">split</span>(<span class=\"regexp\">/\\s/</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> n = input[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> n_arr = input.<span class=\"title function_\">slice</span>(<span class=\"number\">1</span>, n+<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> [m, ...m_arr] = input.<span class=\"title function_\">slice</span>(n+<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>최종 결과 확인을 위해선 <strong>console.log()</strong> 를 통해 값을 출력해주면 된다.</p>\n<hr>\n\n<h2 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h2><p><a href=\"https://overcome-the-limits.tistory.com/25\">[알고리즘] 백준 0.nodejs 입력하기</a><br><a href=\"https://tesseractjh.tistory.com/39\">Node.js로 백준(BOJ) 문제 풀 때 유의할 점들</a></p>\n"},{"title":"[Deep Dive] 연산자","date":"2022-10-20T08:47:21.000Z","_content":"# 연산자\n\n연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다.\n\n이 때 연산의 대상을 피연산자라 한다. 피연산자는 값으로 평가될 수 있는 표현식이어야 한다.\n그리고 피연산자와 연산자의 조합으로 이뤄진 연산자 표현식도 값으로 평가될 수 있는 표현식이다.\n\n자바스크립트가 제공하는 다양한 연산자에 대해 살펴보자.\n\n## 산술 연산자\n\n산술 연산자는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다.\n산술 연산이 불가능한 경우, NaN을 반환한다.\n\n산술 연산자는 피연산자의 개수에 따라 이항 산술 연산자와 단항 산술 연산자로 구분할 수 있다.\n\n### 이항 산술 연산자\n\n이항 산술 연산자는 2개의 피연산자를 산술 연산하여 숫자 값을 만든다.\n\n모든 이항 산술 연산자는 피연산자의 값을 변경하는 부수효과가 없다.\n\n```javascript\n5 + 2; // 7\n5 - 2; // 3\n5 * 2; // 10\n5 / 2; // 2.5\n5 % 2; // 1\n```\n\n### 단항 산술 연산자\n\n단항 산술 연산자는 1개의 피연산자를 산술 연산하여 숫자 값을 만든다.\n\n이 때 증가/감소(++/--) 연산자는 피연산자의 값을 변경한느 부수 효과가 있어 주의해야 한다.\n즉 증가/감소 연산을 하면 피연산자의 값을 변경하는 암묵적 할당이 이뤄진다.\n\n```javascript\nvar x = 1;\n\nx++; // x = x + 1;\nconsole.log(x); // 2\n\nx--; // x = x - 1;\nconsole.log(x); // 1\n```\n\n또한 증가/감소 연산자는 위치에 따라 선 할당후 연산이 이루어지는지, 연산이 수행되고 할당이 이루어지는지 다르므로 주의해야 한다.\n\n```javascript\nvar x = 5,\n  result;\n\nresult = x++; // 선할당 후증가\nconsole.log(result, x); // 5 6\n\nresult = ++x; // 선증가 후할당\nconsole.log(result, x); // 7 7\n\nresult = x--; // 선할당 후감소\nconsole.log(result, x); // 7 6\n\nresult = --x; // 선감소 후할당\nconsole.log(result, x); // 5 5\n```\n\n\\+ 단항 연산자는 피연산자에 어떠한 효과도 없다.\n다만 숫자 타입이 아닌 피연산자에 \\+ 단항 연산자를 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다.\n이때 피연산자를 변경하는 것은 아니고 숫자 타입으로 변환한 값을 생성해서 반환한다. 즉 부수 효과가 없다.\n\n```javascript\nvar x = '1';\n\nconsole.log(+x); // 1\nconsole.log(x); // \"1\"\n```\n\n\\- 단항 연산자는 피연산자에 부호를 반전한 값을 반환한다.\n\\+ 단항 연산자와 마찬가지로 숫자타입이 아닌 피연산자에 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다.\n이때 피연산자를 변경하는 것은 아니고 숫자 타입으로 변환한 값을 생성해서 반환한다. 즉 부수 효과가 없다.\n\n```javascript\n-(-10); // 10 (부호 반전)\n-true; // -1 (타입 변환)\n```\n\n### 문자열 연결 연산자\n\n\\+ 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.\n그 외의 경우는 산술 연산자로 동작한다.\n\n```javascript\n// 문자열 연결 연산자\n'1' + 2; // \"12\"\n2 + '1'; // \"12\"\n\n// 산술 연산자\n1 + 2; // 3\n\n// 타입 변환이 일어나는 경우\n1 + true; // 2\n1 + undefined; // NaN\n```\n\n이 때 주목할 점은 개발자의 의도와는 상관 없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다는 것이다.\n1 + true를 연산하면 자바스크립트 엔진은 암묵적으로 불리언 타입 값인 true를 숫자 탕비인 1로 강제로 변환한 후 연산을 수행한다.\n\n이를 암묵적 타입 변환이라고 한다. 앞서 살펴본 +/- 단항 연산자도 암묵적 타입 변환이 발생한 것이다\n\n## 할당 연산자\n\n할당 연산자는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다.\n할당 연산자는 좌항의 변수에 값을 할당하므로 변수 값이 변하는 부수 효과가 존재한다.\n\n```javascript\nvar x;\n\nx = 10;\nconsole.log(x); // 10\n\nx += 5; // x = x + 5;\nconsole.log(x); // 15\n\nx -= 5; // x = x - 5;\nconsole.log(x); // 10\n\nx *= 5; // x = x * 5;\nconsole.log(x); // 50\n\nx /= 5; // x = x / 5;\nconsole.log(x); // 10\n\nx %= 5; // x = x % 5;\nconsole.log(x); // 0\n```\n\n표현식은 값으로 평가 될 수 있는 문이고, 문에는 표현식인 문과 표현식이 아닌 문이 존재한다.\n그렇다면 할당문은 표현식인 문일까, 표현식이 아닌 문일까?\n\n할당문은 변수에 값을 할당하는 부수 효과만 있을 뿐 값으로 평가되지 않을 것처럼 보인다.\n하지만 할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다. 즉 변수에 할당할 수 있다.\n이러한 특징을 활용해 여러 변수에 동일한 값을 연쇄 할당할 수 있다.\n\n```javascript\nvar a, b, c;\n\na = b = c = 0;\n\nconsole.log(a, b, c); // 0 0 0\n```\n\n## 비교 연산자\n\n비교 연산자는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환한다.\n비교 연산자는 if 문이나 for 문과 같은 제어문의 조건식에서 주로 사용한다.\n\n### 동등/일치 비교 연산자\n\n동등 비교 연산자와 일치 비교 연산자는 좌항과 우항의 피연산자가 같은 값으로 평가되는지 비교해 불리언 값을 반환한다.\n하지만 비교하는 엄격성의 정도가 다르다.\n\n동등 비교(==) 연산자는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다.\n다시 말해 동등 비교 연산자는 좌항과 우항의 피연산자가 타입은 다르더라도 암묵적 타입 변환 후에 같은 값일 수 있다면 true를 반환한다.\n\n동등 비교 연산자는 편리한 경우도 있지만 결과를 예측하기 어렵고 실수하기 쉬우므로 사용하지 않는 편이 좋다.\n\n반면 일치 비교(===) 연산자는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다. 따라서 일치 비교 연산자는 예측하기 쉽다.\n\n```javascript\n5 == 5; // true\n5 == '5'; // true (암묵적 타입 변환)\n\n5 === 5; // true\n5 === '5'; // false (타입 변환 X)\n```\n\n일치 비교 연산자에서 주의할 것은 NaN이다.\n\n```javascript\nNaN === NaN; // false\n```\n\nNaN은 자신과 일치하지 않는 유일한 값이다. 숫자가 NaN인지 조사하기 위해서는 빌트인 함수 Number.isNaN을 사용한다.\n\n```javascript\nNumber.isNaN(NaN); // true\nNumber.isNaN(10); // false\n```\n\n> ES6에서 도입된 Object.is 메서드를 이용하면 예측 가능한 정확한 비교 결과를 얻을 수 있다.\n>\n> ```javascript\n> -0 === +0; // true\n> Object.is(-0, +0); // false\n>\n> NaN === NaN; // false\n> Object.is(NaN, NaN); // true\n> ```\n\n부동등 비교 연산자(!=)와 불일치 비교 연산자(!==)는 각각 동등 비교(==) 연산자와 일치 비교(===) 연산자의 반대 개념이다.\n\n### 대소 관계 비교 연산자\n\n대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다.\n\n```javascript\n5 > 0; // true\n5 > 5; // false\n5 >= 5; // true\n5 <= 5; // true\n```\n\n## 삼항 조건 연산자\n\n삼항 조건 연산자는 조건식의 평가 결과에 따라 반환할 값을 결정한다.\n자바스크립트의 유일한 삼항 연산자이며, 부수 효과는 없다.\n\n삼항 조건 연산자의 표현식은 다음과 같다.\n\n> 조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값\n\n삼항 조건 연산자는 첫 번째 피연산자가 true로 평가되면 두 번째 피연산자를 반환하고, 첫 번째 피연산자가 false로 평가되면 세 번째 피연산자를 반환한다.\n즉 삼항 조건 연산자는 두 번째 피연산자 또는 세 번째 피연산자로 평가되는 표현식이다.\n\n삼항 조건 연산자는 if...else 문을 사용해도 유사하게 처리 가능하다. 하지만 삼항 조건 연산자 표현식은 값처럼 사용할 수 있는 반면 if...else 문은 값처럼 사용할 수 없다는 차이가 있다.\n\n```javascript\nvar x = 10;\n\nvar result1 = x % 2 ? '홀수' : '짝수';\nconsole.log(result1); // 짝수\n\nvar result2 = if (x % 2) { result2 = '홀수'; } else { result2 = '짝수'; }; // SyntaxError: Unexpected token if\n```\n\n조건에 따라 어떤 값을 결정해야 한다면 if...else 문보다 삼항 조건 연산자 표현식을 사용하는 편이 유리하다.\n하지만 조건에 따라 수행해야 할 문이 하나가 아니리 여러 개라면 if...else 문의 가독성이 더 좋다.\n\n## 논리 연산자\n\n논리 연산자는 우항과 좌항의 피연산자(부정 논리 연산자의 경우 우항의 피연산자)를 논리 연산 한다.\n\n```javascript\n// 논리합(||) 연산자\ntrue || true; // true\ntrue || false; // true\nfalse || true; // true\nfalse || false; // false\n\n// 논리곱(&&) 연산자\ntrue && true; // true\ntrue && false; // false\nfalse && true; // false\nfalse && false; // false\n\n// 논리 부정(!) 연산자\n!true; // false\n!false; // true\n```\n\n논리 부정(!) 연산자는 언제나 불리언 값을 반환한다. 단 피연산자가 반드시 불리언 값일 필요는 없다.\n피연산자가 불리언 값이 아니라면 불리언 타입으로 암묵적 타입 변환된다.\n\n## 쉼표 연산자\n\n쉼표(,) 연산자는 왼쪽 피연산자부터 차레대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.\n\n```javascript\nvar x, y, z;\n\nx = 1, y = 2, z = 3; // 3\n```\n\n## 그룹 연산자\n\n소괄호(\\(\\))로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가한다. 따라서 그룹 연산자를 사용하면 연산자의 우선순위를 조절할 수 있다. 그룹 연산자는 연산자 우선순위가 가장 높다.\n\n## typeof 연산자\n\ntypeof 연산자는 피연산자의 데이터 타입을 문자열로 반환한다.\ntypeof 연산자는 \"number\", \"bigint\", \"string\", \"boolean\", \"undefined\", \"symbol\", \"object\", \"function\" 중 하나를 반환한다.\ntypeof 연산자가 반환하는 문자열이 데이터 타입과 정확히 일치하지는 않는다.\n\ntypeof 연산자로 null 값을 연산해 보면 \"null\"이 아닌 \"object\"를 반환하는데 이는 하위 호환성을 위해 수정되지 않고 있는 버그이다.\n따라서 값이 null 타입인지 확인할 때는 typeof 연산자가 아닌 일치(===) 연산자를 사용해야 한다.\n\n```javascript\nvar foo = null;\n\ntypeof foo === null; // false\nfoo === null; // true\n```\n\n또한 선언하지 않은 식별자를 typeof 연산자로 연산해 보면 ReferenceError가 발생하지 않고 undefined를 반환하는것도 주의하자.\n\n```javascript\n// undeclared 식별자를 선언하지 않았다.\ntypeof undeclared; // undefined\n```\n\n## 지수 연산자\n\nES7에서 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱한 숫자 값을 반환한다.\n\n```javascript\n2 ** 2; // 4\n2 * 0; // 1\n2 ** -2; // 0.25\n```\n\n지수 연산자가 도입되기 이전에는 Math.pow 메서드를 사용했다.\n\n```javascript\nMath.pow(2, 2); // 4\nMath.pow(2, 0); // 1\nMath.pow(2, -2); // 0.25\n```\n\n음수를 거듭제곱의 밑으로 사용해 계산하려면 괄호로 묶어주어야 한다.\n\n```javascript\n-5 ** 2;\n// SyntaxError: Unary operator used immediately before exponentiation expression. Parenthesis must be used to disambiguate operator precedence\n\n(-5) ** 2; // 25\n```\n\n## 연산자 우선순위\n\n연산자 우선순위란 여러 개의 연산자로 이뤄진 문이 실행될 때 연산자가 실행되는 순서를 말한다. 우선순위가 높을수록 먼저 실행된다.\n\n연산자는 종류가 많아 연산자 우선순위를 모두 기억하기 어렵고 실수하기도 쉽다.\n따라서 기억해 사용하기 보다는 연산자 우선순위가 높은 그룹 연산자를 사용하여 우선순위를 명시적으로 조절하는 것이 좋다.\n\n```javascript\n10 * (2 + 3); // 50\n```\n\n","source":"_posts/Modern-Javascript-Deep-Dive-Chapter-7-Operator-Summary.md","raw":"---\ntitle: \"[Deep Dive] 연산자\"\ndate: 2022-10-20 17:47:21\ntags:\n- 개발\n- 자바스크립트\n- 모던 자바스크립트 Deep Dive\n---\n# 연산자\n\n연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다.\n\n이 때 연산의 대상을 피연산자라 한다. 피연산자는 값으로 평가될 수 있는 표현식이어야 한다.\n그리고 피연산자와 연산자의 조합으로 이뤄진 연산자 표현식도 값으로 평가될 수 있는 표현식이다.\n\n자바스크립트가 제공하는 다양한 연산자에 대해 살펴보자.\n\n## 산술 연산자\n\n산술 연산자는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다.\n산술 연산이 불가능한 경우, NaN을 반환한다.\n\n산술 연산자는 피연산자의 개수에 따라 이항 산술 연산자와 단항 산술 연산자로 구분할 수 있다.\n\n### 이항 산술 연산자\n\n이항 산술 연산자는 2개의 피연산자를 산술 연산하여 숫자 값을 만든다.\n\n모든 이항 산술 연산자는 피연산자의 값을 변경하는 부수효과가 없다.\n\n```javascript\n5 + 2; // 7\n5 - 2; // 3\n5 * 2; // 10\n5 / 2; // 2.5\n5 % 2; // 1\n```\n\n### 단항 산술 연산자\n\n단항 산술 연산자는 1개의 피연산자를 산술 연산하여 숫자 값을 만든다.\n\n이 때 증가/감소(++/--) 연산자는 피연산자의 값을 변경한느 부수 효과가 있어 주의해야 한다.\n즉 증가/감소 연산을 하면 피연산자의 값을 변경하는 암묵적 할당이 이뤄진다.\n\n```javascript\nvar x = 1;\n\nx++; // x = x + 1;\nconsole.log(x); // 2\n\nx--; // x = x - 1;\nconsole.log(x); // 1\n```\n\n또한 증가/감소 연산자는 위치에 따라 선 할당후 연산이 이루어지는지, 연산이 수행되고 할당이 이루어지는지 다르므로 주의해야 한다.\n\n```javascript\nvar x = 5,\n  result;\n\nresult = x++; // 선할당 후증가\nconsole.log(result, x); // 5 6\n\nresult = ++x; // 선증가 후할당\nconsole.log(result, x); // 7 7\n\nresult = x--; // 선할당 후감소\nconsole.log(result, x); // 7 6\n\nresult = --x; // 선감소 후할당\nconsole.log(result, x); // 5 5\n```\n\n\\+ 단항 연산자는 피연산자에 어떠한 효과도 없다.\n다만 숫자 타입이 아닌 피연산자에 \\+ 단항 연산자를 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다.\n이때 피연산자를 변경하는 것은 아니고 숫자 타입으로 변환한 값을 생성해서 반환한다. 즉 부수 효과가 없다.\n\n```javascript\nvar x = '1';\n\nconsole.log(+x); // 1\nconsole.log(x); // \"1\"\n```\n\n\\- 단항 연산자는 피연산자에 부호를 반전한 값을 반환한다.\n\\+ 단항 연산자와 마찬가지로 숫자타입이 아닌 피연산자에 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다.\n이때 피연산자를 변경하는 것은 아니고 숫자 타입으로 변환한 값을 생성해서 반환한다. 즉 부수 효과가 없다.\n\n```javascript\n-(-10); // 10 (부호 반전)\n-true; // -1 (타입 변환)\n```\n\n### 문자열 연결 연산자\n\n\\+ 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.\n그 외의 경우는 산술 연산자로 동작한다.\n\n```javascript\n// 문자열 연결 연산자\n'1' + 2; // \"12\"\n2 + '1'; // \"12\"\n\n// 산술 연산자\n1 + 2; // 3\n\n// 타입 변환이 일어나는 경우\n1 + true; // 2\n1 + undefined; // NaN\n```\n\n이 때 주목할 점은 개발자의 의도와는 상관 없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다는 것이다.\n1 + true를 연산하면 자바스크립트 엔진은 암묵적으로 불리언 타입 값인 true를 숫자 탕비인 1로 강제로 변환한 후 연산을 수행한다.\n\n이를 암묵적 타입 변환이라고 한다. 앞서 살펴본 +/- 단항 연산자도 암묵적 타입 변환이 발생한 것이다\n\n## 할당 연산자\n\n할당 연산자는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다.\n할당 연산자는 좌항의 변수에 값을 할당하므로 변수 값이 변하는 부수 효과가 존재한다.\n\n```javascript\nvar x;\n\nx = 10;\nconsole.log(x); // 10\n\nx += 5; // x = x + 5;\nconsole.log(x); // 15\n\nx -= 5; // x = x - 5;\nconsole.log(x); // 10\n\nx *= 5; // x = x * 5;\nconsole.log(x); // 50\n\nx /= 5; // x = x / 5;\nconsole.log(x); // 10\n\nx %= 5; // x = x % 5;\nconsole.log(x); // 0\n```\n\n표현식은 값으로 평가 될 수 있는 문이고, 문에는 표현식인 문과 표현식이 아닌 문이 존재한다.\n그렇다면 할당문은 표현식인 문일까, 표현식이 아닌 문일까?\n\n할당문은 변수에 값을 할당하는 부수 효과만 있을 뿐 값으로 평가되지 않을 것처럼 보인다.\n하지만 할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다. 즉 변수에 할당할 수 있다.\n이러한 특징을 활용해 여러 변수에 동일한 값을 연쇄 할당할 수 있다.\n\n```javascript\nvar a, b, c;\n\na = b = c = 0;\n\nconsole.log(a, b, c); // 0 0 0\n```\n\n## 비교 연산자\n\n비교 연산자는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환한다.\n비교 연산자는 if 문이나 for 문과 같은 제어문의 조건식에서 주로 사용한다.\n\n### 동등/일치 비교 연산자\n\n동등 비교 연산자와 일치 비교 연산자는 좌항과 우항의 피연산자가 같은 값으로 평가되는지 비교해 불리언 값을 반환한다.\n하지만 비교하는 엄격성의 정도가 다르다.\n\n동등 비교(==) 연산자는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다.\n다시 말해 동등 비교 연산자는 좌항과 우항의 피연산자가 타입은 다르더라도 암묵적 타입 변환 후에 같은 값일 수 있다면 true를 반환한다.\n\n동등 비교 연산자는 편리한 경우도 있지만 결과를 예측하기 어렵고 실수하기 쉬우므로 사용하지 않는 편이 좋다.\n\n반면 일치 비교(===) 연산자는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다. 따라서 일치 비교 연산자는 예측하기 쉽다.\n\n```javascript\n5 == 5; // true\n5 == '5'; // true (암묵적 타입 변환)\n\n5 === 5; // true\n5 === '5'; // false (타입 변환 X)\n```\n\n일치 비교 연산자에서 주의할 것은 NaN이다.\n\n```javascript\nNaN === NaN; // false\n```\n\nNaN은 자신과 일치하지 않는 유일한 값이다. 숫자가 NaN인지 조사하기 위해서는 빌트인 함수 Number.isNaN을 사용한다.\n\n```javascript\nNumber.isNaN(NaN); // true\nNumber.isNaN(10); // false\n```\n\n> ES6에서 도입된 Object.is 메서드를 이용하면 예측 가능한 정확한 비교 결과를 얻을 수 있다.\n>\n> ```javascript\n> -0 === +0; // true\n> Object.is(-0, +0); // false\n>\n> NaN === NaN; // false\n> Object.is(NaN, NaN); // true\n> ```\n\n부동등 비교 연산자(!=)와 불일치 비교 연산자(!==)는 각각 동등 비교(==) 연산자와 일치 비교(===) 연산자의 반대 개념이다.\n\n### 대소 관계 비교 연산자\n\n대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다.\n\n```javascript\n5 > 0; // true\n5 > 5; // false\n5 >= 5; // true\n5 <= 5; // true\n```\n\n## 삼항 조건 연산자\n\n삼항 조건 연산자는 조건식의 평가 결과에 따라 반환할 값을 결정한다.\n자바스크립트의 유일한 삼항 연산자이며, 부수 효과는 없다.\n\n삼항 조건 연산자의 표현식은 다음과 같다.\n\n> 조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값\n\n삼항 조건 연산자는 첫 번째 피연산자가 true로 평가되면 두 번째 피연산자를 반환하고, 첫 번째 피연산자가 false로 평가되면 세 번째 피연산자를 반환한다.\n즉 삼항 조건 연산자는 두 번째 피연산자 또는 세 번째 피연산자로 평가되는 표현식이다.\n\n삼항 조건 연산자는 if...else 문을 사용해도 유사하게 처리 가능하다. 하지만 삼항 조건 연산자 표현식은 값처럼 사용할 수 있는 반면 if...else 문은 값처럼 사용할 수 없다는 차이가 있다.\n\n```javascript\nvar x = 10;\n\nvar result1 = x % 2 ? '홀수' : '짝수';\nconsole.log(result1); // 짝수\n\nvar result2 = if (x % 2) { result2 = '홀수'; } else { result2 = '짝수'; }; // SyntaxError: Unexpected token if\n```\n\n조건에 따라 어떤 값을 결정해야 한다면 if...else 문보다 삼항 조건 연산자 표현식을 사용하는 편이 유리하다.\n하지만 조건에 따라 수행해야 할 문이 하나가 아니리 여러 개라면 if...else 문의 가독성이 더 좋다.\n\n## 논리 연산자\n\n논리 연산자는 우항과 좌항의 피연산자(부정 논리 연산자의 경우 우항의 피연산자)를 논리 연산 한다.\n\n```javascript\n// 논리합(||) 연산자\ntrue || true; // true\ntrue || false; // true\nfalse || true; // true\nfalse || false; // false\n\n// 논리곱(&&) 연산자\ntrue && true; // true\ntrue && false; // false\nfalse && true; // false\nfalse && false; // false\n\n// 논리 부정(!) 연산자\n!true; // false\n!false; // true\n```\n\n논리 부정(!) 연산자는 언제나 불리언 값을 반환한다. 단 피연산자가 반드시 불리언 값일 필요는 없다.\n피연산자가 불리언 값이 아니라면 불리언 타입으로 암묵적 타입 변환된다.\n\n## 쉼표 연산자\n\n쉼표(,) 연산자는 왼쪽 피연산자부터 차레대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.\n\n```javascript\nvar x, y, z;\n\nx = 1, y = 2, z = 3; // 3\n```\n\n## 그룹 연산자\n\n소괄호(\\(\\))로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가한다. 따라서 그룹 연산자를 사용하면 연산자의 우선순위를 조절할 수 있다. 그룹 연산자는 연산자 우선순위가 가장 높다.\n\n## typeof 연산자\n\ntypeof 연산자는 피연산자의 데이터 타입을 문자열로 반환한다.\ntypeof 연산자는 \"number\", \"bigint\", \"string\", \"boolean\", \"undefined\", \"symbol\", \"object\", \"function\" 중 하나를 반환한다.\ntypeof 연산자가 반환하는 문자열이 데이터 타입과 정확히 일치하지는 않는다.\n\ntypeof 연산자로 null 값을 연산해 보면 \"null\"이 아닌 \"object\"를 반환하는데 이는 하위 호환성을 위해 수정되지 않고 있는 버그이다.\n따라서 값이 null 타입인지 확인할 때는 typeof 연산자가 아닌 일치(===) 연산자를 사용해야 한다.\n\n```javascript\nvar foo = null;\n\ntypeof foo === null; // false\nfoo === null; // true\n```\n\n또한 선언하지 않은 식별자를 typeof 연산자로 연산해 보면 ReferenceError가 발생하지 않고 undefined를 반환하는것도 주의하자.\n\n```javascript\n// undeclared 식별자를 선언하지 않았다.\ntypeof undeclared; // undefined\n```\n\n## 지수 연산자\n\nES7에서 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱한 숫자 값을 반환한다.\n\n```javascript\n2 ** 2; // 4\n2 * 0; // 1\n2 ** -2; // 0.25\n```\n\n지수 연산자가 도입되기 이전에는 Math.pow 메서드를 사용했다.\n\n```javascript\nMath.pow(2, 2); // 4\nMath.pow(2, 0); // 1\nMath.pow(2, -2); // 0.25\n```\n\n음수를 거듭제곱의 밑으로 사용해 계산하려면 괄호로 묶어주어야 한다.\n\n```javascript\n-5 ** 2;\n// SyntaxError: Unary operator used immediately before exponentiation expression. Parenthesis must be used to disambiguate operator precedence\n\n(-5) ** 2; // 25\n```\n\n## 연산자 우선순위\n\n연산자 우선순위란 여러 개의 연산자로 이뤄진 문이 실행될 때 연산자가 실행되는 순서를 말한다. 우선순위가 높을수록 먼저 실행된다.\n\n연산자는 종류가 많아 연산자 우선순위를 모두 기억하기 어렵고 실수하기도 쉽다.\n따라서 기억해 사용하기 보다는 연산자 우선순위가 높은 그룹 연산자를 사용하여 우선순위를 명시적으로 조절하는 것이 좋다.\n\n```javascript\n10 * (2 + 3); // 50\n```\n\n","slug":"Modern-Javascript-Deep-Dive-Chapter-7-Operator-Summary","published":1,"updated":"2022-10-20T10:51:09.584Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb08iq6h000je4vk6kbh6ki4","content":"<h1 id=\"연산자\"><a href=\"#연산자\" class=\"headerlink\" title=\"연산자\"></a>연산자</h1><p>연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다.</p>\n<p>이 때 연산의 대상을 피연산자라 한다. 피연산자는 값으로 평가될 수 있는 표현식이어야 한다.<br>그리고 피연산자와 연산자의 조합으로 이뤄진 연산자 표현식도 값으로 평가될 수 있는 표현식이다.</p>\n<p>자바스크립트가 제공하는 다양한 연산자에 대해 살펴보자.</p>\n<h2 id=\"산술-연산자\"><a href=\"#산술-연산자\" class=\"headerlink\" title=\"산술 연산자\"></a>산술 연산자</h2><p>산술 연산자는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다.<br>산술 연산이 불가능한 경우, NaN을 반환한다.</p>\n<p>산술 연산자는 피연산자의 개수에 따라 이항 산술 연산자와 단항 산술 연산자로 구분할 수 있다.</p>\n<h3 id=\"이항-산술-연산자\"><a href=\"#이항-산술-연산자\" class=\"headerlink\" title=\"이항 산술 연산자\"></a>이항 산술 연산자</h3><p>이항 산술 연산자는 2개의 피연산자를 산술 연산하여 숫자 값을 만든다.</p>\n<p>모든 이항 산술 연산자는 피연산자의 값을 변경하는 부수효과가 없다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span> + <span class=\"number\">2</span>; <span class=\"comment\">// 7</span></span><br><span class=\"line\"><span class=\"number\">5</span> - <span class=\"number\">2</span>; <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"number\">5</span> * <span class=\"number\">2</span>; <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"number\">5</span> / <span class=\"number\">2</span>; <span class=\"comment\">// 2.5</span></span><br><span class=\"line\"><span class=\"number\">5</span> % <span class=\"number\">2</span>; <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"단항-산술-연산자\"><a href=\"#단항-산술-연산자\" class=\"headerlink\" title=\"단항 산술 연산자\"></a>단항 산술 연산자</h3><p>단항 산술 연산자는 1개의 피연산자를 산술 연산하여 숫자 값을 만든다.</p>\n<p>이 때 증가&#x2F;감소(++&#x2F;–) 연산자는 피연산자의 값을 변경한느 부수 효과가 있어 주의해야 한다.<br>즉 증가&#x2F;감소 연산을 하면 피연산자의 값을 변경하는 암묵적 할당이 이뤄진다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">x++; <span class=\"comment\">// x = x + 1;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">x--; <span class=\"comment\">// x = x - 1;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<p>또한 증가&#x2F;감소 연산자는 위치에 따라 선 할당후 연산이 이루어지는지, 연산이 수행되고 할당이 이루어지는지 다르므로 주의해야 한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">5</span>,</span><br><span class=\"line\">  result;</span><br><span class=\"line\"></span><br><span class=\"line\">result = x++; <span class=\"comment\">// 선할당 후증가</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result, x); <span class=\"comment\">// 5 6</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = ++x; <span class=\"comment\">// 선증가 후할당</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result, x); <span class=\"comment\">// 7 7</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = x--; <span class=\"comment\">// 선할당 후감소</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result, x); <span class=\"comment\">// 7 6</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = --x; <span class=\"comment\">// 선감소 후할당</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result, x); <span class=\"comment\">// 5 5</span></span><br></pre></td></tr></table></figure>\n\n<p>+ 단항 연산자는 피연산자에 어떠한 효과도 없다.<br>다만 숫자 타입이 아닌 피연산자에 + 단항 연산자를 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다.<br>이때 피연산자를 변경하는 것은 아니고 숫자 타입으로 변환한 값을 생성해서 반환한다. 즉 부수 효과가 없다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(+x); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x); <span class=\"comment\">// &quot;1&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>- 단항 연산자는 피연산자에 부호를 반전한 값을 반환한다.<br>+ 단항 연산자와 마찬가지로 숫자타입이 아닌 피연산자에 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다.<br>이때 피연산자를 변경하는 것은 아니고 숫자 타입으로 변환한 값을 생성해서 반환한다. 즉 부수 효과가 없다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(-<span class=\"number\">10</span>); <span class=\"comment\">// 10 (부호 반전)</span></span><br><span class=\"line\">-<span class=\"literal\">true</span>; <span class=\"comment\">// -1 (타입 변환)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"문자열-연결-연산자\"><a href=\"#문자열-연결-연산자\" class=\"headerlink\" title=\"문자열 연결 연산자\"></a>문자열 연결 연산자</h3><p>+ 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.<br>그 외의 경우는 산술 연산자로 동작한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 문자열 연결 연산자</span></span><br><span class=\"line\"><span class=\"string\">&#x27;1&#x27;</span> + <span class=\"number\">2</span>; <span class=\"comment\">// &quot;12&quot;</span></span><br><span class=\"line\"><span class=\"number\">2</span> + <span class=\"string\">&#x27;1&#x27;</span>; <span class=\"comment\">// &quot;12&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 산술 연산자</span></span><br><span class=\"line\"><span class=\"number\">1</span> + <span class=\"number\">2</span>; <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 타입 변환이 일어나는 경우</span></span><br><span class=\"line\"><span class=\"number\">1</span> + <span class=\"literal\">true</span>; <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"number\">1</span> + <span class=\"literal\">undefined</span>; <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<p>이 때 주목할 점은 개발자의 의도와는 상관 없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다는 것이다.<br>1 + true를 연산하면 자바스크립트 엔진은 암묵적으로 불리언 타입 값인 true를 숫자 탕비인 1로 강제로 변환한 후 연산을 수행한다.</p>\n<p>이를 암묵적 타입 변환이라고 한다. 앞서 살펴본 +&#x2F;- 단항 연산자도 암묵적 타입 변환이 발생한 것이다</p>\n<h2 id=\"할당-연산자\"><a href=\"#할당-연산자\" class=\"headerlink\" title=\"할당 연산자\"></a>할당 연산자</h2><p>할당 연산자는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다.<br>할당 연산자는 좌항의 변수에 값을 할당하므로 변수 값이 변하는 부수 효과가 존재한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x;</span><br><span class=\"line\"></span><br><span class=\"line\">x = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x); <span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\">x += <span class=\"number\">5</span>; <span class=\"comment\">// x = x + 5;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x); <span class=\"comment\">// 15</span></span><br><span class=\"line\"></span><br><span class=\"line\">x -= <span class=\"number\">5</span>; <span class=\"comment\">// x = x - 5;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x); <span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\">x *= <span class=\"number\">5</span>; <span class=\"comment\">// x = x * 5;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x); <span class=\"comment\">// 50</span></span><br><span class=\"line\"></span><br><span class=\"line\">x /= <span class=\"number\">5</span>; <span class=\"comment\">// x = x / 5;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x); <span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\">x %= <span class=\"number\">5</span>; <span class=\"comment\">// x = x % 5;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x); <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n<p>표현식은 값으로 평가 될 수 있는 문이고, 문에는 표현식인 문과 표현식이 아닌 문이 존재한다.<br>그렇다면 할당문은 표현식인 문일까, 표현식이 아닌 문일까?</p>\n<p>할당문은 변수에 값을 할당하는 부수 효과만 있을 뿐 값으로 평가되지 않을 것처럼 보인다.<br>하지만 할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다. 즉 변수에 할당할 수 있다.<br>이러한 특징을 활용해 여러 변수에 동일한 값을 연쇄 할당할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a, b, c;</span><br><span class=\"line\"></span><br><span class=\"line\">a = b = c = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a, b, c); <span class=\"comment\">// 0 0 0</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"비교-연산자\"><a href=\"#비교-연산자\" class=\"headerlink\" title=\"비교 연산자\"></a>비교 연산자</h2><p>비교 연산자는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환한다.<br>비교 연산자는 if 문이나 for 문과 같은 제어문의 조건식에서 주로 사용한다.</p>\n<h3 id=\"동등-x2F-일치-비교-연산자\"><a href=\"#동등-x2F-일치-비교-연산자\" class=\"headerlink\" title=\"동등&#x2F;일치 비교 연산자\"></a>동등&#x2F;일치 비교 연산자</h3><p>동등 비교 연산자와 일치 비교 연산자는 좌항과 우항의 피연산자가 같은 값으로 평가되는지 비교해 불리언 값을 반환한다.<br>하지만 비교하는 엄격성의 정도가 다르다.</p>\n<p>동등 비교(&#x3D;&#x3D;) 연산자는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다.<br>다시 말해 동등 비교 연산자는 좌항과 우항의 피연산자가 타입은 다르더라도 암묵적 타입 변환 후에 같은 값일 수 있다면 true를 반환한다.</p>\n<p>동등 비교 연산자는 편리한 경우도 있지만 결과를 예측하기 어렵고 실수하기 쉬우므로 사용하지 않는 편이 좋다.</p>\n<p>반면 일치 비교(&#x3D;&#x3D;&#x3D;) 연산자는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다. 따라서 일치 비교 연산자는 예측하기 쉽다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span> == <span class=\"number\">5</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">5</span> == <span class=\"string\">&#x27;5&#x27;</span>; <span class=\"comment\">// true (암묵적 타입 변환)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">5</span> === <span class=\"number\">5</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">5</span> === <span class=\"string\">&#x27;5&#x27;</span>; <span class=\"comment\">// false (타입 변환 X)</span></span><br></pre></td></tr></table></figure>\n\n<p>일치 비교 연산자에서 주의할 것은 NaN이다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">NaN</span> === <span class=\"title class_\">NaN</span>; <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>NaN은 자신과 일치하지 않는 유일한 값이다. 숫자가 NaN인지 조사하기 위해서는 빌트인 함수 Number.isNaN을 사용한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Number</span>.<span class=\"built_in\">isNaN</span>(<span class=\"title class_\">NaN</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>.<span class=\"built_in\">isNaN</span>(<span class=\"number\">10</span>); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>ES6에서 도입된 Object.is 메서드를 이용하면 예측 가능한 정확한 비교 결과를 얻을 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-<span class=\"number\">0</span> === +<span class=\"number\">0</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">is</span>(-<span class=\"number\">0</span>, +<span class=\"number\">0</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">NaN</span> === <span class=\"title class_\">NaN</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">is</span>(<span class=\"title class_\">NaN</span>, <span class=\"title class_\">NaN</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>부동등 비교 연산자(!&#x3D;)와 불일치 비교 연산자(!&#x3D;&#x3D;)는 각각 동등 비교(&#x3D;&#x3D;) 연산자와 일치 비교(&#x3D;&#x3D;&#x3D;) 연산자의 반대 개념이다.</p>\n<h3 id=\"대소-관계-비교-연산자\"><a href=\"#대소-관계-비교-연산자\" class=\"headerlink\" title=\"대소 관계 비교 연산자\"></a>대소 관계 비교 연산자</h3><p>대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span> &gt; <span class=\"number\">0</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">5</span> &gt; <span class=\"number\">5</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"number\">5</span> &gt;= <span class=\"number\">5</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">5</span> &lt;= <span class=\"number\">5</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"삼항-조건-연산자\"><a href=\"#삼항-조건-연산자\" class=\"headerlink\" title=\"삼항 조건 연산자\"></a>삼항 조건 연산자</h2><p>삼항 조건 연산자는 조건식의 평가 결과에 따라 반환할 값을 결정한다.<br>자바스크립트의 유일한 삼항 연산자이며, 부수 효과는 없다.</p>\n<p>삼항 조건 연산자의 표현식은 다음과 같다.</p>\n<blockquote>\n<p>조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값</p>\n</blockquote>\n<p>삼항 조건 연산자는 첫 번째 피연산자가 true로 평가되면 두 번째 피연산자를 반환하고, 첫 번째 피연산자가 false로 평가되면 세 번째 피연산자를 반환한다.<br>즉 삼항 조건 연산자는 두 번째 피연산자 또는 세 번째 피연산자로 평가되는 표현식이다.</p>\n<p>삼항 조건 연산자는 if…else 문을 사용해도 유사하게 처리 가능하다. 하지만 삼항 조건 연산자 표현식은 값처럼 사용할 수 있는 반면 if…else 문은 값처럼 사용할 수 없다는 차이가 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result1 = x % <span class=\"number\">2</span> ? <span class=\"string\">&#x27;홀수&#x27;</span> : <span class=\"string\">&#x27;짝수&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result1); <span class=\"comment\">// 짝수</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result2 = <span class=\"keyword\">if</span> (x % <span class=\"number\">2</span>) &#123; result2 = <span class=\"string\">&#x27;홀수&#x27;</span>; &#125; <span class=\"keyword\">else</span> &#123; result2 = <span class=\"string\">&#x27;짝수&#x27;</span>; &#125;; <span class=\"comment\">// SyntaxError: Unexpected token if</span></span><br></pre></td></tr></table></figure>\n\n<p>조건에 따라 어떤 값을 결정해야 한다면 if…else 문보다 삼항 조건 연산자 표현식을 사용하는 편이 유리하다.<br>하지만 조건에 따라 수행해야 할 문이 하나가 아니리 여러 개라면 if…else 문의 가독성이 더 좋다.</p>\n<h2 id=\"논리-연산자\"><a href=\"#논리-연산자\" class=\"headerlink\" title=\"논리 연산자\"></a>논리 연산자</h2><p>논리 연산자는 우항과 좌항의 피연산자(부정 논리 연산자의 경우 우항의 피연산자)를 논리 연산 한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 논리합(||) 연산자</span></span><br><span class=\"line\"><span class=\"literal\">true</span> || <span class=\"literal\">true</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">true</span> || <span class=\"literal\">false</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">false</span> || <span class=\"literal\">true</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">false</span> || <span class=\"literal\">false</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 논리곱(&amp;&amp;) 연산자</span></span><br><span class=\"line\"><span class=\"literal\">true</span> &amp;&amp; <span class=\"literal\">true</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">true</span> &amp;&amp; <span class=\"literal\">false</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">false</span> &amp;&amp; <span class=\"literal\">true</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">false</span> &amp;&amp; <span class=\"literal\">false</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 논리 부정(!) 연산자</span></span><br><span class=\"line\">!<span class=\"literal\">true</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\">!<span class=\"literal\">false</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>논리 부정(!) 연산자는 언제나 불리언 값을 반환한다. 단 피연산자가 반드시 불리언 값일 필요는 없다.<br>피연산자가 불리언 값이 아니라면 불리언 타입으로 암묵적 타입 변환된다.</p>\n<h2 id=\"쉼표-연산자\"><a href=\"#쉼표-연산자\" class=\"headerlink\" title=\"쉼표 연산자\"></a>쉼표 연산자</h2><p>쉼표(,) 연산자는 왼쪽 피연산자부터 차레대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x, y, z;</span><br><span class=\"line\"></span><br><span class=\"line\">x = <span class=\"number\">1</span>, y = <span class=\"number\">2</span>, z = <span class=\"number\">3</span>; <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"그룹-연산자\"><a href=\"#그룹-연산자\" class=\"headerlink\" title=\"그룹 연산자\"></a>그룹 연산자</h2><p>소괄호(())로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가한다. 따라서 그룹 연산자를 사용하면 연산자의 우선순위를 조절할 수 있다. 그룹 연산자는 연산자 우선순위가 가장 높다.</p>\n<h2 id=\"typeof-연산자\"><a href=\"#typeof-연산자\" class=\"headerlink\" title=\"typeof 연산자\"></a>typeof 연산자</h2><p>typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환한다.<br>typeof 연산자는 “number”, “bigint”, “string”, “boolean”, “undefined”, “symbol”, “object”, “function” 중 하나를 반환한다.<br>typeof 연산자가 반환하는 문자열이 데이터 타입과 정확히 일치하지는 않는다.</p>\n<p>typeof 연산자로 null 값을 연산해 보면 “null”이 아닌 “object”를 반환하는데 이는 하위 호환성을 위해 수정되지 않고 있는 버그이다.<br>따라서 값이 null 타입인지 확인할 때는 typeof 연산자가 아닌 일치(&#x3D;&#x3D;&#x3D;) 연산자를 사용해야 한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> foo === <span class=\"literal\">null</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\">foo === <span class=\"literal\">null</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>또한 선언하지 않은 식별자를 typeof 연산자로 연산해 보면 ReferenceError가 발생하지 않고 undefined를 반환하는것도 주의하자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// undeclared 식별자를 선언하지 않았다.</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> undeclared; <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"지수-연산자\"><a href=\"#지수-연산자\" class=\"headerlink\" title=\"지수 연산자\"></a>지수 연산자</h2><p>ES7에서 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱한 숫자 값을 반환한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span> ** <span class=\"number\">2</span>; <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"number\">2</span> * <span class=\"number\">0</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"number\">2</span> ** -<span class=\"number\">2</span>; <span class=\"comment\">// 0.25</span></span><br></pre></td></tr></table></figure>\n\n<p>지수 연산자가 도입되기 이전에는 Math.pow 메서드를 사용했다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Math</span>.<span class=\"title function_\">pow</span>(<span class=\"number\">2</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"title class_\">Math</span>.<span class=\"title function_\">pow</span>(<span class=\"number\">2</span>, <span class=\"number\">0</span>); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"title class_\">Math</span>.<span class=\"title function_\">pow</span>(<span class=\"number\">2</span>, -<span class=\"number\">2</span>); <span class=\"comment\">// 0.25</span></span><br></pre></td></tr></table></figure>\n\n<p>음수를 거듭제곱의 밑으로 사용해 계산하려면 괄호로 묶어주어야 한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-<span class=\"number\">5</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"comment\">// SyntaxError: Unary operator used immediately before exponentiation expression. Parenthesis must be used to disambiguate operator precedence</span></span><br><span class=\"line\"></span><br><span class=\"line\">(-<span class=\"number\">5</span>) ** <span class=\"number\">2</span>; <span class=\"comment\">// 25</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"연산자-우선순위\"><a href=\"#연산자-우선순위\" class=\"headerlink\" title=\"연산자 우선순위\"></a>연산자 우선순위</h2><p>연산자 우선순위란 여러 개의 연산자로 이뤄진 문이 실행될 때 연산자가 실행되는 순서를 말한다. 우선순위가 높을수록 먼저 실행된다.</p>\n<p>연산자는 종류가 많아 연산자 우선순위를 모두 기억하기 어렵고 실수하기도 쉽다.<br>따라서 기억해 사용하기 보다는 연산자 우선순위가 높은 그룹 연산자를 사용하여 우선순위를 명시적으로 조절하는 것이 좋다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span> * (<span class=\"number\">2</span> + <span class=\"number\">3</span>); <span class=\"comment\">// 50</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"연산자\"><a href=\"#연산자\" class=\"headerlink\" title=\"연산자\"></a>연산자</h1><p>연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다.</p>\n<p>이 때 연산의 대상을 피연산자라 한다. 피연산자는 값으로 평가될 수 있는 표현식이어야 한다.<br>그리고 피연산자와 연산자의 조합으로 이뤄진 연산자 표현식도 값으로 평가될 수 있는 표현식이다.</p>\n<p>자바스크립트가 제공하는 다양한 연산자에 대해 살펴보자.</p>\n<h2 id=\"산술-연산자\"><a href=\"#산술-연산자\" class=\"headerlink\" title=\"산술 연산자\"></a>산술 연산자</h2><p>산술 연산자는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다.<br>산술 연산이 불가능한 경우, NaN을 반환한다.</p>\n<p>산술 연산자는 피연산자의 개수에 따라 이항 산술 연산자와 단항 산술 연산자로 구분할 수 있다.</p>\n<h3 id=\"이항-산술-연산자\"><a href=\"#이항-산술-연산자\" class=\"headerlink\" title=\"이항 산술 연산자\"></a>이항 산술 연산자</h3><p>이항 산술 연산자는 2개의 피연산자를 산술 연산하여 숫자 값을 만든다.</p>\n<p>모든 이항 산술 연산자는 피연산자의 값을 변경하는 부수효과가 없다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span> + <span class=\"number\">2</span>; <span class=\"comment\">// 7</span></span><br><span class=\"line\"><span class=\"number\">5</span> - <span class=\"number\">2</span>; <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"number\">5</span> * <span class=\"number\">2</span>; <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"number\">5</span> / <span class=\"number\">2</span>; <span class=\"comment\">// 2.5</span></span><br><span class=\"line\"><span class=\"number\">5</span> % <span class=\"number\">2</span>; <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"단항-산술-연산자\"><a href=\"#단항-산술-연산자\" class=\"headerlink\" title=\"단항 산술 연산자\"></a>단항 산술 연산자</h3><p>단항 산술 연산자는 1개의 피연산자를 산술 연산하여 숫자 값을 만든다.</p>\n<p>이 때 증가&#x2F;감소(++&#x2F;–) 연산자는 피연산자의 값을 변경한느 부수 효과가 있어 주의해야 한다.<br>즉 증가&#x2F;감소 연산을 하면 피연산자의 값을 변경하는 암묵적 할당이 이뤄진다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">x++; <span class=\"comment\">// x = x + 1;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">x--; <span class=\"comment\">// x = x - 1;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<p>또한 증가&#x2F;감소 연산자는 위치에 따라 선 할당후 연산이 이루어지는지, 연산이 수행되고 할당이 이루어지는지 다르므로 주의해야 한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">5</span>,</span><br><span class=\"line\">  result;</span><br><span class=\"line\"></span><br><span class=\"line\">result = x++; <span class=\"comment\">// 선할당 후증가</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result, x); <span class=\"comment\">// 5 6</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = ++x; <span class=\"comment\">// 선증가 후할당</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result, x); <span class=\"comment\">// 7 7</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = x--; <span class=\"comment\">// 선할당 후감소</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result, x); <span class=\"comment\">// 7 6</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = --x; <span class=\"comment\">// 선감소 후할당</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result, x); <span class=\"comment\">// 5 5</span></span><br></pre></td></tr></table></figure>\n\n<p>+ 단항 연산자는 피연산자에 어떠한 효과도 없다.<br>다만 숫자 타입이 아닌 피연산자에 + 단항 연산자를 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다.<br>이때 피연산자를 변경하는 것은 아니고 숫자 타입으로 변환한 값을 생성해서 반환한다. 즉 부수 효과가 없다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(+x); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x); <span class=\"comment\">// &quot;1&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>- 단항 연산자는 피연산자에 부호를 반전한 값을 반환한다.<br>+ 단항 연산자와 마찬가지로 숫자타입이 아닌 피연산자에 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다.<br>이때 피연산자를 변경하는 것은 아니고 숫자 타입으로 변환한 값을 생성해서 반환한다. 즉 부수 효과가 없다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(-<span class=\"number\">10</span>); <span class=\"comment\">// 10 (부호 반전)</span></span><br><span class=\"line\">-<span class=\"literal\">true</span>; <span class=\"comment\">// -1 (타입 변환)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"문자열-연결-연산자\"><a href=\"#문자열-연결-연산자\" class=\"headerlink\" title=\"문자열 연결 연산자\"></a>문자열 연결 연산자</h3><p>+ 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.<br>그 외의 경우는 산술 연산자로 동작한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 문자열 연결 연산자</span></span><br><span class=\"line\"><span class=\"string\">&#x27;1&#x27;</span> + <span class=\"number\">2</span>; <span class=\"comment\">// &quot;12&quot;</span></span><br><span class=\"line\"><span class=\"number\">2</span> + <span class=\"string\">&#x27;1&#x27;</span>; <span class=\"comment\">// &quot;12&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 산술 연산자</span></span><br><span class=\"line\"><span class=\"number\">1</span> + <span class=\"number\">2</span>; <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 타입 변환이 일어나는 경우</span></span><br><span class=\"line\"><span class=\"number\">1</span> + <span class=\"literal\">true</span>; <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"number\">1</span> + <span class=\"literal\">undefined</span>; <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<p>이 때 주목할 점은 개발자의 의도와는 상관 없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다는 것이다.<br>1 + true를 연산하면 자바스크립트 엔진은 암묵적으로 불리언 타입 값인 true를 숫자 탕비인 1로 강제로 변환한 후 연산을 수행한다.</p>\n<p>이를 암묵적 타입 변환이라고 한다. 앞서 살펴본 +&#x2F;- 단항 연산자도 암묵적 타입 변환이 발생한 것이다</p>\n<h2 id=\"할당-연산자\"><a href=\"#할당-연산자\" class=\"headerlink\" title=\"할당 연산자\"></a>할당 연산자</h2><p>할당 연산자는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다.<br>할당 연산자는 좌항의 변수에 값을 할당하므로 변수 값이 변하는 부수 효과가 존재한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x;</span><br><span class=\"line\"></span><br><span class=\"line\">x = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x); <span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\">x += <span class=\"number\">5</span>; <span class=\"comment\">// x = x + 5;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x); <span class=\"comment\">// 15</span></span><br><span class=\"line\"></span><br><span class=\"line\">x -= <span class=\"number\">5</span>; <span class=\"comment\">// x = x - 5;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x); <span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\">x *= <span class=\"number\">5</span>; <span class=\"comment\">// x = x * 5;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x); <span class=\"comment\">// 50</span></span><br><span class=\"line\"></span><br><span class=\"line\">x /= <span class=\"number\">5</span>; <span class=\"comment\">// x = x / 5;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x); <span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\">x %= <span class=\"number\">5</span>; <span class=\"comment\">// x = x % 5;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x); <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n<p>표현식은 값으로 평가 될 수 있는 문이고, 문에는 표현식인 문과 표현식이 아닌 문이 존재한다.<br>그렇다면 할당문은 표현식인 문일까, 표현식이 아닌 문일까?</p>\n<p>할당문은 변수에 값을 할당하는 부수 효과만 있을 뿐 값으로 평가되지 않을 것처럼 보인다.<br>하지만 할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다. 즉 변수에 할당할 수 있다.<br>이러한 특징을 활용해 여러 변수에 동일한 값을 연쇄 할당할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a, b, c;</span><br><span class=\"line\"></span><br><span class=\"line\">a = b = c = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a, b, c); <span class=\"comment\">// 0 0 0</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"비교-연산자\"><a href=\"#비교-연산자\" class=\"headerlink\" title=\"비교 연산자\"></a>비교 연산자</h2><p>비교 연산자는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환한다.<br>비교 연산자는 if 문이나 for 문과 같은 제어문의 조건식에서 주로 사용한다.</p>\n<h3 id=\"동등-x2F-일치-비교-연산자\"><a href=\"#동등-x2F-일치-비교-연산자\" class=\"headerlink\" title=\"동등&#x2F;일치 비교 연산자\"></a>동등&#x2F;일치 비교 연산자</h3><p>동등 비교 연산자와 일치 비교 연산자는 좌항과 우항의 피연산자가 같은 값으로 평가되는지 비교해 불리언 값을 반환한다.<br>하지만 비교하는 엄격성의 정도가 다르다.</p>\n<p>동등 비교(&#x3D;&#x3D;) 연산자는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다.<br>다시 말해 동등 비교 연산자는 좌항과 우항의 피연산자가 타입은 다르더라도 암묵적 타입 변환 후에 같은 값일 수 있다면 true를 반환한다.</p>\n<p>동등 비교 연산자는 편리한 경우도 있지만 결과를 예측하기 어렵고 실수하기 쉬우므로 사용하지 않는 편이 좋다.</p>\n<p>반면 일치 비교(&#x3D;&#x3D;&#x3D;) 연산자는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다. 따라서 일치 비교 연산자는 예측하기 쉽다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span> == <span class=\"number\">5</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">5</span> == <span class=\"string\">&#x27;5&#x27;</span>; <span class=\"comment\">// true (암묵적 타입 변환)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">5</span> === <span class=\"number\">5</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">5</span> === <span class=\"string\">&#x27;5&#x27;</span>; <span class=\"comment\">// false (타입 변환 X)</span></span><br></pre></td></tr></table></figure>\n\n<p>일치 비교 연산자에서 주의할 것은 NaN이다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">NaN</span> === <span class=\"title class_\">NaN</span>; <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>NaN은 자신과 일치하지 않는 유일한 값이다. 숫자가 NaN인지 조사하기 위해서는 빌트인 함수 Number.isNaN을 사용한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Number</span>.<span class=\"built_in\">isNaN</span>(<span class=\"title class_\">NaN</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>.<span class=\"built_in\">isNaN</span>(<span class=\"number\">10</span>); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>ES6에서 도입된 Object.is 메서드를 이용하면 예측 가능한 정확한 비교 결과를 얻을 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-<span class=\"number\">0</span> === +<span class=\"number\">0</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">is</span>(-<span class=\"number\">0</span>, +<span class=\"number\">0</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">NaN</span> === <span class=\"title class_\">NaN</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">is</span>(<span class=\"title class_\">NaN</span>, <span class=\"title class_\">NaN</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>부동등 비교 연산자(!&#x3D;)와 불일치 비교 연산자(!&#x3D;&#x3D;)는 각각 동등 비교(&#x3D;&#x3D;) 연산자와 일치 비교(&#x3D;&#x3D;&#x3D;) 연산자의 반대 개념이다.</p>\n<h3 id=\"대소-관계-비교-연산자\"><a href=\"#대소-관계-비교-연산자\" class=\"headerlink\" title=\"대소 관계 비교 연산자\"></a>대소 관계 비교 연산자</h3><p>대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span> &gt; <span class=\"number\">0</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">5</span> &gt; <span class=\"number\">5</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"number\">5</span> &gt;= <span class=\"number\">5</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">5</span> &lt;= <span class=\"number\">5</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"삼항-조건-연산자\"><a href=\"#삼항-조건-연산자\" class=\"headerlink\" title=\"삼항 조건 연산자\"></a>삼항 조건 연산자</h2><p>삼항 조건 연산자는 조건식의 평가 결과에 따라 반환할 값을 결정한다.<br>자바스크립트의 유일한 삼항 연산자이며, 부수 효과는 없다.</p>\n<p>삼항 조건 연산자의 표현식은 다음과 같다.</p>\n<blockquote>\n<p>조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값</p>\n</blockquote>\n<p>삼항 조건 연산자는 첫 번째 피연산자가 true로 평가되면 두 번째 피연산자를 반환하고, 첫 번째 피연산자가 false로 평가되면 세 번째 피연산자를 반환한다.<br>즉 삼항 조건 연산자는 두 번째 피연산자 또는 세 번째 피연산자로 평가되는 표현식이다.</p>\n<p>삼항 조건 연산자는 if…else 문을 사용해도 유사하게 처리 가능하다. 하지만 삼항 조건 연산자 표현식은 값처럼 사용할 수 있는 반면 if…else 문은 값처럼 사용할 수 없다는 차이가 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result1 = x % <span class=\"number\">2</span> ? <span class=\"string\">&#x27;홀수&#x27;</span> : <span class=\"string\">&#x27;짝수&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result1); <span class=\"comment\">// 짝수</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result2 = <span class=\"keyword\">if</span> (x % <span class=\"number\">2</span>) &#123; result2 = <span class=\"string\">&#x27;홀수&#x27;</span>; &#125; <span class=\"keyword\">else</span> &#123; result2 = <span class=\"string\">&#x27;짝수&#x27;</span>; &#125;; <span class=\"comment\">// SyntaxError: Unexpected token if</span></span><br></pre></td></tr></table></figure>\n\n<p>조건에 따라 어떤 값을 결정해야 한다면 if…else 문보다 삼항 조건 연산자 표현식을 사용하는 편이 유리하다.<br>하지만 조건에 따라 수행해야 할 문이 하나가 아니리 여러 개라면 if…else 문의 가독성이 더 좋다.</p>\n<h2 id=\"논리-연산자\"><a href=\"#논리-연산자\" class=\"headerlink\" title=\"논리 연산자\"></a>논리 연산자</h2><p>논리 연산자는 우항과 좌항의 피연산자(부정 논리 연산자의 경우 우항의 피연산자)를 논리 연산 한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 논리합(||) 연산자</span></span><br><span class=\"line\"><span class=\"literal\">true</span> || <span class=\"literal\">true</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">true</span> || <span class=\"literal\">false</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">false</span> || <span class=\"literal\">true</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">false</span> || <span class=\"literal\">false</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 논리곱(&amp;&amp;) 연산자</span></span><br><span class=\"line\"><span class=\"literal\">true</span> &amp;&amp; <span class=\"literal\">true</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">true</span> &amp;&amp; <span class=\"literal\">false</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">false</span> &amp;&amp; <span class=\"literal\">true</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">false</span> &amp;&amp; <span class=\"literal\">false</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 논리 부정(!) 연산자</span></span><br><span class=\"line\">!<span class=\"literal\">true</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\">!<span class=\"literal\">false</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>논리 부정(!) 연산자는 언제나 불리언 값을 반환한다. 단 피연산자가 반드시 불리언 값일 필요는 없다.<br>피연산자가 불리언 값이 아니라면 불리언 타입으로 암묵적 타입 변환된다.</p>\n<h2 id=\"쉼표-연산자\"><a href=\"#쉼표-연산자\" class=\"headerlink\" title=\"쉼표 연산자\"></a>쉼표 연산자</h2><p>쉼표(,) 연산자는 왼쪽 피연산자부터 차레대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x, y, z;</span><br><span class=\"line\"></span><br><span class=\"line\">x = <span class=\"number\">1</span>, y = <span class=\"number\">2</span>, z = <span class=\"number\">3</span>; <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"그룹-연산자\"><a href=\"#그룹-연산자\" class=\"headerlink\" title=\"그룹 연산자\"></a>그룹 연산자</h2><p>소괄호(())로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가한다. 따라서 그룹 연산자를 사용하면 연산자의 우선순위를 조절할 수 있다. 그룹 연산자는 연산자 우선순위가 가장 높다.</p>\n<h2 id=\"typeof-연산자\"><a href=\"#typeof-연산자\" class=\"headerlink\" title=\"typeof 연산자\"></a>typeof 연산자</h2><p>typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환한다.<br>typeof 연산자는 “number”, “bigint”, “string”, “boolean”, “undefined”, “symbol”, “object”, “function” 중 하나를 반환한다.<br>typeof 연산자가 반환하는 문자열이 데이터 타입과 정확히 일치하지는 않는다.</p>\n<p>typeof 연산자로 null 값을 연산해 보면 “null”이 아닌 “object”를 반환하는데 이는 하위 호환성을 위해 수정되지 않고 있는 버그이다.<br>따라서 값이 null 타입인지 확인할 때는 typeof 연산자가 아닌 일치(&#x3D;&#x3D;&#x3D;) 연산자를 사용해야 한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> foo === <span class=\"literal\">null</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\">foo === <span class=\"literal\">null</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>또한 선언하지 않은 식별자를 typeof 연산자로 연산해 보면 ReferenceError가 발생하지 않고 undefined를 반환하는것도 주의하자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// undeclared 식별자를 선언하지 않았다.</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> undeclared; <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"지수-연산자\"><a href=\"#지수-연산자\" class=\"headerlink\" title=\"지수 연산자\"></a>지수 연산자</h2><p>ES7에서 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱한 숫자 값을 반환한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span> ** <span class=\"number\">2</span>; <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"number\">2</span> * <span class=\"number\">0</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"number\">2</span> ** -<span class=\"number\">2</span>; <span class=\"comment\">// 0.25</span></span><br></pre></td></tr></table></figure>\n\n<p>지수 연산자가 도입되기 이전에는 Math.pow 메서드를 사용했다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Math</span>.<span class=\"title function_\">pow</span>(<span class=\"number\">2</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"title class_\">Math</span>.<span class=\"title function_\">pow</span>(<span class=\"number\">2</span>, <span class=\"number\">0</span>); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"title class_\">Math</span>.<span class=\"title function_\">pow</span>(<span class=\"number\">2</span>, -<span class=\"number\">2</span>); <span class=\"comment\">// 0.25</span></span><br></pre></td></tr></table></figure>\n\n<p>음수를 거듭제곱의 밑으로 사용해 계산하려면 괄호로 묶어주어야 한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-<span class=\"number\">5</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"comment\">// SyntaxError: Unary operator used immediately before exponentiation expression. Parenthesis must be used to disambiguate operator precedence</span></span><br><span class=\"line\"></span><br><span class=\"line\">(-<span class=\"number\">5</span>) ** <span class=\"number\">2</span>; <span class=\"comment\">// 25</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"연산자-우선순위\"><a href=\"#연산자-우선순위\" class=\"headerlink\" title=\"연산자 우선순위\"></a>연산자 우선순위</h2><p>연산자 우선순위란 여러 개의 연산자로 이뤄진 문이 실행될 때 연산자가 실행되는 순서를 말한다. 우선순위가 높을수록 먼저 실행된다.</p>\n<p>연산자는 종류가 많아 연산자 우선순위를 모두 기억하기 어렵고 실수하기도 쉽다.<br>따라서 기억해 사용하기 보다는 연산자 우선순위가 높은 그룹 연산자를 사용하여 우선순위를 명시적으로 조절하는 것이 좋다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span> * (<span class=\"number\">2</span> + <span class=\"number\">3</span>); <span class=\"comment\">// 50</span></span><br></pre></td></tr></table></figure>\n\n"},{"title":"첫 프로젝트를 마치고","date":"2022-10-04T10:55:18.000Z","_content":"# 들어가며\n약 2주동안 진행했던 프로젝트가 종료되었다. 개발 공부를 시작한지도 얼마 안 되었고 처음으로 해본 프로젝트인지라 2주가 정말 정신없이 지나가버렸다. 배운점도 많았고 아쉬운점도 많았는데 회고를 하며 정리해보려고 한다.\n\n완성된 결과물은 https://woowahal-6go5.vercel.app/ 에서 확인 가능하다.\n\n<hr>\n\n# 프로젝트 우아할\n\n이전글에서 언급했듯이 우리 팀은 배달의 민족 앱을 웹 페이지로 클론하기로 했다(그래서 팀명도 **우아할**형제들로 정했다).\n\n개발 기간은 2022-09-19 ~ 2022-09-30로 약 2주 동안 진행되었고, 팀원은 나를 포함해 총 3명이었다.\n\n프로젝트 기간이나 인원에 비해 배달의 민족이 가지고 있는 콘텐츠가 너무 많아 모든 페이지를 클론 할 수는 없었고 배달의 민족에서 배달하기 까지의 주요 프로세스를 메인,카테고리, 리스트, 디테일, 오더, 장바구니, 결과의 7개 페이지로 나누어 구현해 보았다.\n\n나는 그 중 메인페이지와 카테고리 페이지를 주로 담당했다.\n\n<hr>\n\n## 기술 스택\n\n페이지를 구현하면서 Figma, Git, npm, HTML, CSS, Sass, JS, Vercel을 이용했다.\n\n### Figma\n\n구현해야 하는 페이지들의 와이어프레임 및 컴포넌트들을 시각적으로 구성해보기 위해 Figma를 이용했다.\n\n페이지에서 주사용되는 컬러를 시스템화해서 플러그인을 통해 변수로 쉽게 추출할 수 있었다.\n\n아직 툴 사용이 미숙해 많은 기능을 활용하지는 못한것 같아 아쉽다\n\n### Git, Github\n\n프로젝트의 버전관리를 위해 Git을 이용했다. Git flow 전략을 모방해 메인을 제외한 develop, subdev, release 3개의 branch를 만들었다.\n\n기본적으로 모든 변경사항을 subdev에 push하였고, merge가 잘 완료되면 log를 추가해 develop으로 옮겼다. 최종적으로 public 폴더만 build해 release에 저장했다.\n\n### npm\n\n개발환경 세팅과 최종적인 프로젝트 파일의 최적화를 위해 npm을 이용했다.\n\nrimraf, npm-run-all, live-server, sass는 개발환경 세팅을 위해 webpack, postcss는 최적화를 위해 사용해 보았다.\n\n### HTML\n\nHTML의 경우 시맨틱 마크업을 제일 중요시 여겼는데 먼저 손으로 페이지의 구조를 설계 한 후 코드로 작성했다. 그 후 코드리뷰를 시간을 가져 팀원들끼리 왜 그렇게 코드를 작성했는지, 구조가 논리적인지 설득하는 시간을 가졌다.\n\n### CSS, Sass\n\nCSS를 효과적으로 사용하기 위해 Sass를 이용했고 이 때 가장 중요시 여긴점은 컨벤션이였다. 기본적으로 BEM 방식을 이용한 Naming과 최대한 구체적인 클래스명을 사용하기로 정했다.\n\n<hr>\n\n## KPT\n\n### Keep\n\n- 프로젝트를 시작하기 전 환경설정을 중요시 여기고 이 부분에 대해 많이 논의 했는데 그 결과 git 충돌도 거의 없었고 일어난 충돌도 금방 해결 할 수 있었다.\n\n- 1차적인 프로젝트 결과물을 가지고 lighthouse 검사를 통해 부족한 부분을 찾고 개선하기 위해 노력했다. 실질적인 성능 향상을 볼 수 있어서 좋았다.\n\n- 의견충돌이 있을때 그냥 넘어가지 않고 서로를 설득하기 위해 노력했는데 생각에 대한 근거를 찾고 정리해보며 의견을 구체화 시킬 수 있었다.\n\n### Problem\n\n- Sass 사용의 아쉬움 - Sass 를 사용하기 위해 폴더 구조를 잘 분리한것은 좋았으나 중첩규칙, 변수 이외에는 잘 사용하지 못했다. 특히 중복적으로 사용되는 코드들을 믹스인으로 분리했어야 했는데 그러지 못했다.\n\n\n- 미숙했던 초반 소통\n\n\n### Try\n\n- 문서화의 중요성 - 서로 상의해 결정했던 부분들이나 컴포넌트에 대한 문서들을 남겨 서로 참고할 수 있도록 하자고 말했었지만 실제 프로젝트를 진행하면서 잘 수행되지 못했다. 문서화가 잘 되어 있는 다른 프로젝트 조의 경우 전체적인 프로젝트 상황에 대한 파악이 수월해 보였다. 다음 프로젝트를 진행할 때에는 꼭 문서화에 신경써봐야겠다.\n\n<hr>\n\n# 마치며\n\n첫 프로젝트를 진행하며 많은 것을 배울 수 있어 정말 좋았다. 하지만 역시 머리에 계속해서 남는것은 아쉬운 점들인 것 같다.\n\n평소 배달의 민족을 많이 사용하면서 이런 기능이 있으면 좋겠다고 생각해 오던것이 있다. 나는 결정장애가 심한 편이라 어떤것을 먹을지, 또 메뉴를 정해도 어디서 시킬지 정말 많이 고민한다. 그래서 카테고리만 선택하면 룰렛이 돌아가듯이 랜덤으로 가게와 메뉴가 선택되면 좋겠다고 생각했다.\n\n마침 배달의 민족을 웹으로 구현하기로 결정해서 이 기능도 추가해 보려고 했는데 막상 스스로의 자바스크립트 실력도 너무 부족하고 어떤 데이터베이스를 기반으로 정보를 가져와야 할지 아이디어 역시도 너무 구체적이지 않아 쉽지 않았다.\n\n스스로 많이 부족하다고 느끼는 점이 가장 아쉬웠다.\n다만 앞으로 3개월 동안 커넥to 과정을 통해 모던 자바스크립트 Deep Dive의 저자이신 이웅모 강사님에게 자바스크립트 강의를 듣게 되었는데, 정말 좋은 기회이니 만큼 열심히 배우고 또 평상시 가지고 있던 아이디어들에 대해서도 구체화해 프로젝트를 리팩토링해봐야 겠다.\n\n\n\n\n\n\n","source":"_posts/Retrospective-about-my-first-project.md","raw":"---\ntitle: 첫 프로젝트를 마치고\ndate: 2022-10-04 19:55:18\ntags:\n- 개발\n- 회고\n---\n# 들어가며\n약 2주동안 진행했던 프로젝트가 종료되었다. 개발 공부를 시작한지도 얼마 안 되었고 처음으로 해본 프로젝트인지라 2주가 정말 정신없이 지나가버렸다. 배운점도 많았고 아쉬운점도 많았는데 회고를 하며 정리해보려고 한다.\n\n완성된 결과물은 https://woowahal-6go5.vercel.app/ 에서 확인 가능하다.\n\n<hr>\n\n# 프로젝트 우아할\n\n이전글에서 언급했듯이 우리 팀은 배달의 민족 앱을 웹 페이지로 클론하기로 했다(그래서 팀명도 **우아할**형제들로 정했다).\n\n개발 기간은 2022-09-19 ~ 2022-09-30로 약 2주 동안 진행되었고, 팀원은 나를 포함해 총 3명이었다.\n\n프로젝트 기간이나 인원에 비해 배달의 민족이 가지고 있는 콘텐츠가 너무 많아 모든 페이지를 클론 할 수는 없었고 배달의 민족에서 배달하기 까지의 주요 프로세스를 메인,카테고리, 리스트, 디테일, 오더, 장바구니, 결과의 7개 페이지로 나누어 구현해 보았다.\n\n나는 그 중 메인페이지와 카테고리 페이지를 주로 담당했다.\n\n<hr>\n\n## 기술 스택\n\n페이지를 구현하면서 Figma, Git, npm, HTML, CSS, Sass, JS, Vercel을 이용했다.\n\n### Figma\n\n구현해야 하는 페이지들의 와이어프레임 및 컴포넌트들을 시각적으로 구성해보기 위해 Figma를 이용했다.\n\n페이지에서 주사용되는 컬러를 시스템화해서 플러그인을 통해 변수로 쉽게 추출할 수 있었다.\n\n아직 툴 사용이 미숙해 많은 기능을 활용하지는 못한것 같아 아쉽다\n\n### Git, Github\n\n프로젝트의 버전관리를 위해 Git을 이용했다. Git flow 전략을 모방해 메인을 제외한 develop, subdev, release 3개의 branch를 만들었다.\n\n기본적으로 모든 변경사항을 subdev에 push하였고, merge가 잘 완료되면 log를 추가해 develop으로 옮겼다. 최종적으로 public 폴더만 build해 release에 저장했다.\n\n### npm\n\n개발환경 세팅과 최종적인 프로젝트 파일의 최적화를 위해 npm을 이용했다.\n\nrimraf, npm-run-all, live-server, sass는 개발환경 세팅을 위해 webpack, postcss는 최적화를 위해 사용해 보았다.\n\n### HTML\n\nHTML의 경우 시맨틱 마크업을 제일 중요시 여겼는데 먼저 손으로 페이지의 구조를 설계 한 후 코드로 작성했다. 그 후 코드리뷰를 시간을 가져 팀원들끼리 왜 그렇게 코드를 작성했는지, 구조가 논리적인지 설득하는 시간을 가졌다.\n\n### CSS, Sass\n\nCSS를 효과적으로 사용하기 위해 Sass를 이용했고 이 때 가장 중요시 여긴점은 컨벤션이였다. 기본적으로 BEM 방식을 이용한 Naming과 최대한 구체적인 클래스명을 사용하기로 정했다.\n\n<hr>\n\n## KPT\n\n### Keep\n\n- 프로젝트를 시작하기 전 환경설정을 중요시 여기고 이 부분에 대해 많이 논의 했는데 그 결과 git 충돌도 거의 없었고 일어난 충돌도 금방 해결 할 수 있었다.\n\n- 1차적인 프로젝트 결과물을 가지고 lighthouse 검사를 통해 부족한 부분을 찾고 개선하기 위해 노력했다. 실질적인 성능 향상을 볼 수 있어서 좋았다.\n\n- 의견충돌이 있을때 그냥 넘어가지 않고 서로를 설득하기 위해 노력했는데 생각에 대한 근거를 찾고 정리해보며 의견을 구체화 시킬 수 있었다.\n\n### Problem\n\n- Sass 사용의 아쉬움 - Sass 를 사용하기 위해 폴더 구조를 잘 분리한것은 좋았으나 중첩규칙, 변수 이외에는 잘 사용하지 못했다. 특히 중복적으로 사용되는 코드들을 믹스인으로 분리했어야 했는데 그러지 못했다.\n\n\n- 미숙했던 초반 소통\n\n\n### Try\n\n- 문서화의 중요성 - 서로 상의해 결정했던 부분들이나 컴포넌트에 대한 문서들을 남겨 서로 참고할 수 있도록 하자고 말했었지만 실제 프로젝트를 진행하면서 잘 수행되지 못했다. 문서화가 잘 되어 있는 다른 프로젝트 조의 경우 전체적인 프로젝트 상황에 대한 파악이 수월해 보였다. 다음 프로젝트를 진행할 때에는 꼭 문서화에 신경써봐야겠다.\n\n<hr>\n\n# 마치며\n\n첫 프로젝트를 진행하며 많은 것을 배울 수 있어 정말 좋았다. 하지만 역시 머리에 계속해서 남는것은 아쉬운 점들인 것 같다.\n\n평소 배달의 민족을 많이 사용하면서 이런 기능이 있으면 좋겠다고 생각해 오던것이 있다. 나는 결정장애가 심한 편이라 어떤것을 먹을지, 또 메뉴를 정해도 어디서 시킬지 정말 많이 고민한다. 그래서 카테고리만 선택하면 룰렛이 돌아가듯이 랜덤으로 가게와 메뉴가 선택되면 좋겠다고 생각했다.\n\n마침 배달의 민족을 웹으로 구현하기로 결정해서 이 기능도 추가해 보려고 했는데 막상 스스로의 자바스크립트 실력도 너무 부족하고 어떤 데이터베이스를 기반으로 정보를 가져와야 할지 아이디어 역시도 너무 구체적이지 않아 쉽지 않았다.\n\n스스로 많이 부족하다고 느끼는 점이 가장 아쉬웠다.\n다만 앞으로 3개월 동안 커넥to 과정을 통해 모던 자바스크립트 Deep Dive의 저자이신 이웅모 강사님에게 자바스크립트 강의를 듣게 되었는데, 정말 좋은 기회이니 만큼 열심히 배우고 또 평상시 가지고 있던 아이디어들에 대해서도 구체화해 프로젝트를 리팩토링해봐야 겠다.\n\n\n\n\n\n\n","slug":"Retrospective-about-my-first-project","published":1,"updated":"2022-10-12T10:57:07.253Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb08iq6i000le4vkhcp07ywi","content":"<h1 id=\"들어가며\"><a href=\"#들어가며\" class=\"headerlink\" title=\"들어가며\"></a>들어가며</h1><p>약 2주동안 진행했던 프로젝트가 종료되었다. 개발 공부를 시작한지도 얼마 안 되었고 처음으로 해본 프로젝트인지라 2주가 정말 정신없이 지나가버렸다. 배운점도 많았고 아쉬운점도 많았는데 회고를 하며 정리해보려고 한다.</p>\n<p>완성된 결과물은 <a href=\"https://woowahal-6go5.vercel.app/\">https://woowahal-6go5.vercel.app/</a> 에서 확인 가능하다.</p>\n<hr>\n\n<h1 id=\"프로젝트-우아할\"><a href=\"#프로젝트-우아할\" class=\"headerlink\" title=\"프로젝트 우아할\"></a>프로젝트 우아할</h1><p>이전글에서 언급했듯이 우리 팀은 배달의 민족 앱을 웹 페이지로 클론하기로 했다(그래서 팀명도 <strong>우아할</strong>형제들로 정했다).</p>\n<p>개발 기간은 2022-09-19 ~ 2022-09-30로 약 2주 동안 진행되었고, 팀원은 나를 포함해 총 3명이었다.</p>\n<p>프로젝트 기간이나 인원에 비해 배달의 민족이 가지고 있는 콘텐츠가 너무 많아 모든 페이지를 클론 할 수는 없었고 배달의 민족에서 배달하기 까지의 주요 프로세스를 메인,카테고리, 리스트, 디테일, 오더, 장바구니, 결과의 7개 페이지로 나누어 구현해 보았다.</p>\n<p>나는 그 중 메인페이지와 카테고리 페이지를 주로 담당했다.</p>\n<hr>\n\n<h2 id=\"기술-스택\"><a href=\"#기술-스택\" class=\"headerlink\" title=\"기술 스택\"></a>기술 스택</h2><p>페이지를 구현하면서 Figma, Git, npm, HTML, CSS, Sass, JS, Vercel을 이용했다.</p>\n<h3 id=\"Figma\"><a href=\"#Figma\" class=\"headerlink\" title=\"Figma\"></a>Figma</h3><p>구현해야 하는 페이지들의 와이어프레임 및 컴포넌트들을 시각적으로 구성해보기 위해 Figma를 이용했다.</p>\n<p>페이지에서 주사용되는 컬러를 시스템화해서 플러그인을 통해 변수로 쉽게 추출할 수 있었다.</p>\n<p>아직 툴 사용이 미숙해 많은 기능을 활용하지는 못한것 같아 아쉽다</p>\n<h3 id=\"Git-Github\"><a href=\"#Git-Github\" class=\"headerlink\" title=\"Git, Github\"></a>Git, Github</h3><p>프로젝트의 버전관리를 위해 Git을 이용했다. Git flow 전략을 모방해 메인을 제외한 develop, subdev, release 3개의 branch를 만들었다.</p>\n<p>기본적으로 모든 변경사항을 subdev에 push하였고, merge가 잘 완료되면 log를 추가해 develop으로 옮겼다. 최종적으로 public 폴더만 build해 release에 저장했다.</p>\n<h3 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\"npm\"></a>npm</h3><p>개발환경 세팅과 최종적인 프로젝트 파일의 최적화를 위해 npm을 이용했다.</p>\n<p>rimraf, npm-run-all, live-server, sass는 개발환경 세팅을 위해 webpack, postcss는 최적화를 위해 사용해 보았다.</p>\n<h3 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h3><p>HTML의 경우 시맨틱 마크업을 제일 중요시 여겼는데 먼저 손으로 페이지의 구조를 설계 한 후 코드로 작성했다. 그 후 코드리뷰를 시간을 가져 팀원들끼리 왜 그렇게 코드를 작성했는지, 구조가 논리적인지 설득하는 시간을 가졌다.</p>\n<h3 id=\"CSS-Sass\"><a href=\"#CSS-Sass\" class=\"headerlink\" title=\"CSS, Sass\"></a>CSS, Sass</h3><p>CSS를 효과적으로 사용하기 위해 Sass를 이용했고 이 때 가장 중요시 여긴점은 컨벤션이였다. 기본적으로 BEM 방식을 이용한 Naming과 최대한 구체적인 클래스명을 사용하기로 정했다.</p>\n<hr>\n\n<h2 id=\"KPT\"><a href=\"#KPT\" class=\"headerlink\" title=\"KPT\"></a>KPT</h2><h3 id=\"Keep\"><a href=\"#Keep\" class=\"headerlink\" title=\"Keep\"></a>Keep</h3><ul>\n<li><p>프로젝트를 시작하기 전 환경설정을 중요시 여기고 이 부분에 대해 많이 논의 했는데 그 결과 git 충돌도 거의 없었고 일어난 충돌도 금방 해결 할 수 있었다.</p>\n</li>\n<li><p>1차적인 프로젝트 결과물을 가지고 lighthouse 검사를 통해 부족한 부분을 찾고 개선하기 위해 노력했다. 실질적인 성능 향상을 볼 수 있어서 좋았다.</p>\n</li>\n<li><p>의견충돌이 있을때 그냥 넘어가지 않고 서로를 설득하기 위해 노력했는데 생각에 대한 근거를 찾고 정리해보며 의견을 구체화 시킬 수 있었다.</p>\n</li>\n</ul>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a>Problem</h3><ul>\n<li><p>Sass 사용의 아쉬움 - Sass 를 사용하기 위해 폴더 구조를 잘 분리한것은 좋았으나 중첩규칙, 변수 이외에는 잘 사용하지 못했다. 특히 중복적으로 사용되는 코드들을 믹스인으로 분리했어야 했는데 그러지 못했다.</p>\n</li>\n<li><p>미숙했던 초반 소통</p>\n</li>\n</ul>\n<h3 id=\"Try\"><a href=\"#Try\" class=\"headerlink\" title=\"Try\"></a>Try</h3><ul>\n<li>문서화의 중요성 - 서로 상의해 결정했던 부분들이나 컴포넌트에 대한 문서들을 남겨 서로 참고할 수 있도록 하자고 말했었지만 실제 프로젝트를 진행하면서 잘 수행되지 못했다. 문서화가 잘 되어 있는 다른 프로젝트 조의 경우 전체적인 프로젝트 상황에 대한 파악이 수월해 보였다. 다음 프로젝트를 진행할 때에는 꼭 문서화에 신경써봐야겠다.</li>\n</ul>\n<hr>\n\n<h1 id=\"마치며\"><a href=\"#마치며\" class=\"headerlink\" title=\"마치며\"></a>마치며</h1><p>첫 프로젝트를 진행하며 많은 것을 배울 수 있어 정말 좋았다. 하지만 역시 머리에 계속해서 남는것은 아쉬운 점들인 것 같다.</p>\n<p>평소 배달의 민족을 많이 사용하면서 이런 기능이 있으면 좋겠다고 생각해 오던것이 있다. 나는 결정장애가 심한 편이라 어떤것을 먹을지, 또 메뉴를 정해도 어디서 시킬지 정말 많이 고민한다. 그래서 카테고리만 선택하면 룰렛이 돌아가듯이 랜덤으로 가게와 메뉴가 선택되면 좋겠다고 생각했다.</p>\n<p>마침 배달의 민족을 웹으로 구현하기로 결정해서 이 기능도 추가해 보려고 했는데 막상 스스로의 자바스크립트 실력도 너무 부족하고 어떤 데이터베이스를 기반으로 정보를 가져와야 할지 아이디어 역시도 너무 구체적이지 않아 쉽지 않았다.</p>\n<p>스스로 많이 부족하다고 느끼는 점이 가장 아쉬웠다.<br>다만 앞으로 3개월 동안 커넥to 과정을 통해 모던 자바스크립트 Deep Dive의 저자이신 이웅모 강사님에게 자바스크립트 강의를 듣게 되었는데, 정말 좋은 기회이니 만큼 열심히 배우고 또 평상시 가지고 있던 아이디어들에 대해서도 구체화해 프로젝트를 리팩토링해봐야 겠다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"들어가며\"><a href=\"#들어가며\" class=\"headerlink\" title=\"들어가며\"></a>들어가며</h1><p>약 2주동안 진행했던 프로젝트가 종료되었다. 개발 공부를 시작한지도 얼마 안 되었고 처음으로 해본 프로젝트인지라 2주가 정말 정신없이 지나가버렸다. 배운점도 많았고 아쉬운점도 많았는데 회고를 하며 정리해보려고 한다.</p>\n<p>완성된 결과물은 <a href=\"https://woowahal-6go5.vercel.app/\">https://woowahal-6go5.vercel.app/</a> 에서 확인 가능하다.</p>\n<hr>\n\n<h1 id=\"프로젝트-우아할\"><a href=\"#프로젝트-우아할\" class=\"headerlink\" title=\"프로젝트 우아할\"></a>프로젝트 우아할</h1><p>이전글에서 언급했듯이 우리 팀은 배달의 민족 앱을 웹 페이지로 클론하기로 했다(그래서 팀명도 <strong>우아할</strong>형제들로 정했다).</p>\n<p>개발 기간은 2022-09-19 ~ 2022-09-30로 약 2주 동안 진행되었고, 팀원은 나를 포함해 총 3명이었다.</p>\n<p>프로젝트 기간이나 인원에 비해 배달의 민족이 가지고 있는 콘텐츠가 너무 많아 모든 페이지를 클론 할 수는 없었고 배달의 민족에서 배달하기 까지의 주요 프로세스를 메인,카테고리, 리스트, 디테일, 오더, 장바구니, 결과의 7개 페이지로 나누어 구현해 보았다.</p>\n<p>나는 그 중 메인페이지와 카테고리 페이지를 주로 담당했다.</p>\n<hr>\n\n<h2 id=\"기술-스택\"><a href=\"#기술-스택\" class=\"headerlink\" title=\"기술 스택\"></a>기술 스택</h2><p>페이지를 구현하면서 Figma, Git, npm, HTML, CSS, Sass, JS, Vercel을 이용했다.</p>\n<h3 id=\"Figma\"><a href=\"#Figma\" class=\"headerlink\" title=\"Figma\"></a>Figma</h3><p>구현해야 하는 페이지들의 와이어프레임 및 컴포넌트들을 시각적으로 구성해보기 위해 Figma를 이용했다.</p>\n<p>페이지에서 주사용되는 컬러를 시스템화해서 플러그인을 통해 변수로 쉽게 추출할 수 있었다.</p>\n<p>아직 툴 사용이 미숙해 많은 기능을 활용하지는 못한것 같아 아쉽다</p>\n<h3 id=\"Git-Github\"><a href=\"#Git-Github\" class=\"headerlink\" title=\"Git, Github\"></a>Git, Github</h3><p>프로젝트의 버전관리를 위해 Git을 이용했다. Git flow 전략을 모방해 메인을 제외한 develop, subdev, release 3개의 branch를 만들었다.</p>\n<p>기본적으로 모든 변경사항을 subdev에 push하였고, merge가 잘 완료되면 log를 추가해 develop으로 옮겼다. 최종적으로 public 폴더만 build해 release에 저장했다.</p>\n<h3 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\"npm\"></a>npm</h3><p>개발환경 세팅과 최종적인 프로젝트 파일의 최적화를 위해 npm을 이용했다.</p>\n<p>rimraf, npm-run-all, live-server, sass는 개발환경 세팅을 위해 webpack, postcss는 최적화를 위해 사용해 보았다.</p>\n<h3 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h3><p>HTML의 경우 시맨틱 마크업을 제일 중요시 여겼는데 먼저 손으로 페이지의 구조를 설계 한 후 코드로 작성했다. 그 후 코드리뷰를 시간을 가져 팀원들끼리 왜 그렇게 코드를 작성했는지, 구조가 논리적인지 설득하는 시간을 가졌다.</p>\n<h3 id=\"CSS-Sass\"><a href=\"#CSS-Sass\" class=\"headerlink\" title=\"CSS, Sass\"></a>CSS, Sass</h3><p>CSS를 효과적으로 사용하기 위해 Sass를 이용했고 이 때 가장 중요시 여긴점은 컨벤션이였다. 기본적으로 BEM 방식을 이용한 Naming과 최대한 구체적인 클래스명을 사용하기로 정했다.</p>\n<hr>\n\n<h2 id=\"KPT\"><a href=\"#KPT\" class=\"headerlink\" title=\"KPT\"></a>KPT</h2><h3 id=\"Keep\"><a href=\"#Keep\" class=\"headerlink\" title=\"Keep\"></a>Keep</h3><ul>\n<li><p>프로젝트를 시작하기 전 환경설정을 중요시 여기고 이 부분에 대해 많이 논의 했는데 그 결과 git 충돌도 거의 없었고 일어난 충돌도 금방 해결 할 수 있었다.</p>\n</li>\n<li><p>1차적인 프로젝트 결과물을 가지고 lighthouse 검사를 통해 부족한 부분을 찾고 개선하기 위해 노력했다. 실질적인 성능 향상을 볼 수 있어서 좋았다.</p>\n</li>\n<li><p>의견충돌이 있을때 그냥 넘어가지 않고 서로를 설득하기 위해 노력했는데 생각에 대한 근거를 찾고 정리해보며 의견을 구체화 시킬 수 있었다.</p>\n</li>\n</ul>\n<h3 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a>Problem</h3><ul>\n<li><p>Sass 사용의 아쉬움 - Sass 를 사용하기 위해 폴더 구조를 잘 분리한것은 좋았으나 중첩규칙, 변수 이외에는 잘 사용하지 못했다. 특히 중복적으로 사용되는 코드들을 믹스인으로 분리했어야 했는데 그러지 못했다.</p>\n</li>\n<li><p>미숙했던 초반 소통</p>\n</li>\n</ul>\n<h3 id=\"Try\"><a href=\"#Try\" class=\"headerlink\" title=\"Try\"></a>Try</h3><ul>\n<li>문서화의 중요성 - 서로 상의해 결정했던 부분들이나 컴포넌트에 대한 문서들을 남겨 서로 참고할 수 있도록 하자고 말했었지만 실제 프로젝트를 진행하면서 잘 수행되지 못했다. 문서화가 잘 되어 있는 다른 프로젝트 조의 경우 전체적인 프로젝트 상황에 대한 파악이 수월해 보였다. 다음 프로젝트를 진행할 때에는 꼭 문서화에 신경써봐야겠다.</li>\n</ul>\n<hr>\n\n<h1 id=\"마치며\"><a href=\"#마치며\" class=\"headerlink\" title=\"마치며\"></a>마치며</h1><p>첫 프로젝트를 진행하며 많은 것을 배울 수 있어 정말 좋았다. 하지만 역시 머리에 계속해서 남는것은 아쉬운 점들인 것 같다.</p>\n<p>평소 배달의 민족을 많이 사용하면서 이런 기능이 있으면 좋겠다고 생각해 오던것이 있다. 나는 결정장애가 심한 편이라 어떤것을 먹을지, 또 메뉴를 정해도 어디서 시킬지 정말 많이 고민한다. 그래서 카테고리만 선택하면 룰렛이 돌아가듯이 랜덤으로 가게와 메뉴가 선택되면 좋겠다고 생각했다.</p>\n<p>마침 배달의 민족을 웹으로 구현하기로 결정해서 이 기능도 추가해 보려고 했는데 막상 스스로의 자바스크립트 실력도 너무 부족하고 어떤 데이터베이스를 기반으로 정보를 가져와야 할지 아이디어 역시도 너무 구체적이지 않아 쉽지 않았다.</p>\n<p>스스로 많이 부족하다고 느끼는 점이 가장 아쉬웠다.<br>다만 앞으로 3개월 동안 커넥to 과정을 통해 모던 자바스크립트 Deep Dive의 저자이신 이웅모 강사님에게 자바스크립트 강의를 듣게 되었는데, 정말 좋은 기회이니 만큼 열심히 배우고 또 평상시 가지고 있던 아이디어들에 대해서도 구체화해 프로젝트를 리팩토링해봐야 겠다.</p>\n"},{"title":"[Deep Dive] 타입 변환과 단축 평가","date":"2022-10-21T11:19:55.000Z","_content":"# 타입 변환이란?\n\n앞서 자바스크립트의 모든 값은 타입이 있음을 알아보았다.\n값의 타입은 개발자의 의도에 따라 다른 타입으로 변환할 수 있는데 이를 명시적 타입 변환 또는 타입 캐스팅이라 한다.\n\n```javascript\nvar x = 10;\n\n// 명시적 타입 변환, 숫자 -> 문자열\nvar str = x.toString();\nconsole.log(typeof str, str); // string 10\n\n// x 변수의 값이 변경된 것은 아님\nconsole.log(typeof x, x); // number 10\n```\n\n개발자의 의도와는 상관없이 표현식을 평가하는 도중 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다.\n이를 암묵적 타입 변환 또는 타입 강제 변환이라 한다.\n\n```javascript\nvar x = 10;\n\n// 암묵적 타입 변환, 숫자 -> 문자열\nvar str = x + '';\nconsole.log(typeof str, str); // string 10\n\n// x 변수의 값이 변경된 것은 아님\nconsole.log(typeof x, x); // number 10\n```\n\n예시에서 볼 수 있듯이 명시적 타입 변환이나 암묵적 타입 변환이 기존 원시 값을 직접 변경하는 것은 아니다.\n원시 값은 변경 불가능한 값으로 변경할 수 없다. 타입 변환이란 기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것이다.\n\n명시적 타입 변환은 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 드러난다.\n하지만 암묵적 타입 강제 변환은 자바스크립트 엔진에 의해 암묵적으로, 즉 드러나지 않게 타입이 자동 변환되기 때문에 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 나타나지 않는다.\n\n따라서 자신이 작성한 코드에서 암묵적 타입 변환이 발생하는지, 발생한다면 어떤 타입의 어떤 값으로 변환되는지 예측 가능해야 한다.\n만약 타입 변환 결과를 예측하지 못하거나 예측이 결과와 일치하지 않는다면 오류를 생산할 가능성이 높아진다.\n타입 변환이 어떻게 동작하는지 정확히 이해하고 사용하자.\n\n## 암묵적 타입 변환\n\n표현식을 평가할 때 코드의 문맥메 부합하지 않는 다양한 상황이 발생할 수 있다. 이때 프로그래밍 언어에 따라 에러를 발생시키기도 하지만 자바스크립트는 가급적 에러를 발생시키지 않도록 암묵적 타입 변환을 통해 표현식을 펴가한다.\n\n암묵적 타입 변환이 발생하면 문자열, 숫자, 불리언과 같은 원시 타입 중 하나로 타입을 자동 변환한다.\n타입 별로 암묵적 타입 변환이 어떻게 발생하는지 살펴보자.\n\n### 문자열 타입으로 변환\n\n```javascript\n1 + '2'; // '12'\n```\n\n위 코드의 + 연산잔느 피연산자 중 하나 이상이 문자열이므로 문자열 연결 연산자로 동작한다.\n문자열 연결 연산자의 역할은 문자열 값을 만드는 것이다. 따라서 문자열 연결 연산자의 모든 피연산자는 코드의 문맥상 모두 문자열 타입이어야 한다.\n\n자바스크립트 엔진은 문자열 연결 연산자 표현식을 평가하기 위해 문자열 연결 연산자의 피연산자 중에서 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적 타입 변환한다.\n\n자바스크립트 엔진은 문자열 타입이 아닌 값을 문자열 타입으로 암묵적 타입 변환을 수행할 때 다음과 같이 동작한다.\n\n```javascript\n// 숫자 타입\n0 + '' // '0'\n-0 + '' // '0'\n1 + '' // '1'\n-1 + '' // '-1'\nNaN + '' // 'NaN'\n\n// 불리언 타입\ntrue + '' // 'true'\nfalse + '' // 'false'\n\n// null 타입\nnull + '' // 'null'\n\n// undefined 타입\nundefined + '' // 'undefined'\n\n// 심벌 타입\n(Symbol()) + '' // TypeError: Cannot convert a Symbol value to a string\n\n// 객체 타입\n({}) + '' // '[object Object]'\nMath + '' // '[object Math]'\n[] + '' // ''\n[10, 20] + '' // '10,20'\n(function(){}) + '' // 'function(){}'\nArray + '' // 'function Array() { [native code] }'\n```\n\n### 숫자 타입으로 변환\n\n```javascript\n1 - '1'; // 0\n1 * '10'; // 10\n1 / 'one'; // NaN\n```\n\n위 코드에서 사용한 연산자는 모두 산술 연산자이다.\n산술 연산자의 역할은 숫자 값을 만드는 것이므로 산술 연산자의 모든 피연산자는 코드 문맥상 모두 숫자 타입이어야 한다.\n\n자바스크립트 엔진은 산술 연산자 표현식을 평가하기 위해 산술 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다. 이때 피연산자를 숫자 타입으로 변환할 수 없는 경우는 산술 연산을 수행할 수 없으므로 표현식의 평가 결과는 NaN이 된다.\n\n```javascript\n'1' > 0; // true\n```\n\n비교 연산자의 역할은 불리언 값을 만드는 것이다. > 비교 연산자는 피연산자의 크기를 비교하므로 모든 피연산자는 코드 문맥상 모두 숫자 타입이어야 한다.\n자바스크립트 엔진은 비교 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다.\n\n자바스크립트 엔진은 숫자 타입이 아닌 값을 숫자 타입으로 암묵적 타입 변환을 수행할 때 다음과 같이 동작한다.\n\n```javascript\n// 문자열 타입\n+'' + // 0\n  '0' + // 0\n  '1' + // 1\n  'string' + // NaN\n  // 불리언 타입\n  true + // 1\n  false + // 0\n  // null 타입\n  null / 0 +\n  // undefined 타입\n  undefined + // NaN\n  // 심벌 타입\n  Symbol() + // TypeError: Cannot convert a Symbol value to a number\n  // 객체 타입\n  {} + // NaN\n  [] + // 0\n  [10, 20] + // NaN\n  function () {}; // NaN\n```\n\n빈 문자열(''), 빈 배열([]), null, false는 0으로 true는 1로 변환된다.\n객체와 빈 배열이 아닌 배열, undefined는 변환되지 않아 NaN이 되는 것에 주의하자.\n\n### 불리언 타입으로 변환\n\n```javascript\nif ('') console.log(x);\n```\n\nif 문이나 for 문과 같은 제어문 또는 삼항 조건 연산자의 조건식은 불리언 값, 즉 논리적 참과 거짓으로 평가되어야 한느 표현식이다.\n자바스크립트 엔진은 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환한다.\n\n이때 자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분한다.\n\nfalse로 평가되는 Falsy 값은 다음과 같다.\n\n- false\n- undefined\n- null\n- 0, -0\n- NaN\n- ''(빈 문자열)\n\nFalsy 값 외의 모든 값은 모두 true로 평가되는 Truthy 값이다.\n\n## 명시적 타입 변환\n\n개발자의 의도에 따라 명시적으로 타입을 변경하는 방법은 다양하다.\n표준 빌트인 생성자 함수(String, Number, Boolean)을 new 연산자 없이 호출하는 방법과 빌트인 메서드를 사용하는 방법, 그리고 앞서 살펴본 암묵적 타입 변환을 이용하는 방법이 있다.\n\n### 문자열 타입으로 변환\n\n문자열 타입이 아닌 값을 문자열 타입으로 변환하는 방법은 다음과 같다.\n\n- String 생성자 함수를 new 연산자 없이 호출\n- Object.prototype.toString 메서드를 사용\n- 문자열 연결 연산자를 이용\n\n```javascript\nString(1); // '1'\nString(NaN); // 'NaN'\nString(true); // 'true'\n\n(1).toString(); // '1'\nNaN.toString(); // 'NaN'\ntrue.toString(); // 'true'\n\n1 + ''; // '1'\nNaN + ''; // 'NaN'\ntrue + ''; // 'true'\n```\n\n### 숫자 타입으로 변환\n\n숫자 타입이 아닌 값을 숫자 타입으로 변환하는 방법은 다음과 같다.\n\n- Number 생성자 함수를 new 연산자 없이 호출\n- parseInt, parseFloat 함수를 사용(문자열만 숫자 타입으로 변환 가능)\n- \\+ 단항 산술 연산자를 이용\n- \\* 산술 연산자를 이용\n\n```javascript\nNumber('0'); // 0\nNumber('10.53'); // 10.53\nNumber(true); // 1\n\nparseInt('0'); // 0\nparseFloat('10.53'); // 10.53\n\n+'0'; // 0\n+'10.53'; // 10.53\ntrue; // 1\n\n'0' * 1; // 0\n'10.53' * 1; // 10.53\ntrue * 1; // 1\n```\n\n### 불리언 타입으로 변환\n\n불리언 타입이 아닌 값을 불리언 타입으로 변환하는 방법은 다음과 같다.\n\n- Boolean 생성자 함수를 new 연산자 없이 호출\n- 부정 논리 연산자(!)를 두전 사용\n\n```javascript\nBoolean('x'); // true\nBoolean(''); // false\nBoolean({}); // true\n\n!!'x'; // true\n!!''; // false\n!!{}; // true\n```\n\n## 단축 평가\n\n이전에 연산자를 공부하면서 논리합(||) 연산자와 논리곱(&&) 연산자에 대해 살펴 본 적이 있다.\n논리합(||) 또는 논리곱(&&) 연산자 표현식은 언제나 2개의 피연산자 중 한쪽으로 평가되는데 이를 설명하기 위해서는 암묵적 타입 변환을 알아야 한다.\n앞서 암묵적 타입 변환에 대해 살펴보았으니 이에 대해 알아보자.\n\n```javascript\n'Cat' && 'Dog'; // 'Dog'\n```\n\n논리곱(&&) 연산자는 두 개의 피연산자가 모두 true로 평가될 때 true를 반환한다. 논리곱 연산자는 좌항에서 우항으로 평가가 진행된다.\n\n첫 번째 피연산자 'Cat'은 Truthy 값이므로 true로 평가된다. 하지만 이 시점까지는 위 표현식을 평가할 수 없다.\n두 번째 피연산자까지 평가해 보아야 위 표현식을 평가할 수 있다. 즉 두 번째 피연산자가 논리곱 연산자 표현식의 평가 결과를 결정한다.\n이때 논리곱 연산자는 논리 연산의 결과를 결정하는 두 번째 피연산자 문자열 'Dog'를 타입 변환 없이 그대로 반환한다.\n\n논리합(||) 연산자도 논리곱(&&) 연산자와 동일하게 동작한다.\n\n논리곱(&&) 연산자와 논리합(||) 연산자는 이처럼 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환한다.\n이를 단축평가라 한다. 단축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말한다.\n\n단축 평가를 사용하면 if 문을 대체할 수 있다. 어떤 조건이 Truthy 값일 때 무언가를 해야 한다면 논리곱(&&) 연산자를, 어떤 조건이 Falsy 값일 때 무언가를 해야 한다면 논리합(||) 연산자를 이용할 수 있다.\n\n```javascript\nvar done = true;\nvar message = '';\n\nif (done) message = '완료';\nmessage = done && '완료';\nconsole.log(message); // 완료\n```\n\n```javascript\nvar done = false;\nvar message = '';\n\nif (done) message = '미완료';\nmessage = done || '미완료';\nconsole.log(message); // 미완료\n```\n\n### 옵셔널 체이닝 연산자\n\nES11에서 도입된 옵셔널 체이닝 연산자 ?.는 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.\n\n```javascript\nvar elem = null;\n\nvar value = elem?.value;\nconsole.log(value); // undefined\n```\n\n옵셔널 체이닝 연산자는 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때 유용하다.\n옵셔널 체이닝 연산자가 도입되기 이전에는 논리곱 연산자를 사용한 단축 평가를 통해 변수가 null 또는 undefined인지 확인했다.\n\n논리곱 연산자는 좌항의 피연산자가 Falsy 값이면 좌항 피연산자를 그대로 반환한다. 좌항 피연산자가 Falsy 값인 0이나 ''인 경우도 마찬가지다.\n하지만 0이나 ''은 객체로 평가될 때도 있다. 옵셔널 체이닝 연산자는 좌항 피연산자가 Falsy 값이라도 null 또는 undefined가 아니면 우항의 프로퍼티 참조를 이어간다는 차이점이 있다.\n\n```javascript\nvar str = '';\n\nvar length1 = str && str.length;\nvar length2 = str?.length;\n\nconsole.log(length1); // ''\nconsole.log(length2); // 0\n```\n\n### null 병합 연산자\n\nES11에서 도입된 null 병합 연산자 ??는 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다.\n\n```javascript\nvar foo = null ?? 'default string';\nconsole.log(foo); // 'default string'\n```\n\nnull 병합 연산자는 변수에 기본값을 설정할 때 유용하다. null 병합 연산자가 도입되기 이전에는 논리합 연산자를 사용한 단축 평가를 통해 변수에 기본값을 설정했다.\n\n논리합 연산자는 좌항의 피연산자가 Falsy 값이면 우항의 피연산자를 반환한다. 만약 Falsy 값인 0이나 ''도 기본값으로 유효하다면 예기치 않은 동작이 발생할 수 있다. 하지만 null 병합 연산자는 좌항의 피연산자가 Falsy 값이라도 null 또는 undefined가 아니면 좌항의 피연산자를 그대로 반환한다는 차이점이 있다.\n\n```javascript\nvar foo1 = '' || 'default string';\nvar foo2 = '' ?? 'default string';\n\nconsole.log(foo1); // 'default string'\nconsole.log(foo2); // ''\n```\n\n","source":"_posts/Modern-Javascript-Deep-Dive-Chapter-9-Summary.md","raw":"---\ntitle: \"[Deep Dive] 타입 변환과 단축 평가\"\ndate: 2022-10-21 20:19:55\ntags:\n- 개발\n- 자바스크립트\n- 모던 자바스크립트 Deep Dive\n---\n# 타입 변환이란?\n\n앞서 자바스크립트의 모든 값은 타입이 있음을 알아보았다.\n값의 타입은 개발자의 의도에 따라 다른 타입으로 변환할 수 있는데 이를 명시적 타입 변환 또는 타입 캐스팅이라 한다.\n\n```javascript\nvar x = 10;\n\n// 명시적 타입 변환, 숫자 -> 문자열\nvar str = x.toString();\nconsole.log(typeof str, str); // string 10\n\n// x 변수의 값이 변경된 것은 아님\nconsole.log(typeof x, x); // number 10\n```\n\n개발자의 의도와는 상관없이 표현식을 평가하는 도중 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다.\n이를 암묵적 타입 변환 또는 타입 강제 변환이라 한다.\n\n```javascript\nvar x = 10;\n\n// 암묵적 타입 변환, 숫자 -> 문자열\nvar str = x + '';\nconsole.log(typeof str, str); // string 10\n\n// x 변수의 값이 변경된 것은 아님\nconsole.log(typeof x, x); // number 10\n```\n\n예시에서 볼 수 있듯이 명시적 타입 변환이나 암묵적 타입 변환이 기존 원시 값을 직접 변경하는 것은 아니다.\n원시 값은 변경 불가능한 값으로 변경할 수 없다. 타입 변환이란 기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것이다.\n\n명시적 타입 변환은 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 드러난다.\n하지만 암묵적 타입 강제 변환은 자바스크립트 엔진에 의해 암묵적으로, 즉 드러나지 않게 타입이 자동 변환되기 때문에 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 나타나지 않는다.\n\n따라서 자신이 작성한 코드에서 암묵적 타입 변환이 발생하는지, 발생한다면 어떤 타입의 어떤 값으로 변환되는지 예측 가능해야 한다.\n만약 타입 변환 결과를 예측하지 못하거나 예측이 결과와 일치하지 않는다면 오류를 생산할 가능성이 높아진다.\n타입 변환이 어떻게 동작하는지 정확히 이해하고 사용하자.\n\n## 암묵적 타입 변환\n\n표현식을 평가할 때 코드의 문맥메 부합하지 않는 다양한 상황이 발생할 수 있다. 이때 프로그래밍 언어에 따라 에러를 발생시키기도 하지만 자바스크립트는 가급적 에러를 발생시키지 않도록 암묵적 타입 변환을 통해 표현식을 펴가한다.\n\n암묵적 타입 변환이 발생하면 문자열, 숫자, 불리언과 같은 원시 타입 중 하나로 타입을 자동 변환한다.\n타입 별로 암묵적 타입 변환이 어떻게 발생하는지 살펴보자.\n\n### 문자열 타입으로 변환\n\n```javascript\n1 + '2'; // '12'\n```\n\n위 코드의 + 연산잔느 피연산자 중 하나 이상이 문자열이므로 문자열 연결 연산자로 동작한다.\n문자열 연결 연산자의 역할은 문자열 값을 만드는 것이다. 따라서 문자열 연결 연산자의 모든 피연산자는 코드의 문맥상 모두 문자열 타입이어야 한다.\n\n자바스크립트 엔진은 문자열 연결 연산자 표현식을 평가하기 위해 문자열 연결 연산자의 피연산자 중에서 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적 타입 변환한다.\n\n자바스크립트 엔진은 문자열 타입이 아닌 값을 문자열 타입으로 암묵적 타입 변환을 수행할 때 다음과 같이 동작한다.\n\n```javascript\n// 숫자 타입\n0 + '' // '0'\n-0 + '' // '0'\n1 + '' // '1'\n-1 + '' // '-1'\nNaN + '' // 'NaN'\n\n// 불리언 타입\ntrue + '' // 'true'\nfalse + '' // 'false'\n\n// null 타입\nnull + '' // 'null'\n\n// undefined 타입\nundefined + '' // 'undefined'\n\n// 심벌 타입\n(Symbol()) + '' // TypeError: Cannot convert a Symbol value to a string\n\n// 객체 타입\n({}) + '' // '[object Object]'\nMath + '' // '[object Math]'\n[] + '' // ''\n[10, 20] + '' // '10,20'\n(function(){}) + '' // 'function(){}'\nArray + '' // 'function Array() { [native code] }'\n```\n\n### 숫자 타입으로 변환\n\n```javascript\n1 - '1'; // 0\n1 * '10'; // 10\n1 / 'one'; // NaN\n```\n\n위 코드에서 사용한 연산자는 모두 산술 연산자이다.\n산술 연산자의 역할은 숫자 값을 만드는 것이므로 산술 연산자의 모든 피연산자는 코드 문맥상 모두 숫자 타입이어야 한다.\n\n자바스크립트 엔진은 산술 연산자 표현식을 평가하기 위해 산술 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다. 이때 피연산자를 숫자 타입으로 변환할 수 없는 경우는 산술 연산을 수행할 수 없으므로 표현식의 평가 결과는 NaN이 된다.\n\n```javascript\n'1' > 0; // true\n```\n\n비교 연산자의 역할은 불리언 값을 만드는 것이다. > 비교 연산자는 피연산자의 크기를 비교하므로 모든 피연산자는 코드 문맥상 모두 숫자 타입이어야 한다.\n자바스크립트 엔진은 비교 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다.\n\n자바스크립트 엔진은 숫자 타입이 아닌 값을 숫자 타입으로 암묵적 타입 변환을 수행할 때 다음과 같이 동작한다.\n\n```javascript\n// 문자열 타입\n+'' + // 0\n  '0' + // 0\n  '1' + // 1\n  'string' + // NaN\n  // 불리언 타입\n  true + // 1\n  false + // 0\n  // null 타입\n  null / 0 +\n  // undefined 타입\n  undefined + // NaN\n  // 심벌 타입\n  Symbol() + // TypeError: Cannot convert a Symbol value to a number\n  // 객체 타입\n  {} + // NaN\n  [] + // 0\n  [10, 20] + // NaN\n  function () {}; // NaN\n```\n\n빈 문자열(''), 빈 배열([]), null, false는 0으로 true는 1로 변환된다.\n객체와 빈 배열이 아닌 배열, undefined는 변환되지 않아 NaN이 되는 것에 주의하자.\n\n### 불리언 타입으로 변환\n\n```javascript\nif ('') console.log(x);\n```\n\nif 문이나 for 문과 같은 제어문 또는 삼항 조건 연산자의 조건식은 불리언 값, 즉 논리적 참과 거짓으로 평가되어야 한느 표현식이다.\n자바스크립트 엔진은 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환한다.\n\n이때 자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분한다.\n\nfalse로 평가되는 Falsy 값은 다음과 같다.\n\n- false\n- undefined\n- null\n- 0, -0\n- NaN\n- ''(빈 문자열)\n\nFalsy 값 외의 모든 값은 모두 true로 평가되는 Truthy 값이다.\n\n## 명시적 타입 변환\n\n개발자의 의도에 따라 명시적으로 타입을 변경하는 방법은 다양하다.\n표준 빌트인 생성자 함수(String, Number, Boolean)을 new 연산자 없이 호출하는 방법과 빌트인 메서드를 사용하는 방법, 그리고 앞서 살펴본 암묵적 타입 변환을 이용하는 방법이 있다.\n\n### 문자열 타입으로 변환\n\n문자열 타입이 아닌 값을 문자열 타입으로 변환하는 방법은 다음과 같다.\n\n- String 생성자 함수를 new 연산자 없이 호출\n- Object.prototype.toString 메서드를 사용\n- 문자열 연결 연산자를 이용\n\n```javascript\nString(1); // '1'\nString(NaN); // 'NaN'\nString(true); // 'true'\n\n(1).toString(); // '1'\nNaN.toString(); // 'NaN'\ntrue.toString(); // 'true'\n\n1 + ''; // '1'\nNaN + ''; // 'NaN'\ntrue + ''; // 'true'\n```\n\n### 숫자 타입으로 변환\n\n숫자 타입이 아닌 값을 숫자 타입으로 변환하는 방법은 다음과 같다.\n\n- Number 생성자 함수를 new 연산자 없이 호출\n- parseInt, parseFloat 함수를 사용(문자열만 숫자 타입으로 변환 가능)\n- \\+ 단항 산술 연산자를 이용\n- \\* 산술 연산자를 이용\n\n```javascript\nNumber('0'); // 0\nNumber('10.53'); // 10.53\nNumber(true); // 1\n\nparseInt('0'); // 0\nparseFloat('10.53'); // 10.53\n\n+'0'; // 0\n+'10.53'; // 10.53\ntrue; // 1\n\n'0' * 1; // 0\n'10.53' * 1; // 10.53\ntrue * 1; // 1\n```\n\n### 불리언 타입으로 변환\n\n불리언 타입이 아닌 값을 불리언 타입으로 변환하는 방법은 다음과 같다.\n\n- Boolean 생성자 함수를 new 연산자 없이 호출\n- 부정 논리 연산자(!)를 두전 사용\n\n```javascript\nBoolean('x'); // true\nBoolean(''); // false\nBoolean({}); // true\n\n!!'x'; // true\n!!''; // false\n!!{}; // true\n```\n\n## 단축 평가\n\n이전에 연산자를 공부하면서 논리합(||) 연산자와 논리곱(&&) 연산자에 대해 살펴 본 적이 있다.\n논리합(||) 또는 논리곱(&&) 연산자 표현식은 언제나 2개의 피연산자 중 한쪽으로 평가되는데 이를 설명하기 위해서는 암묵적 타입 변환을 알아야 한다.\n앞서 암묵적 타입 변환에 대해 살펴보았으니 이에 대해 알아보자.\n\n```javascript\n'Cat' && 'Dog'; // 'Dog'\n```\n\n논리곱(&&) 연산자는 두 개의 피연산자가 모두 true로 평가될 때 true를 반환한다. 논리곱 연산자는 좌항에서 우항으로 평가가 진행된다.\n\n첫 번째 피연산자 'Cat'은 Truthy 값이므로 true로 평가된다. 하지만 이 시점까지는 위 표현식을 평가할 수 없다.\n두 번째 피연산자까지 평가해 보아야 위 표현식을 평가할 수 있다. 즉 두 번째 피연산자가 논리곱 연산자 표현식의 평가 결과를 결정한다.\n이때 논리곱 연산자는 논리 연산의 결과를 결정하는 두 번째 피연산자 문자열 'Dog'를 타입 변환 없이 그대로 반환한다.\n\n논리합(||) 연산자도 논리곱(&&) 연산자와 동일하게 동작한다.\n\n논리곱(&&) 연산자와 논리합(||) 연산자는 이처럼 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환한다.\n이를 단축평가라 한다. 단축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말한다.\n\n단축 평가를 사용하면 if 문을 대체할 수 있다. 어떤 조건이 Truthy 값일 때 무언가를 해야 한다면 논리곱(&&) 연산자를, 어떤 조건이 Falsy 값일 때 무언가를 해야 한다면 논리합(||) 연산자를 이용할 수 있다.\n\n```javascript\nvar done = true;\nvar message = '';\n\nif (done) message = '완료';\nmessage = done && '완료';\nconsole.log(message); // 완료\n```\n\n```javascript\nvar done = false;\nvar message = '';\n\nif (done) message = '미완료';\nmessage = done || '미완료';\nconsole.log(message); // 미완료\n```\n\n### 옵셔널 체이닝 연산자\n\nES11에서 도입된 옵셔널 체이닝 연산자 ?.는 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.\n\n```javascript\nvar elem = null;\n\nvar value = elem?.value;\nconsole.log(value); // undefined\n```\n\n옵셔널 체이닝 연산자는 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때 유용하다.\n옵셔널 체이닝 연산자가 도입되기 이전에는 논리곱 연산자를 사용한 단축 평가를 통해 변수가 null 또는 undefined인지 확인했다.\n\n논리곱 연산자는 좌항의 피연산자가 Falsy 값이면 좌항 피연산자를 그대로 반환한다. 좌항 피연산자가 Falsy 값인 0이나 ''인 경우도 마찬가지다.\n하지만 0이나 ''은 객체로 평가될 때도 있다. 옵셔널 체이닝 연산자는 좌항 피연산자가 Falsy 값이라도 null 또는 undefined가 아니면 우항의 프로퍼티 참조를 이어간다는 차이점이 있다.\n\n```javascript\nvar str = '';\n\nvar length1 = str && str.length;\nvar length2 = str?.length;\n\nconsole.log(length1); // ''\nconsole.log(length2); // 0\n```\n\n### null 병합 연산자\n\nES11에서 도입된 null 병합 연산자 ??는 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다.\n\n```javascript\nvar foo = null ?? 'default string';\nconsole.log(foo); // 'default string'\n```\n\nnull 병합 연산자는 변수에 기본값을 설정할 때 유용하다. null 병합 연산자가 도입되기 이전에는 논리합 연산자를 사용한 단축 평가를 통해 변수에 기본값을 설정했다.\n\n논리합 연산자는 좌항의 피연산자가 Falsy 값이면 우항의 피연산자를 반환한다. 만약 Falsy 값인 0이나 ''도 기본값으로 유효하다면 예기치 않은 동작이 발생할 수 있다. 하지만 null 병합 연산자는 좌항의 피연산자가 Falsy 값이라도 null 또는 undefined가 아니면 좌항의 피연산자를 그대로 반환한다는 차이점이 있다.\n\n```javascript\nvar foo1 = '' || 'default string';\nvar foo2 = '' ?? 'default string';\n\nconsole.log(foo1); // 'default string'\nconsole.log(foo2); // ''\n```\n\n","slug":"Modern-Javascript-Deep-Dive-Chapter-9-Summary","published":1,"updated":"2022-10-21T11:21:00.027Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb08iq6j000oe4vk6qsh87bv","content":"<h1 id=\"타입-변환이란\"><a href=\"#타입-변환이란\" class=\"headerlink\" title=\"타입 변환이란?\"></a>타입 변환이란?</h1><p>앞서 자바스크립트의 모든 값은 타입이 있음을 알아보았다.<br>값의 타입은 개발자의 의도에 따라 다른 타입으로 변환할 수 있는데 이를 명시적 타입 변환 또는 타입 캐스팅이라 한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 명시적 타입 변환, 숫자 -&gt; 문자열</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = x.<span class=\"title function_\">toString</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> str, str); <span class=\"comment\">// string 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// x 변수의 값이 변경된 것은 아님</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> x, x); <span class=\"comment\">// number 10</span></span><br></pre></td></tr></table></figure>\n\n<p>개발자의 의도와는 상관없이 표현식을 평가하는 도중 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다.<br>이를 암묵적 타입 변환 또는 타입 강제 변환이라 한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 암묵적 타입 변환, 숫자 -&gt; 문자열</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = x + <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> str, str); <span class=\"comment\">// string 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// x 변수의 값이 변경된 것은 아님</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> x, x); <span class=\"comment\">// number 10</span></span><br></pre></td></tr></table></figure>\n\n<p>예시에서 볼 수 있듯이 명시적 타입 변환이나 암묵적 타입 변환이 기존 원시 값을 직접 변경하는 것은 아니다.<br>원시 값은 변경 불가능한 값으로 변경할 수 없다. 타입 변환이란 기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것이다.</p>\n<p>명시적 타입 변환은 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 드러난다.<br>하지만 암묵적 타입 강제 변환은 자바스크립트 엔진에 의해 암묵적으로, 즉 드러나지 않게 타입이 자동 변환되기 때문에 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 나타나지 않는다.</p>\n<p>따라서 자신이 작성한 코드에서 암묵적 타입 변환이 발생하는지, 발생한다면 어떤 타입의 어떤 값으로 변환되는지 예측 가능해야 한다.<br>만약 타입 변환 결과를 예측하지 못하거나 예측이 결과와 일치하지 않는다면 오류를 생산할 가능성이 높아진다.<br>타입 변환이 어떻게 동작하는지 정확히 이해하고 사용하자.</p>\n<h2 id=\"암묵적-타입-변환\"><a href=\"#암묵적-타입-변환\" class=\"headerlink\" title=\"암묵적 타입 변환\"></a>암묵적 타입 변환</h2><p>표현식을 평가할 때 코드의 문맥메 부합하지 않는 다양한 상황이 발생할 수 있다. 이때 프로그래밍 언어에 따라 에러를 발생시키기도 하지만 자바스크립트는 가급적 에러를 발생시키지 않도록 암묵적 타입 변환을 통해 표현식을 펴가한다.</p>\n<p>암묵적 타입 변환이 발생하면 문자열, 숫자, 불리언과 같은 원시 타입 중 하나로 타입을 자동 변환한다.<br>타입 별로 암묵적 타입 변환이 어떻게 발생하는지 살펴보자.</p>\n<h3 id=\"문자열-타입으로-변환\"><a href=\"#문자열-타입으로-변환\" class=\"headerlink\" title=\"문자열 타입으로 변환\"></a>문자열 타입으로 변환</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> + <span class=\"string\">&#x27;2&#x27;</span>; <span class=\"comment\">// &#x27;12&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>위 코드의 + 연산잔느 피연산자 중 하나 이상이 문자열이므로 문자열 연결 연산자로 동작한다.<br>문자열 연결 연산자의 역할은 문자열 값을 만드는 것이다. 따라서 문자열 연결 연산자의 모든 피연산자는 코드의 문맥상 모두 문자열 타입이어야 한다.</p>\n<p>자바스크립트 엔진은 문자열 연결 연산자 표현식을 평가하기 위해 문자열 연결 연산자의 피연산자 중에서 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적 타입 변환한다.</p>\n<p>자바스크립트 엔진은 문자열 타입이 아닌 값을 문자열 타입으로 암묵적 타입 변환을 수행할 때 다음과 같이 동작한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 숫자 타입</span></span><br><span class=\"line\"><span class=\"number\">0</span> + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;0&#x27;</span></span><br><span class=\"line\">-<span class=\"number\">0</span> + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;0&#x27;</span></span><br><span class=\"line\"><span class=\"number\">1</span> + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;1&#x27;</span></span><br><span class=\"line\">-<span class=\"number\">1</span> + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;-1&#x27;</span></span><br><span class=\"line\"><span class=\"title class_\">NaN</span> + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;NaN&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 불리언 타입</span></span><br><span class=\"line\"><span class=\"literal\">true</span> + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;true&#x27;</span></span><br><span class=\"line\"><span class=\"literal\">false</span> + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;false&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// null 타입</span></span><br><span class=\"line\"><span class=\"literal\">null</span> + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;null&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// undefined 타입</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;undefined&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 심벌 타입</span></span><br><span class=\"line\">(<span class=\"title class_\">Symbol</span>()) + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// TypeError: Cannot convert a Symbol value to a string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 객체 타입</span></span><br><span class=\"line\">(&#123;&#125;) + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;[object Object]&#x27;</span></span><br><span class=\"line\"><span class=\"title class_\">Math</span> + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;[object Math]&#x27;</span></span><br><span class=\"line\">[] + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;&#x27;</span></span><br><span class=\"line\">[<span class=\"number\">10</span>, <span class=\"number\">20</span>] + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;10,20&#x27;</span></span><br><span class=\"line\">(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;&#125;) + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;function()&#123;&#125;&#x27;</span></span><br><span class=\"line\"><span class=\"title class_\">Array</span> + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;function Array() &#123; [native code] &#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"숫자-타입으로-변환\"><a href=\"#숫자-타입으로-변환\" class=\"headerlink\" title=\"숫자 타입으로 변환\"></a>숫자 타입으로 변환</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> - <span class=\"string\">&#x27;1&#x27;</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"number\">1</span> * <span class=\"string\">&#x27;10&#x27;</span>; <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"number\">1</span> / <span class=\"string\">&#x27;one&#x27;</span>; <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<p>위 코드에서 사용한 연산자는 모두 산술 연산자이다.<br>산술 연산자의 역할은 숫자 값을 만드는 것이므로 산술 연산자의 모든 피연산자는 코드 문맥상 모두 숫자 타입이어야 한다.</p>\n<p>자바스크립트 엔진은 산술 연산자 표현식을 평가하기 위해 산술 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다. 이때 피연산자를 숫자 타입으로 변환할 수 없는 경우는 산술 연산을 수행할 수 없으므로 표현식의 평가 결과는 NaN이 된다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&#x27;1&#x27;</span> &gt; <span class=\"number\">0</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>비교 연산자의 역할은 불리언 값을 만드는 것이다. &gt; 비교 연산자는 피연산자의 크기를 비교하므로 모든 피연산자는 코드 문맥상 모두 숫자 타입이어야 한다.<br>자바스크립트 엔진은 비교 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다.</p>\n<p>자바스크립트 엔진은 숫자 타입이 아닌 값을 숫자 타입으로 암묵적 타입 변환을 수행할 때 다음과 같이 동작한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 문자열 타입</span></span><br><span class=\"line\">+<span class=\"string\">&#x27;&#x27;</span> + <span class=\"comment\">// 0</span></span><br><span class=\"line\">  <span class=\"string\">&#x27;0&#x27;</span> + <span class=\"comment\">// 0</span></span><br><span class=\"line\">  <span class=\"string\">&#x27;1&#x27;</span> + <span class=\"comment\">// 1</span></span><br><span class=\"line\">  <span class=\"string\">&#x27;string&#x27;</span> + <span class=\"comment\">// NaN</span></span><br><span class=\"line\">  <span class=\"comment\">// 불리언 타입</span></span><br><span class=\"line\">  <span class=\"literal\">true</span> + <span class=\"comment\">// 1</span></span><br><span class=\"line\">  <span class=\"literal\">false</span> + <span class=\"comment\">// 0</span></span><br><span class=\"line\">  <span class=\"comment\">// null 타입</span></span><br><span class=\"line\">  <span class=\"literal\">null</span> / <span class=\"number\">0</span> +</span><br><span class=\"line\">  <span class=\"comment\">// undefined 타입</span></span><br><span class=\"line\">  <span class=\"literal\">undefined</span> + <span class=\"comment\">// NaN</span></span><br><span class=\"line\">  <span class=\"comment\">// 심벌 타입</span></span><br><span class=\"line\">  <span class=\"title class_\">Symbol</span>() + <span class=\"comment\">// TypeError: Cannot convert a Symbol value to a number</span></span><br><span class=\"line\">  <span class=\"comment\">// 객체 타입</span></span><br><span class=\"line\">  &#123;&#125; + <span class=\"comment\">// NaN</span></span><br><span class=\"line\">  [] + <span class=\"comment\">// 0</span></span><br><span class=\"line\">  [<span class=\"number\">10</span>, <span class=\"number\">20</span>] + <span class=\"comment\">// NaN</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;&#125;; <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<p>빈 문자열(‘’), 빈 배열([]), null, false는 0으로 true는 1로 변환된다.<br>객체와 빈 배열이 아닌 배열, undefined는 변환되지 않아 NaN이 되는 것에 주의하자.</p>\n<h3 id=\"불리언-타입으로-변환\"><a href=\"#불리언-타입으로-변환\" class=\"headerlink\" title=\"불리언 타입으로 변환\"></a>불리언 타입으로 변환</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"string\">&#x27;&#x27;</span>) <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br></pre></td></tr></table></figure>\n\n<p>if 문이나 for 문과 같은 제어문 또는 삼항 조건 연산자의 조건식은 불리언 값, 즉 논리적 참과 거짓으로 평가되어야 한느 표현식이다.<br>자바스크립트 엔진은 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환한다.</p>\n<p>이때 자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분한다.</p>\n<p>false로 평가되는 Falsy 값은 다음과 같다.</p>\n<ul>\n<li>false</li>\n<li>undefined</li>\n<li>null</li>\n<li>0, -0</li>\n<li>NaN</li>\n<li>‘’(빈 문자열)</li>\n</ul>\n<p>Falsy 값 외의 모든 값은 모두 true로 평가되는 Truthy 값이다.</p>\n<h2 id=\"명시적-타입-변환\"><a href=\"#명시적-타입-변환\" class=\"headerlink\" title=\"명시적 타입 변환\"></a>명시적 타입 변환</h2><p>개발자의 의도에 따라 명시적으로 타입을 변경하는 방법은 다양하다.<br>표준 빌트인 생성자 함수(String, Number, Boolean)을 new 연산자 없이 호출하는 방법과 빌트인 메서드를 사용하는 방법, 그리고 앞서 살펴본 암묵적 타입 변환을 이용하는 방법이 있다.</p>\n<h3 id=\"문자열-타입으로-변환-1\"><a href=\"#문자열-타입으로-변환-1\" class=\"headerlink\" title=\"문자열 타입으로 변환\"></a>문자열 타입으로 변환</h3><p>문자열 타입이 아닌 값을 문자열 타입으로 변환하는 방법은 다음과 같다.</p>\n<ul>\n<li>String 생성자 함수를 new 연산자 없이 호출</li>\n<li>Object.prototype.toString 메서드를 사용</li>\n<li>문자열 연결 연산자를 이용</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">String</span>(<span class=\"number\">1</span>); <span class=\"comment\">// &#x27;1&#x27;</span></span><br><span class=\"line\"><span class=\"title class_\">String</span>(<span class=\"title class_\">NaN</span>); <span class=\"comment\">// &#x27;NaN&#x27;</span></span><br><span class=\"line\"><span class=\"title class_\">String</span>(<span class=\"literal\">true</span>); <span class=\"comment\">// &#x27;true&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"number\">1</span>).<span class=\"title function_\">toString</span>(); <span class=\"comment\">// &#x27;1&#x27;</span></span><br><span class=\"line\"><span class=\"title class_\">NaN</span>.<span class=\"title function_\">toString</span>(); <span class=\"comment\">// &#x27;NaN&#x27;</span></span><br><span class=\"line\"><span class=\"literal\">true</span>.<span class=\"title function_\">toString</span>(); <span class=\"comment\">// &#x27;true&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span> + <span class=\"string\">&#x27;&#x27;</span>; <span class=\"comment\">// &#x27;1&#x27;</span></span><br><span class=\"line\"><span class=\"title class_\">NaN</span> + <span class=\"string\">&#x27;&#x27;</span>; <span class=\"comment\">// &#x27;NaN&#x27;</span></span><br><span class=\"line\"><span class=\"literal\">true</span> + <span class=\"string\">&#x27;&#x27;</span>; <span class=\"comment\">// &#x27;true&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"숫자-타입으로-변환-1\"><a href=\"#숫자-타입으로-변환-1\" class=\"headerlink\" title=\"숫자 타입으로 변환\"></a>숫자 타입으로 변환</h3><p>숫자 타입이 아닌 값을 숫자 타입으로 변환하는 방법은 다음과 같다.</p>\n<ul>\n<li>Number 생성자 함수를 new 연산자 없이 호출</li>\n<li>parseInt, parseFloat 함수를 사용(문자열만 숫자 타입으로 변환 가능)</li>\n<li>+ 단항 산술 연산자를 이용</li>\n<li>* 산술 연산자를 이용</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Number</span>(<span class=\"string\">&#x27;0&#x27;</span>); <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>(<span class=\"string\">&#x27;10.53&#x27;</span>); <span class=\"comment\">// 10.53</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>(<span class=\"literal\">true</span>); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;0&#x27;</span>); <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">parseFloat</span>(<span class=\"string\">&#x27;10.53&#x27;</span>); <span class=\"comment\">// 10.53</span></span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"string\">&#x27;0&#x27;</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\">+<span class=\"string\">&#x27;10.53&#x27;</span>; <span class=\"comment\">// 10.53</span></span><br><span class=\"line\"><span class=\"literal\">true</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&#x27;0&#x27;</span> * <span class=\"number\">1</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"string\">&#x27;10.53&#x27;</span> * <span class=\"number\">1</span>; <span class=\"comment\">// 10.53</span></span><br><span class=\"line\"><span class=\"literal\">true</span> * <span class=\"number\">1</span>; <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"불리언-타입으로-변환-1\"><a href=\"#불리언-타입으로-변환-1\" class=\"headerlink\" title=\"불리언 타입으로 변환\"></a>불리언 타입으로 변환</h3><p>불리언 타입이 아닌 값을 불리언 타입으로 변환하는 방법은 다음과 같다.</p>\n<ul>\n<li>Boolean 생성자 함수를 new 연산자 없이 호출</li>\n<li>부정 논리 연산자(!)를 두전 사용</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Boolean</span>(<span class=\"string\">&#x27;x&#x27;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>(<span class=\"string\">&#x27;&#x27;</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>(&#123;&#125;); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">!!<span class=\"string\">&#x27;x&#x27;</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\">!!<span class=\"string\">&#x27;&#x27;</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\">!!&#123;&#125;; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"단축-평가\"><a href=\"#단축-평가\" class=\"headerlink\" title=\"단축 평가\"></a>단축 평가</h2><p>이전에 연산자를 공부하면서 논리합(||) 연산자와 논리곱(&amp;&amp;) 연산자에 대해 살펴 본 적이 있다.<br>논리합(||) 또는 논리곱(&amp;&amp;) 연산자 표현식은 언제나 2개의 피연산자 중 한쪽으로 평가되는데 이를 설명하기 위해서는 암묵적 타입 변환을 알아야 한다.<br>앞서 암묵적 타입 변환에 대해 살펴보았으니 이에 대해 알아보자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&#x27;Cat&#x27;</span> &amp;&amp; <span class=\"string\">&#x27;Dog&#x27;</span>; <span class=\"comment\">// &#x27;Dog&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>논리곱(&amp;&amp;) 연산자는 두 개의 피연산자가 모두 true로 평가될 때 true를 반환한다. 논리곱 연산자는 좌항에서 우항으로 평가가 진행된다.</p>\n<p>첫 번째 피연산자 ‘Cat’은 Truthy 값이므로 true로 평가된다. 하지만 이 시점까지는 위 표현식을 평가할 수 없다.<br>두 번째 피연산자까지 평가해 보아야 위 표현식을 평가할 수 있다. 즉 두 번째 피연산자가 논리곱 연산자 표현식의 평가 결과를 결정한다.<br>이때 논리곱 연산자는 논리 연산의 결과를 결정하는 두 번째 피연산자 문자열 ‘Dog’를 타입 변환 없이 그대로 반환한다.</p>\n<p>논리합(||) 연산자도 논리곱(&amp;&amp;) 연산자와 동일하게 동작한다.</p>\n<p>논리곱(&amp;&amp;) 연산자와 논리합(||) 연산자는 이처럼 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환한다.<br>이를 단축평가라 한다. 단축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말한다.</p>\n<p>단축 평가를 사용하면 if 문을 대체할 수 있다. 어떤 조건이 Truthy 값일 때 무언가를 해야 한다면 논리곱(&amp;&amp;) 연산자를, 어떤 조건이 Falsy 값일 때 무언가를 해야 한다면 논리합(||) 연산자를 이용할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> done = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (done) message = <span class=\"string\">&#x27;완료&#x27;</span>;</span><br><span class=\"line\">message = done &amp;&amp; <span class=\"string\">&#x27;완료&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(message); <span class=\"comment\">// 완료</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> done = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (done) message = <span class=\"string\">&#x27;미완료&#x27;</span>;</span><br><span class=\"line\">message = done || <span class=\"string\">&#x27;미완료&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(message); <span class=\"comment\">// 미완료</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"옵셔널-체이닝-연산자\"><a href=\"#옵셔널-체이닝-연산자\" class=\"headerlink\" title=\"옵셔널 체이닝 연산자\"></a>옵셔널 체이닝 연산자</h3><p>ES11에서 도입된 옵셔널 체이닝 연산자 ?.는 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> elem = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> value = elem?.<span class=\"property\">value</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>옵셔널 체이닝 연산자는 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때 유용하다.<br>옵셔널 체이닝 연산자가 도입되기 이전에는 논리곱 연산자를 사용한 단축 평가를 통해 변수가 null 또는 undefined인지 확인했다.</p>\n<p>논리곱 연산자는 좌항의 피연산자가 Falsy 값이면 좌항 피연산자를 그대로 반환한다. 좌항 피연산자가 Falsy 값인 0이나 ‘’인 경우도 마찬가지다.<br>하지만 0이나 ‘’은 객체로 평가될 때도 있다. 옵셔널 체이닝 연산자는 좌항 피연산자가 Falsy 값이라도 null 또는 undefined가 아니면 우항의 프로퍼티 참조를 이어간다는 차이점이 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> length1 = str &amp;&amp; str.<span class=\"property\">length</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> length2 = str?.<span class=\"property\">length</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(length1); <span class=\"comment\">// &#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(length2); <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"null-병합-연산자\"><a href=\"#null-병합-연산자\" class=\"headerlink\" title=\"null 병합 연산자\"></a>null 병합 연산자</h3><p>ES11에서 도입된 null 병합 연산자 ??는 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"literal\">null</span> ?? <span class=\"string\">&#x27;default string&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(foo); <span class=\"comment\">// &#x27;default string&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>null 병합 연산자는 변수에 기본값을 설정할 때 유용하다. null 병합 연산자가 도입되기 이전에는 논리합 연산자를 사용한 단축 평가를 통해 변수에 기본값을 설정했다.</p>\n<p>논리합 연산자는 좌항의 피연산자가 Falsy 값이면 우항의 피연산자를 반환한다. 만약 Falsy 값인 0이나 ‘’도 기본값으로 유효하다면 예기치 않은 동작이 발생할 수 있다. 하지만 null 병합 연산자는 좌항의 피연산자가 Falsy 값이라도 null 또는 undefined가 아니면 좌항의 피연산자를 그대로 반환한다는 차이점이 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo1 = <span class=\"string\">&#x27;&#x27;</span> || <span class=\"string\">&#x27;default string&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo2 = <span class=\"string\">&#x27;&#x27;</span> ?? <span class=\"string\">&#x27;default string&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(foo1); <span class=\"comment\">// &#x27;default string&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(foo2); <span class=\"comment\">// &#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"타입-변환이란\"><a href=\"#타입-변환이란\" class=\"headerlink\" title=\"타입 변환이란?\"></a>타입 변환이란?</h1><p>앞서 자바스크립트의 모든 값은 타입이 있음을 알아보았다.<br>값의 타입은 개발자의 의도에 따라 다른 타입으로 변환할 수 있는데 이를 명시적 타입 변환 또는 타입 캐스팅이라 한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 명시적 타입 변환, 숫자 -&gt; 문자열</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = x.<span class=\"title function_\">toString</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> str, str); <span class=\"comment\">// string 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// x 변수의 값이 변경된 것은 아님</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> x, x); <span class=\"comment\">// number 10</span></span><br></pre></td></tr></table></figure>\n\n<p>개발자의 의도와는 상관없이 표현식을 평가하는 도중 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다.<br>이를 암묵적 타입 변환 또는 타입 강제 변환이라 한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 암묵적 타입 변환, 숫자 -&gt; 문자열</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = x + <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> str, str); <span class=\"comment\">// string 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// x 변수의 값이 변경된 것은 아님</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> x, x); <span class=\"comment\">// number 10</span></span><br></pre></td></tr></table></figure>\n\n<p>예시에서 볼 수 있듯이 명시적 타입 변환이나 암묵적 타입 변환이 기존 원시 값을 직접 변경하는 것은 아니다.<br>원시 값은 변경 불가능한 값으로 변경할 수 없다. 타입 변환이란 기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것이다.</p>\n<p>명시적 타입 변환은 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 드러난다.<br>하지만 암묵적 타입 강제 변환은 자바스크립트 엔진에 의해 암묵적으로, 즉 드러나지 않게 타입이 자동 변환되기 때문에 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 나타나지 않는다.</p>\n<p>따라서 자신이 작성한 코드에서 암묵적 타입 변환이 발생하는지, 발생한다면 어떤 타입의 어떤 값으로 변환되는지 예측 가능해야 한다.<br>만약 타입 변환 결과를 예측하지 못하거나 예측이 결과와 일치하지 않는다면 오류를 생산할 가능성이 높아진다.<br>타입 변환이 어떻게 동작하는지 정확히 이해하고 사용하자.</p>\n<h2 id=\"암묵적-타입-변환\"><a href=\"#암묵적-타입-변환\" class=\"headerlink\" title=\"암묵적 타입 변환\"></a>암묵적 타입 변환</h2><p>표현식을 평가할 때 코드의 문맥메 부합하지 않는 다양한 상황이 발생할 수 있다. 이때 프로그래밍 언어에 따라 에러를 발생시키기도 하지만 자바스크립트는 가급적 에러를 발생시키지 않도록 암묵적 타입 변환을 통해 표현식을 펴가한다.</p>\n<p>암묵적 타입 변환이 발생하면 문자열, 숫자, 불리언과 같은 원시 타입 중 하나로 타입을 자동 변환한다.<br>타입 별로 암묵적 타입 변환이 어떻게 발생하는지 살펴보자.</p>\n<h3 id=\"문자열-타입으로-변환\"><a href=\"#문자열-타입으로-변환\" class=\"headerlink\" title=\"문자열 타입으로 변환\"></a>문자열 타입으로 변환</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> + <span class=\"string\">&#x27;2&#x27;</span>; <span class=\"comment\">// &#x27;12&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>위 코드의 + 연산잔느 피연산자 중 하나 이상이 문자열이므로 문자열 연결 연산자로 동작한다.<br>문자열 연결 연산자의 역할은 문자열 값을 만드는 것이다. 따라서 문자열 연결 연산자의 모든 피연산자는 코드의 문맥상 모두 문자열 타입이어야 한다.</p>\n<p>자바스크립트 엔진은 문자열 연결 연산자 표현식을 평가하기 위해 문자열 연결 연산자의 피연산자 중에서 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적 타입 변환한다.</p>\n<p>자바스크립트 엔진은 문자열 타입이 아닌 값을 문자열 타입으로 암묵적 타입 변환을 수행할 때 다음과 같이 동작한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 숫자 타입</span></span><br><span class=\"line\"><span class=\"number\">0</span> + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;0&#x27;</span></span><br><span class=\"line\">-<span class=\"number\">0</span> + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;0&#x27;</span></span><br><span class=\"line\"><span class=\"number\">1</span> + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;1&#x27;</span></span><br><span class=\"line\">-<span class=\"number\">1</span> + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;-1&#x27;</span></span><br><span class=\"line\"><span class=\"title class_\">NaN</span> + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;NaN&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 불리언 타입</span></span><br><span class=\"line\"><span class=\"literal\">true</span> + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;true&#x27;</span></span><br><span class=\"line\"><span class=\"literal\">false</span> + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;false&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// null 타입</span></span><br><span class=\"line\"><span class=\"literal\">null</span> + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;null&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// undefined 타입</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;undefined&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 심벌 타입</span></span><br><span class=\"line\">(<span class=\"title class_\">Symbol</span>()) + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// TypeError: Cannot convert a Symbol value to a string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 객체 타입</span></span><br><span class=\"line\">(&#123;&#125;) + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;[object Object]&#x27;</span></span><br><span class=\"line\"><span class=\"title class_\">Math</span> + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;[object Math]&#x27;</span></span><br><span class=\"line\">[] + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;&#x27;</span></span><br><span class=\"line\">[<span class=\"number\">10</span>, <span class=\"number\">20</span>] + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;10,20&#x27;</span></span><br><span class=\"line\">(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;&#125;) + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;function()&#123;&#125;&#x27;</span></span><br><span class=\"line\"><span class=\"title class_\">Array</span> + <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// &#x27;function Array() &#123; [native code] &#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"숫자-타입으로-변환\"><a href=\"#숫자-타입으로-변환\" class=\"headerlink\" title=\"숫자 타입으로 변환\"></a>숫자 타입으로 변환</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> - <span class=\"string\">&#x27;1&#x27;</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"number\">1</span> * <span class=\"string\">&#x27;10&#x27;</span>; <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"number\">1</span> / <span class=\"string\">&#x27;one&#x27;</span>; <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<p>위 코드에서 사용한 연산자는 모두 산술 연산자이다.<br>산술 연산자의 역할은 숫자 값을 만드는 것이므로 산술 연산자의 모든 피연산자는 코드 문맥상 모두 숫자 타입이어야 한다.</p>\n<p>자바스크립트 엔진은 산술 연산자 표현식을 평가하기 위해 산술 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다. 이때 피연산자를 숫자 타입으로 변환할 수 없는 경우는 산술 연산을 수행할 수 없으므로 표현식의 평가 결과는 NaN이 된다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&#x27;1&#x27;</span> &gt; <span class=\"number\">0</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>비교 연산자의 역할은 불리언 값을 만드는 것이다. &gt; 비교 연산자는 피연산자의 크기를 비교하므로 모든 피연산자는 코드 문맥상 모두 숫자 타입이어야 한다.<br>자바스크립트 엔진은 비교 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다.</p>\n<p>자바스크립트 엔진은 숫자 타입이 아닌 값을 숫자 타입으로 암묵적 타입 변환을 수행할 때 다음과 같이 동작한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 문자열 타입</span></span><br><span class=\"line\">+<span class=\"string\">&#x27;&#x27;</span> + <span class=\"comment\">// 0</span></span><br><span class=\"line\">  <span class=\"string\">&#x27;0&#x27;</span> + <span class=\"comment\">// 0</span></span><br><span class=\"line\">  <span class=\"string\">&#x27;1&#x27;</span> + <span class=\"comment\">// 1</span></span><br><span class=\"line\">  <span class=\"string\">&#x27;string&#x27;</span> + <span class=\"comment\">// NaN</span></span><br><span class=\"line\">  <span class=\"comment\">// 불리언 타입</span></span><br><span class=\"line\">  <span class=\"literal\">true</span> + <span class=\"comment\">// 1</span></span><br><span class=\"line\">  <span class=\"literal\">false</span> + <span class=\"comment\">// 0</span></span><br><span class=\"line\">  <span class=\"comment\">// null 타입</span></span><br><span class=\"line\">  <span class=\"literal\">null</span> / <span class=\"number\">0</span> +</span><br><span class=\"line\">  <span class=\"comment\">// undefined 타입</span></span><br><span class=\"line\">  <span class=\"literal\">undefined</span> + <span class=\"comment\">// NaN</span></span><br><span class=\"line\">  <span class=\"comment\">// 심벌 타입</span></span><br><span class=\"line\">  <span class=\"title class_\">Symbol</span>() + <span class=\"comment\">// TypeError: Cannot convert a Symbol value to a number</span></span><br><span class=\"line\">  <span class=\"comment\">// 객체 타입</span></span><br><span class=\"line\">  &#123;&#125; + <span class=\"comment\">// NaN</span></span><br><span class=\"line\">  [] + <span class=\"comment\">// 0</span></span><br><span class=\"line\">  [<span class=\"number\">10</span>, <span class=\"number\">20</span>] + <span class=\"comment\">// NaN</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;&#125;; <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<p>빈 문자열(‘’), 빈 배열([]), null, false는 0으로 true는 1로 변환된다.<br>객체와 빈 배열이 아닌 배열, undefined는 변환되지 않아 NaN이 되는 것에 주의하자.</p>\n<h3 id=\"불리언-타입으로-변환\"><a href=\"#불리언-타입으로-변환\" class=\"headerlink\" title=\"불리언 타입으로 변환\"></a>불리언 타입으로 변환</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"string\">&#x27;&#x27;</span>) <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br></pre></td></tr></table></figure>\n\n<p>if 문이나 for 문과 같은 제어문 또는 삼항 조건 연산자의 조건식은 불리언 값, 즉 논리적 참과 거짓으로 평가되어야 한느 표현식이다.<br>자바스크립트 엔진은 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환한다.</p>\n<p>이때 자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분한다.</p>\n<p>false로 평가되는 Falsy 값은 다음과 같다.</p>\n<ul>\n<li>false</li>\n<li>undefined</li>\n<li>null</li>\n<li>0, -0</li>\n<li>NaN</li>\n<li>‘’(빈 문자열)</li>\n</ul>\n<p>Falsy 값 외의 모든 값은 모두 true로 평가되는 Truthy 값이다.</p>\n<h2 id=\"명시적-타입-변환\"><a href=\"#명시적-타입-변환\" class=\"headerlink\" title=\"명시적 타입 변환\"></a>명시적 타입 변환</h2><p>개발자의 의도에 따라 명시적으로 타입을 변경하는 방법은 다양하다.<br>표준 빌트인 생성자 함수(String, Number, Boolean)을 new 연산자 없이 호출하는 방법과 빌트인 메서드를 사용하는 방법, 그리고 앞서 살펴본 암묵적 타입 변환을 이용하는 방법이 있다.</p>\n<h3 id=\"문자열-타입으로-변환-1\"><a href=\"#문자열-타입으로-변환-1\" class=\"headerlink\" title=\"문자열 타입으로 변환\"></a>문자열 타입으로 변환</h3><p>문자열 타입이 아닌 값을 문자열 타입으로 변환하는 방법은 다음과 같다.</p>\n<ul>\n<li>String 생성자 함수를 new 연산자 없이 호출</li>\n<li>Object.prototype.toString 메서드를 사용</li>\n<li>문자열 연결 연산자를 이용</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">String</span>(<span class=\"number\">1</span>); <span class=\"comment\">// &#x27;1&#x27;</span></span><br><span class=\"line\"><span class=\"title class_\">String</span>(<span class=\"title class_\">NaN</span>); <span class=\"comment\">// &#x27;NaN&#x27;</span></span><br><span class=\"line\"><span class=\"title class_\">String</span>(<span class=\"literal\">true</span>); <span class=\"comment\">// &#x27;true&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"number\">1</span>).<span class=\"title function_\">toString</span>(); <span class=\"comment\">// &#x27;1&#x27;</span></span><br><span class=\"line\"><span class=\"title class_\">NaN</span>.<span class=\"title function_\">toString</span>(); <span class=\"comment\">// &#x27;NaN&#x27;</span></span><br><span class=\"line\"><span class=\"literal\">true</span>.<span class=\"title function_\">toString</span>(); <span class=\"comment\">// &#x27;true&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span> + <span class=\"string\">&#x27;&#x27;</span>; <span class=\"comment\">// &#x27;1&#x27;</span></span><br><span class=\"line\"><span class=\"title class_\">NaN</span> + <span class=\"string\">&#x27;&#x27;</span>; <span class=\"comment\">// &#x27;NaN&#x27;</span></span><br><span class=\"line\"><span class=\"literal\">true</span> + <span class=\"string\">&#x27;&#x27;</span>; <span class=\"comment\">// &#x27;true&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"숫자-타입으로-변환-1\"><a href=\"#숫자-타입으로-변환-1\" class=\"headerlink\" title=\"숫자 타입으로 변환\"></a>숫자 타입으로 변환</h3><p>숫자 타입이 아닌 값을 숫자 타입으로 변환하는 방법은 다음과 같다.</p>\n<ul>\n<li>Number 생성자 함수를 new 연산자 없이 호출</li>\n<li>parseInt, parseFloat 함수를 사용(문자열만 숫자 타입으로 변환 가능)</li>\n<li>+ 단항 산술 연산자를 이용</li>\n<li>* 산술 연산자를 이용</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Number</span>(<span class=\"string\">&#x27;0&#x27;</span>); <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>(<span class=\"string\">&#x27;10.53&#x27;</span>); <span class=\"comment\">// 10.53</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>(<span class=\"literal\">true</span>); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;0&#x27;</span>); <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">parseFloat</span>(<span class=\"string\">&#x27;10.53&#x27;</span>); <span class=\"comment\">// 10.53</span></span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"string\">&#x27;0&#x27;</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\">+<span class=\"string\">&#x27;10.53&#x27;</span>; <span class=\"comment\">// 10.53</span></span><br><span class=\"line\"><span class=\"literal\">true</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&#x27;0&#x27;</span> * <span class=\"number\">1</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"string\">&#x27;10.53&#x27;</span> * <span class=\"number\">1</span>; <span class=\"comment\">// 10.53</span></span><br><span class=\"line\"><span class=\"literal\">true</span> * <span class=\"number\">1</span>; <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"불리언-타입으로-변환-1\"><a href=\"#불리언-타입으로-변환-1\" class=\"headerlink\" title=\"불리언 타입으로 변환\"></a>불리언 타입으로 변환</h3><p>불리언 타입이 아닌 값을 불리언 타입으로 변환하는 방법은 다음과 같다.</p>\n<ul>\n<li>Boolean 생성자 함수를 new 연산자 없이 호출</li>\n<li>부정 논리 연산자(!)를 두전 사용</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Boolean</span>(<span class=\"string\">&#x27;x&#x27;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>(<span class=\"string\">&#x27;&#x27;</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>(&#123;&#125;); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">!!<span class=\"string\">&#x27;x&#x27;</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\">!!<span class=\"string\">&#x27;&#x27;</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\">!!&#123;&#125;; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"단축-평가\"><a href=\"#단축-평가\" class=\"headerlink\" title=\"단축 평가\"></a>단축 평가</h2><p>이전에 연산자를 공부하면서 논리합(||) 연산자와 논리곱(&amp;&amp;) 연산자에 대해 살펴 본 적이 있다.<br>논리합(||) 또는 논리곱(&amp;&amp;) 연산자 표현식은 언제나 2개의 피연산자 중 한쪽으로 평가되는데 이를 설명하기 위해서는 암묵적 타입 변환을 알아야 한다.<br>앞서 암묵적 타입 변환에 대해 살펴보았으니 이에 대해 알아보자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&#x27;Cat&#x27;</span> &amp;&amp; <span class=\"string\">&#x27;Dog&#x27;</span>; <span class=\"comment\">// &#x27;Dog&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>논리곱(&amp;&amp;) 연산자는 두 개의 피연산자가 모두 true로 평가될 때 true를 반환한다. 논리곱 연산자는 좌항에서 우항으로 평가가 진행된다.</p>\n<p>첫 번째 피연산자 ‘Cat’은 Truthy 값이므로 true로 평가된다. 하지만 이 시점까지는 위 표현식을 평가할 수 없다.<br>두 번째 피연산자까지 평가해 보아야 위 표현식을 평가할 수 있다. 즉 두 번째 피연산자가 논리곱 연산자 표현식의 평가 결과를 결정한다.<br>이때 논리곱 연산자는 논리 연산의 결과를 결정하는 두 번째 피연산자 문자열 ‘Dog’를 타입 변환 없이 그대로 반환한다.</p>\n<p>논리합(||) 연산자도 논리곱(&amp;&amp;) 연산자와 동일하게 동작한다.</p>\n<p>논리곱(&amp;&amp;) 연산자와 논리합(||) 연산자는 이처럼 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환한다.<br>이를 단축평가라 한다. 단축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말한다.</p>\n<p>단축 평가를 사용하면 if 문을 대체할 수 있다. 어떤 조건이 Truthy 값일 때 무언가를 해야 한다면 논리곱(&amp;&amp;) 연산자를, 어떤 조건이 Falsy 값일 때 무언가를 해야 한다면 논리합(||) 연산자를 이용할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> done = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (done) message = <span class=\"string\">&#x27;완료&#x27;</span>;</span><br><span class=\"line\">message = done &amp;&amp; <span class=\"string\">&#x27;완료&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(message); <span class=\"comment\">// 완료</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> done = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (done) message = <span class=\"string\">&#x27;미완료&#x27;</span>;</span><br><span class=\"line\">message = done || <span class=\"string\">&#x27;미완료&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(message); <span class=\"comment\">// 미완료</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"옵셔널-체이닝-연산자\"><a href=\"#옵셔널-체이닝-연산자\" class=\"headerlink\" title=\"옵셔널 체이닝 연산자\"></a>옵셔널 체이닝 연산자</h3><p>ES11에서 도입된 옵셔널 체이닝 연산자 ?.는 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> elem = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> value = elem?.<span class=\"property\">value</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>옵셔널 체이닝 연산자는 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때 유용하다.<br>옵셔널 체이닝 연산자가 도입되기 이전에는 논리곱 연산자를 사용한 단축 평가를 통해 변수가 null 또는 undefined인지 확인했다.</p>\n<p>논리곱 연산자는 좌항의 피연산자가 Falsy 값이면 좌항 피연산자를 그대로 반환한다. 좌항 피연산자가 Falsy 값인 0이나 ‘’인 경우도 마찬가지다.<br>하지만 0이나 ‘’은 객체로 평가될 때도 있다. 옵셔널 체이닝 연산자는 좌항 피연산자가 Falsy 값이라도 null 또는 undefined가 아니면 우항의 프로퍼티 참조를 이어간다는 차이점이 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> length1 = str &amp;&amp; str.<span class=\"property\">length</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> length2 = str?.<span class=\"property\">length</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(length1); <span class=\"comment\">// &#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(length2); <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"null-병합-연산자\"><a href=\"#null-병합-연산자\" class=\"headerlink\" title=\"null 병합 연산자\"></a>null 병합 연산자</h3><p>ES11에서 도입된 null 병합 연산자 ??는 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"literal\">null</span> ?? <span class=\"string\">&#x27;default string&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(foo); <span class=\"comment\">// &#x27;default string&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>null 병합 연산자는 변수에 기본값을 설정할 때 유용하다. null 병합 연산자가 도입되기 이전에는 논리합 연산자를 사용한 단축 평가를 통해 변수에 기본값을 설정했다.</p>\n<p>논리합 연산자는 좌항의 피연산자가 Falsy 값이면 우항의 피연산자를 반환한다. 만약 Falsy 값인 0이나 ‘’도 기본값으로 유효하다면 예기치 않은 동작이 발생할 수 있다. 하지만 null 병합 연산자는 좌항의 피연산자가 Falsy 값이라도 null 또는 undefined가 아니면 좌항의 피연산자를 그대로 반환한다는 차이점이 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo1 = <span class=\"string\">&#x27;&#x27;</span> || <span class=\"string\">&#x27;default string&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo2 = <span class=\"string\">&#x27;&#x27;</span> ?? <span class=\"string\">&#x27;default string&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(foo1); <span class=\"comment\">// &#x27;default string&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(foo2); <span class=\"comment\">// &#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n"},{"title":"Sass Basic","date":"2022-09-13T14:05:15.000Z","_content":"# Sass?\n\nCSS를 사용해 웹 애플리케이션 스타일을 관리하는 것은 애플리케이션 규모가 커지고 복잡해질수록 매우 어렵다.\n\n반면 Sass와 같은 프리프로세서(Pre-Processor, 전처리기)를 사용하면 매우 효과적으로 복잡한 애플리케이션 스타일을 관리할 수 있다.\n\nSass란 Syntactically Awesome Style Sheets의 준말로 CSS가 아직은 할 수 없는 다양한 기능(중첩, 함수, 믹스인, 상속 등)을 제공한다.\n\nSass말고도 Stylus, Less와 같은 전처리기가 존재하지만 현재 Sass가 통계상 가장 사용자가 많으면서 만족도가 높아 배웠을 때 가장 유용하다고 할 수 있다. ([설문결과](https://2021.stateofcss.com/ko-KR/technologies/#scatterplot_overview))\n\n<hr>\n\n## 설치\n\nSass를 이용하기 위해선 먼저 설치를 해야한다. [공식사이트](https://sass-lang.com/install)를 참고해 다양한 방식으로 설치가 가능하다. 나는 Node.js를 이용하고 있기에 npm을 통해 설치해 주었다.\n```bash\nnpm install -g sass\n```\n\n## 컴파일\nSass를 설치해 이용하고자 할 때, 웹 브라우저는 Sass파일을 해석할 수 없기에 Sass파일을 CSS파일로 변경해야 한다. 이를 컴파일이라 하는데 다음과 같이 사용 가능하다.\n```bash\nsass input.scss output.css\n```\n단일 파일이 아니라 폴더 단위의 변경을 처리한다면 `:`을 이용할 수 있다.\n```bash\nsass src/scss:public/css\n```\n더 많은 옵션은 [Dart Sass CLI](https://sass-lang.com/documentation/cli/dart-sass)를 참고할 수 있다.\n\n<hr>\n\n## 문법\nSass파일은 사용하는 문법에 따라 `.scss`의 확장자를 가진 SCSS 구문과 `.sass`를 가진 Sass구문 2가지로 나뉜다.\n\n### Sass 구문\n\nSass 구문은 중괄호, 세미콜론을 생략하고 들여쓰기 문법을 사용한다. 좀 더 간결하고 작성하기 편리하며 `{}`나 `;`를 사용하지 않아도 되어 코드가 깔끔하다.\n\n```sass\n.button\n\tcursor: pointer\n\t&:disabled\n\t\tcursor: not-allowed\n```\n\n### SCSS 구문\n\nSCSS 구문은 CSS와 유사한 문법을 사용한다. 인라인 코드를 작성할 수 있고, CSS와 유사한 문법을 가지기 때문에 코드 통합이 훨씬 쉽다.\n\n```scss\n.button {\n\tcursor: pointer;\n\t&:disabled {\n\t  cursor: not-allowed;\n\t}\n}\n```\n\n서로 장단점이 있기 때문에 회사나 팀에서 원하는 방식 혹은 개인의 취향에 따라서 선택할 수 있다. 일반적으로 CSS 구문과 문제없이 호환되는 SCSS구문이 많이 사용된다.\n\n<hr>\n\n## Sass Basics\n수업을 들으면서 Sass의 두 가지 구문중 SCSS를 사용했기에 Sass Basics에 대해 SCSS를 이용한 방법으로 정리하겠다.\n\n### 변수(Variables)\nCSS도 변수 사용이 가능하지만 Sass에서는 `$`를 이용해 더 쉽게 변수를 사용할 수 있다.\n\n**CSS 변수**\n\n```css\n:root {\n  --spacing-1: 4px;\n  --spacing-2: 8px;\n  --primary-400: hsl(250, 75%, 60%);\n  --primary-500: hsl(250, 75%, 50%);\n}\n\n.container {\n  margin-top: var(--spacing-2);\n  color: var(--primary-500);\n}\n```\n\n**SCSS 변수**\n\n```scss\n$spacing-1: 4px;\n$spacing-2: 8px;\n$primary-400: hsl(250, 75%, 60%);\n$primary-500: hsl(250, 75%, 50%);\n\n.container {\n  margin-top: $spacing-2;\n  color: $primary-500;\n}\n```\n\n### 중첩(Nesting)\nCSS는 HTML과 달리 시각적인 계층 구조와 명확히 중첩된 구문을 작성할 수 없다. 하지만 Sass는 HTML과 동일하게 시각적 계층 구조를 따르는 방식으로 스타일을 작성하는 방법을 지원한다.\n\n**CSS 구문**\n\n```css\nnav ul {\n  margin: 0;\n  padding: 0;\n  list-style: none;\n}\nnav li {\n  display: inline-block;\n}\nnav a {\n  display: block;\n  padding: 6px 12px;\n  text-decoration: none;\n}\n```\n\n**SCSS 구문**\n\n```scss\nnav {\n  ul {\n    margin: 0;\n    padding: 0;\n    list-style: none;\n  }\n\n  li { display: inline-block; }\n\n  a {\n    display: block;\n    padding: 6px 12px;\n    text-decoration: none;\n  }\n}\n```\n\nSass 중첩 구문은 시각적으로 계층 구조를 파악할 수 있어 CSS 보다 직관성이 높다. 하지만 많은 중첩은 오히려 복잡성을 증가시켜 가독성이 떨어지므로 피해야한다.\n\n### 모듈(modules)\n\n모듈은 독립적으로 묶인 작은 코드 조각으로, Sass는 관심사에 따라 여러 조각의 코드로 묶인 파일을 관리할 수 있는 기능인 모듈화를 제공한다. 모듈은 애플리케이션 스타일을 유지 관리하기 쉽게 만들어 주는 매우 효과적인 방법이다.\n\nSass(정확히는 Dart Sass)에서는 `@import rule`대신 `@use`를 이용해 다른 스타일 모듈을 불러올 수 있다. Sass 파일 확장자와 언더스코어(_)는 생략 가능하다.\n\n**_base.scss**\n```scss\n$font-stack: Helvetica, sans-serif;\n$primary-color: #333;\n\nbody {\n  font: 100% $font-stack;\n  color: $primary-color;\n}\n```\n불러온 모듈은 기본적으로 파일 이름을 네임스페이스(namespace)로 가지며 점(.) 문법을 사용해 모듈의 변수 등에 접근할 수 있다.\n\n**styles.scss**\n\n```scss\n@use 'base';\n\n.inverse {\n  background-color: base.$primary-color;\n  color: white;\n}\n```\n네임스페이스 이름을 다른 이름으로 변경해 사용하고자 할 경우 as를 사용한다. 특히 as에 별(*) 기호를 사용할 경우 네임스페이스 없이 바로 모듈에서 내보낸 변수를 사용할 수 있다.\n\n```scss\n@use 'base' as *;\n\n.inverse {\n  background-color: $primary-color;\n  color: white;\n}\n```\n\n\n**CSS**\n\n```css\nbody {\n  font: 100% Helvetica, sans-serif;\n  color: #333;\n}\n\n.inverse {\n  background-color: #333;\n  color: white;\n}\n```\n\n### 믹스인(mixins)\n\nCSS는 코드를 재사용 할 수 있는 기능이 제공되지 않기 때문에 코드 중복이 잦은 언어이다. 하지만 Sass는 코드를 효율적으로 재사용할 수 있도록 믹스인 기능을 제공한다. 믹스인을 이용해 재사용할 코드 그룹을  선언할 수 있다.\n\n**SCSS**\n```scss\n@mixin theme($theme: DarkGray) {\n  background: $theme;\n  box-shadow: 0 0 1px rgba($theme, .25);\n  color: #fff;\n}\n\n.info {\n  @include theme;\n}\n.alert {\n  @include theme($theme: DarkRed);\n}\n.success {\n  @include theme($theme: DarkGreen);\n}\n```\n\n**CSS**\n\n```css\n.info {\n  background: DarkGray;\n  box-shadow: 0 0 1px rgba(169, 169, 169, 0.25);\n  color: #fff;\n}\n\n.alert {\n  background: DarkRed;\n  box-shadow: 0 0 1px rgba(139, 0, 0, 0.25);\n  color: #fff;\n}\n\n.success {\n  background: DarkGreen;\n  box-shadow: 0 0 1px rgba(0, 100, 0, 0.25);\n  color: #fff;\n}\n```\n`@mixin`과 이름을 통해 믹스인을 만들 수 있다. 믹스인을 만든 후에는 `@include`와 이름을 선언해 믹스인을 이용 할 수 있다. 또한 믹스인은 JavaScript 함수처럼 매개변수를 설정할 수 있는데, 매개변수를 사용하면 믹스인 외부에서 사용자가 전달한 값을 믹스인 내부에서 사용해 재사용성을 더 높여줄 수 있다.\n\n### 확장/상속 (extend/inheritance)\n\n선택자 이름 앞에 `%`를 사용해 선언한 플레이스홀더 클래스는 스타일을 확장할 때만 사용되는 특수한 유형의 클래스로 여러 선택자에서 공유할 수 있다. 스타일 집합을 공유할 때는 `@extend`를 사용한다.\n\n이 방법은 스타일 코드를 반복 생성하는 믹스인과 달리, 스타일 코드 집합 하나를 재사용하는데 목적을 두고 있어 보다 코드를 깨끗하게 유지하는데 도움이 될 수 있다.\n\n**SCSS**\n```scss\n%message-shared {\n  border: 1px solid #ccc;\n  padding: 10px;\n  color: #333;\n}\n\n.message {\n  @extend %message-shared;\n}\n\n.success {\n  @extend %message-shared;\n  border-color: green;\n}\n\n.error {\n  @extend %message-shared;\n  border-color: red;\n}\n\n.warning {\n  @extend %message-shared;\n  border-color: yellow;\n}\n```\n\n**CSS**\n\n```css\n.message, .success, .error, .warning {\n  border: 1px solid #ccc;\n  padding: 10px;\n  color: #333;\n}\n\n.success {\n  border-color: green;\n}\n\n.error {\n  border-color: red;\n}\n\n.warning {\n  border-color: yellow;\n}\n```\n\n### 연산자 (operators)\n\nCSS에서 수학은 매우 유용하다. Sass는 산술연산자(`+`, `-`, `*`, `%`) 및 수학 함수(예: `math.div()`)를 제공한다.\n\n**SCSS**\n```scss\n@use \"sass:math\";\n\n.container {\n  display: flex;\n}\n\narticle[role=\"main\"] {\n  width: math.div(600px, 960px) * 100%;\n}\n\naside[role=\"complementary\"] {\n  width: math.div(300px, 960px) * 100%;\n  margin-left: auto;\n}\n```\n\n**CSS**\n\n```css\n.container {\n  display: flex;\n}\n\narticle[role=\"main\"] {\n  width: 62.5%;\n}\n\naside[role=\"complementary\"] {\n  width: 31.25%;\n  margin-left: auto;\n}\n```\n특히 `math.div()`를 이용하기 위해서는 `@use \"sass:math\"`를 이용해 Sass에서 기본으로 제공하는 math 모듈을 불러와야 한다. 이때 as *를 이용해 사용한다면 div 태그와 구분이 가지 않으므로 `math.div()`의 기본 형태로 사용하는 것이 추천된다.\n\n<hr>\n\n# 참고\n- https://sass-lang.com/guide\n- https://euid.notion.site/euid/Sass-04a97ad611cc4436a9f09e9ff052b183\n- https://heropy.blog/2018/01/31/sass/\n","source":"_posts/Sass-Basic.md","raw":"---\ntitle: Sass Basic\ndate: 2022-09-13 23:05:15\ntags:\n- 개발\n- Sass\n---\n# Sass?\n\nCSS를 사용해 웹 애플리케이션 스타일을 관리하는 것은 애플리케이션 규모가 커지고 복잡해질수록 매우 어렵다.\n\n반면 Sass와 같은 프리프로세서(Pre-Processor, 전처리기)를 사용하면 매우 효과적으로 복잡한 애플리케이션 스타일을 관리할 수 있다.\n\nSass란 Syntactically Awesome Style Sheets의 준말로 CSS가 아직은 할 수 없는 다양한 기능(중첩, 함수, 믹스인, 상속 등)을 제공한다.\n\nSass말고도 Stylus, Less와 같은 전처리기가 존재하지만 현재 Sass가 통계상 가장 사용자가 많으면서 만족도가 높아 배웠을 때 가장 유용하다고 할 수 있다. ([설문결과](https://2021.stateofcss.com/ko-KR/technologies/#scatterplot_overview))\n\n<hr>\n\n## 설치\n\nSass를 이용하기 위해선 먼저 설치를 해야한다. [공식사이트](https://sass-lang.com/install)를 참고해 다양한 방식으로 설치가 가능하다. 나는 Node.js를 이용하고 있기에 npm을 통해 설치해 주었다.\n```bash\nnpm install -g sass\n```\n\n## 컴파일\nSass를 설치해 이용하고자 할 때, 웹 브라우저는 Sass파일을 해석할 수 없기에 Sass파일을 CSS파일로 변경해야 한다. 이를 컴파일이라 하는데 다음과 같이 사용 가능하다.\n```bash\nsass input.scss output.css\n```\n단일 파일이 아니라 폴더 단위의 변경을 처리한다면 `:`을 이용할 수 있다.\n```bash\nsass src/scss:public/css\n```\n더 많은 옵션은 [Dart Sass CLI](https://sass-lang.com/documentation/cli/dart-sass)를 참고할 수 있다.\n\n<hr>\n\n## 문법\nSass파일은 사용하는 문법에 따라 `.scss`의 확장자를 가진 SCSS 구문과 `.sass`를 가진 Sass구문 2가지로 나뉜다.\n\n### Sass 구문\n\nSass 구문은 중괄호, 세미콜론을 생략하고 들여쓰기 문법을 사용한다. 좀 더 간결하고 작성하기 편리하며 `{}`나 `;`를 사용하지 않아도 되어 코드가 깔끔하다.\n\n```sass\n.button\n\tcursor: pointer\n\t&:disabled\n\t\tcursor: not-allowed\n```\n\n### SCSS 구문\n\nSCSS 구문은 CSS와 유사한 문법을 사용한다. 인라인 코드를 작성할 수 있고, CSS와 유사한 문법을 가지기 때문에 코드 통합이 훨씬 쉽다.\n\n```scss\n.button {\n\tcursor: pointer;\n\t&:disabled {\n\t  cursor: not-allowed;\n\t}\n}\n```\n\n서로 장단점이 있기 때문에 회사나 팀에서 원하는 방식 혹은 개인의 취향에 따라서 선택할 수 있다. 일반적으로 CSS 구문과 문제없이 호환되는 SCSS구문이 많이 사용된다.\n\n<hr>\n\n## Sass Basics\n수업을 들으면서 Sass의 두 가지 구문중 SCSS를 사용했기에 Sass Basics에 대해 SCSS를 이용한 방법으로 정리하겠다.\n\n### 변수(Variables)\nCSS도 변수 사용이 가능하지만 Sass에서는 `$`를 이용해 더 쉽게 변수를 사용할 수 있다.\n\n**CSS 변수**\n\n```css\n:root {\n  --spacing-1: 4px;\n  --spacing-2: 8px;\n  --primary-400: hsl(250, 75%, 60%);\n  --primary-500: hsl(250, 75%, 50%);\n}\n\n.container {\n  margin-top: var(--spacing-2);\n  color: var(--primary-500);\n}\n```\n\n**SCSS 변수**\n\n```scss\n$spacing-1: 4px;\n$spacing-2: 8px;\n$primary-400: hsl(250, 75%, 60%);\n$primary-500: hsl(250, 75%, 50%);\n\n.container {\n  margin-top: $spacing-2;\n  color: $primary-500;\n}\n```\n\n### 중첩(Nesting)\nCSS는 HTML과 달리 시각적인 계층 구조와 명확히 중첩된 구문을 작성할 수 없다. 하지만 Sass는 HTML과 동일하게 시각적 계층 구조를 따르는 방식으로 스타일을 작성하는 방법을 지원한다.\n\n**CSS 구문**\n\n```css\nnav ul {\n  margin: 0;\n  padding: 0;\n  list-style: none;\n}\nnav li {\n  display: inline-block;\n}\nnav a {\n  display: block;\n  padding: 6px 12px;\n  text-decoration: none;\n}\n```\n\n**SCSS 구문**\n\n```scss\nnav {\n  ul {\n    margin: 0;\n    padding: 0;\n    list-style: none;\n  }\n\n  li { display: inline-block; }\n\n  a {\n    display: block;\n    padding: 6px 12px;\n    text-decoration: none;\n  }\n}\n```\n\nSass 중첩 구문은 시각적으로 계층 구조를 파악할 수 있어 CSS 보다 직관성이 높다. 하지만 많은 중첩은 오히려 복잡성을 증가시켜 가독성이 떨어지므로 피해야한다.\n\n### 모듈(modules)\n\n모듈은 독립적으로 묶인 작은 코드 조각으로, Sass는 관심사에 따라 여러 조각의 코드로 묶인 파일을 관리할 수 있는 기능인 모듈화를 제공한다. 모듈은 애플리케이션 스타일을 유지 관리하기 쉽게 만들어 주는 매우 효과적인 방법이다.\n\nSass(정확히는 Dart Sass)에서는 `@import rule`대신 `@use`를 이용해 다른 스타일 모듈을 불러올 수 있다. Sass 파일 확장자와 언더스코어(_)는 생략 가능하다.\n\n**_base.scss**\n```scss\n$font-stack: Helvetica, sans-serif;\n$primary-color: #333;\n\nbody {\n  font: 100% $font-stack;\n  color: $primary-color;\n}\n```\n불러온 모듈은 기본적으로 파일 이름을 네임스페이스(namespace)로 가지며 점(.) 문법을 사용해 모듈의 변수 등에 접근할 수 있다.\n\n**styles.scss**\n\n```scss\n@use 'base';\n\n.inverse {\n  background-color: base.$primary-color;\n  color: white;\n}\n```\n네임스페이스 이름을 다른 이름으로 변경해 사용하고자 할 경우 as를 사용한다. 특히 as에 별(*) 기호를 사용할 경우 네임스페이스 없이 바로 모듈에서 내보낸 변수를 사용할 수 있다.\n\n```scss\n@use 'base' as *;\n\n.inverse {\n  background-color: $primary-color;\n  color: white;\n}\n```\n\n\n**CSS**\n\n```css\nbody {\n  font: 100% Helvetica, sans-serif;\n  color: #333;\n}\n\n.inverse {\n  background-color: #333;\n  color: white;\n}\n```\n\n### 믹스인(mixins)\n\nCSS는 코드를 재사용 할 수 있는 기능이 제공되지 않기 때문에 코드 중복이 잦은 언어이다. 하지만 Sass는 코드를 효율적으로 재사용할 수 있도록 믹스인 기능을 제공한다. 믹스인을 이용해 재사용할 코드 그룹을  선언할 수 있다.\n\n**SCSS**\n```scss\n@mixin theme($theme: DarkGray) {\n  background: $theme;\n  box-shadow: 0 0 1px rgba($theme, .25);\n  color: #fff;\n}\n\n.info {\n  @include theme;\n}\n.alert {\n  @include theme($theme: DarkRed);\n}\n.success {\n  @include theme($theme: DarkGreen);\n}\n```\n\n**CSS**\n\n```css\n.info {\n  background: DarkGray;\n  box-shadow: 0 0 1px rgba(169, 169, 169, 0.25);\n  color: #fff;\n}\n\n.alert {\n  background: DarkRed;\n  box-shadow: 0 0 1px rgba(139, 0, 0, 0.25);\n  color: #fff;\n}\n\n.success {\n  background: DarkGreen;\n  box-shadow: 0 0 1px rgba(0, 100, 0, 0.25);\n  color: #fff;\n}\n```\n`@mixin`과 이름을 통해 믹스인을 만들 수 있다. 믹스인을 만든 후에는 `@include`와 이름을 선언해 믹스인을 이용 할 수 있다. 또한 믹스인은 JavaScript 함수처럼 매개변수를 설정할 수 있는데, 매개변수를 사용하면 믹스인 외부에서 사용자가 전달한 값을 믹스인 내부에서 사용해 재사용성을 더 높여줄 수 있다.\n\n### 확장/상속 (extend/inheritance)\n\n선택자 이름 앞에 `%`를 사용해 선언한 플레이스홀더 클래스는 스타일을 확장할 때만 사용되는 특수한 유형의 클래스로 여러 선택자에서 공유할 수 있다. 스타일 집합을 공유할 때는 `@extend`를 사용한다.\n\n이 방법은 스타일 코드를 반복 생성하는 믹스인과 달리, 스타일 코드 집합 하나를 재사용하는데 목적을 두고 있어 보다 코드를 깨끗하게 유지하는데 도움이 될 수 있다.\n\n**SCSS**\n```scss\n%message-shared {\n  border: 1px solid #ccc;\n  padding: 10px;\n  color: #333;\n}\n\n.message {\n  @extend %message-shared;\n}\n\n.success {\n  @extend %message-shared;\n  border-color: green;\n}\n\n.error {\n  @extend %message-shared;\n  border-color: red;\n}\n\n.warning {\n  @extend %message-shared;\n  border-color: yellow;\n}\n```\n\n**CSS**\n\n```css\n.message, .success, .error, .warning {\n  border: 1px solid #ccc;\n  padding: 10px;\n  color: #333;\n}\n\n.success {\n  border-color: green;\n}\n\n.error {\n  border-color: red;\n}\n\n.warning {\n  border-color: yellow;\n}\n```\n\n### 연산자 (operators)\n\nCSS에서 수학은 매우 유용하다. Sass는 산술연산자(`+`, `-`, `*`, `%`) 및 수학 함수(예: `math.div()`)를 제공한다.\n\n**SCSS**\n```scss\n@use \"sass:math\";\n\n.container {\n  display: flex;\n}\n\narticle[role=\"main\"] {\n  width: math.div(600px, 960px) * 100%;\n}\n\naside[role=\"complementary\"] {\n  width: math.div(300px, 960px) * 100%;\n  margin-left: auto;\n}\n```\n\n**CSS**\n\n```css\n.container {\n  display: flex;\n}\n\narticle[role=\"main\"] {\n  width: 62.5%;\n}\n\naside[role=\"complementary\"] {\n  width: 31.25%;\n  margin-left: auto;\n}\n```\n특히 `math.div()`를 이용하기 위해서는 `@use \"sass:math\"`를 이용해 Sass에서 기본으로 제공하는 math 모듈을 불러와야 한다. 이때 as *를 이용해 사용한다면 div 태그와 구분이 가지 않으므로 `math.div()`의 기본 형태로 사용하는 것이 추천된다.\n\n<hr>\n\n# 참고\n- https://sass-lang.com/guide\n- https://euid.notion.site/euid/Sass-04a97ad611cc4436a9f09e9ff052b183\n- https://heropy.blog/2018/01/31/sass/\n","slug":"Sass-Basic","published":1,"updated":"2022-10-11T14:06:51.610Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb08iq6j000pe4vkfto41tb8","content":"<h1 id=\"Sass\"><a href=\"#Sass\" class=\"headerlink\" title=\"Sass?\"></a>Sass?</h1><p>CSS를 사용해 웹 애플리케이션 스타일을 관리하는 것은 애플리케이션 규모가 커지고 복잡해질수록 매우 어렵다.</p>\n<p>반면 Sass와 같은 프리프로세서(Pre-Processor, 전처리기)를 사용하면 매우 효과적으로 복잡한 애플리케이션 스타일을 관리할 수 있다.</p>\n<p>Sass란 Syntactically Awesome Style Sheets의 준말로 CSS가 아직은 할 수 없는 다양한 기능(중첩, 함수, 믹스인, 상속 등)을 제공한다.</p>\n<p>Sass말고도 Stylus, Less와 같은 전처리기가 존재하지만 현재 Sass가 통계상 가장 사용자가 많으면서 만족도가 높아 배웠을 때 가장 유용하다고 할 수 있다. (<a href=\"https://2021.stateofcss.com/ko-KR/technologies/#scatterplot_overview\">설문결과</a>)</p>\n<hr>\n\n<h2 id=\"설치\"><a href=\"#설치\" class=\"headerlink\" title=\"설치\"></a>설치</h2><p>Sass를 이용하기 위해선 먼저 설치를 해야한다. <a href=\"https://sass-lang.com/install\">공식사이트</a>를 참고해 다양한 방식으로 설치가 가능하다. 나는 Node.js를 이용하고 있기에 npm을 통해 설치해 주었다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g sass</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"컴파일\"><a href=\"#컴파일\" class=\"headerlink\" title=\"컴파일\"></a>컴파일</h2><p>Sass를 설치해 이용하고자 할 때, 웹 브라우저는 Sass파일을 해석할 수 없기에 Sass파일을 CSS파일로 변경해야 한다. 이를 컴파일이라 하는데 다음과 같이 사용 가능하다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sass input.scss output.css</span><br></pre></td></tr></table></figure>\n<p>단일 파일이 아니라 폴더 단위의 변경을 처리한다면 <code>:</code>을 이용할 수 있다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sass src/scss:public/css</span><br></pre></td></tr></table></figure>\n<p>더 많은 옵션은 <a href=\"https://sass-lang.com/documentation/cli/dart-sass\">Dart Sass CLI</a>를 참고할 수 있다.</p>\n<hr>\n\n<h2 id=\"문법\"><a href=\"#문법\" class=\"headerlink\" title=\"문법\"></a>문법</h2><p>Sass파일은 사용하는 문법에 따라 <code>.scss</code>의 확장자를 가진 SCSS 구문과 <code>.sass</code>를 가진 Sass구문 2가지로 나뉜다.</p>\n<h3 id=\"Sass-구문\"><a href=\"#Sass-구문\" class=\"headerlink\" title=\"Sass 구문\"></a>Sass 구문</h3><p>Sass 구문은 중괄호, 세미콜론을 생략하고 들여쓰기 문법을 사용한다. 좀 더 간결하고 작성하기 편리하며 <code>&#123;&#125;</code>나 <code>;</code>를 사용하지 않아도 되어 코드가 깔끔하다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.button</span><br><span class=\"line\">\tcursor: pointer</span><br><span class=\"line\">\t&amp;:disabled</span><br><span class=\"line\">\t\tcursor: not-allowed</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SCSS-구문\"><a href=\"#SCSS-구문\" class=\"headerlink\" title=\"SCSS 구문\"></a>SCSS 구문</h3><p>SCSS 구문은 CSS와 유사한 문법을 사용한다. 인라인 코드를 작성할 수 있고, CSS와 유사한 문법을 가지기 때문에 코드 통합이 훨씬 쉽다.</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.button</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">cursor</span>: pointer;</span><br><span class=\"line\">\t&amp;<span class=\"selector-pseudo\">:disabled</span> &#123;</span><br><span class=\"line\">\t  <span class=\"attribute\">cursor</span>: not-allowed;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>서로 장단점이 있기 때문에 회사나 팀에서 원하는 방식 혹은 개인의 취향에 따라서 선택할 수 있다. 일반적으로 CSS 구문과 문제없이 호환되는 SCSS구문이 많이 사용된다.</p>\n<hr>\n\n<h2 id=\"Sass-Basics\"><a href=\"#Sass-Basics\" class=\"headerlink\" title=\"Sass Basics\"></a>Sass Basics</h2><p>수업을 들으면서 Sass의 두 가지 구문중 SCSS를 사용했기에 Sass Basics에 대해 SCSS를 이용한 방법으로 정리하겠다.</p>\n<h3 id=\"변수-Variables\"><a href=\"#변수-Variables\" class=\"headerlink\" title=\"변수(Variables)\"></a>변수(Variables)</h3><p>CSS도 변수 사용이 가능하지만 Sass에서는 <code>$</code>를 이용해 더 쉽게 변수를 사용할 수 있다.</p>\n<p><strong>CSS 변수</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-pseudo\">:root</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">--spacing-1</span>: <span class=\"number\">4px</span>;</span><br><span class=\"line\">  <span class=\"attr\">--spacing-2</span>: <span class=\"number\">8px</span>;</span><br><span class=\"line\">  <span class=\"attr\">--primary-400</span>: <span class=\"built_in\">hsl</span>(<span class=\"number\">250</span>, <span class=\"number\">75%</span>, <span class=\"number\">60%</span>);</span><br><span class=\"line\">  <span class=\"attr\">--primary-500</span>: <span class=\"built_in\">hsl</span>(<span class=\"number\">250</span>, <span class=\"number\">75%</span>, <span class=\"number\">50%</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>: <span class=\"built_in\">var</span>(--spacing-<span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"built_in\">var</span>(--primary-<span class=\"number\">500</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>SCSS 변수</strong></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$spacing-1</span>: <span class=\"number\">4px</span>;</span><br><span class=\"line\"><span class=\"variable\">$spacing-2</span>: <span class=\"number\">8px</span>;</span><br><span class=\"line\"><span class=\"variable\">$primary-400</span>: <span class=\"built_in\">hsl</span>(<span class=\"number\">250</span>, <span class=\"number\">75%</span>, <span class=\"number\">60%</span>);</span><br><span class=\"line\"><span class=\"variable\">$primary-500</span>: <span class=\"built_in\">hsl</span>(<span class=\"number\">250</span>, <span class=\"number\">75%</span>, <span class=\"number\">50%</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>: <span class=\"variable\">$spacing-2</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"variable\">$primary-500</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"중첩-Nesting\"><a href=\"#중첩-Nesting\" class=\"headerlink\" title=\"중첩(Nesting)\"></a>중첩(Nesting)</h3><p>CSS는 HTML과 달리 시각적인 계층 구조와 명확히 중첩된 구문을 작성할 수 없다. 하지만 Sass는 HTML과 동일하게 시각적 계층 구조를 따르는 방식으로 스타일을 작성하는 방법을 지원한다.</p>\n<p><strong>CSS 구문</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">ul</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">list-style</span>: none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">6px</span> <span class=\"number\">12px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">text-decoration</span>: none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>SCSS 구문</strong></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"selector-tag\">ul</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">list-style</span>: none;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"selector-tag\">li</span> &#123; <span class=\"attribute\">display</span>: inline-block; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">6px</span> <span class=\"number\">12px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">text-decoration</span>: none;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Sass 중첩 구문은 시각적으로 계층 구조를 파악할 수 있어 CSS 보다 직관성이 높다. 하지만 많은 중첩은 오히려 복잡성을 증가시켜 가독성이 떨어지므로 피해야한다.</p>\n<h3 id=\"모듈-modules\"><a href=\"#모듈-modules\" class=\"headerlink\" title=\"모듈(modules)\"></a>모듈(modules)</h3><p>모듈은 독립적으로 묶인 작은 코드 조각으로, Sass는 관심사에 따라 여러 조각의 코드로 묶인 파일을 관리할 수 있는 기능인 모듈화를 제공한다. 모듈은 애플리케이션 스타일을 유지 관리하기 쉽게 만들어 주는 매우 효과적인 방법이다.</p>\n<p>Sass(정확히는 Dart Sass)에서는 <code>@import rule</code>대신 <code>@use</code>를 이용해 다른 스타일 모듈을 불러올 수 있다. Sass 파일 확장자와 언더스코어(_)는 생략 가능하다.</p>\n<p><strong>_base.scss</strong></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$font-stack</span>: Helvetica, sans-serif;</span><br><span class=\"line\"><span class=\"variable\">$primary-color</span>: <span class=\"number\">#333</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font</span>: <span class=\"number\">100%</span> <span class=\"variable\">$font-stack</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"variable\">$primary-color</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>불러온 모듈은 기본적으로 파일 이름을 네임스페이스(namespace)로 가지며 점(.) 문법을 사용해 모듈의 변수 등에 접근할 수 있다.</p>\n<p><strong>styles.scss</strong></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@use</span> <span class=\"string\">&#x27;base&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.inverse</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: base.<span class=\"variable\">$primary-color</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: white;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>네임스페이스 이름을 다른 이름으로 변경해 사용하고자 할 경우 as를 사용한다. 특히 as에 별(*) 기호를 사용할 경우 네임스페이스 없이 바로 모듈에서 내보낸 변수를 사용할 수 있다.</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@use</span> <span class=\"string\">&#x27;base&#x27;</span> as *;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.inverse</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"variable\">$primary-color</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: white;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>CSS</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font</span>: <span class=\"number\">100%</span> Helvetica, sans-serif;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#333</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.inverse</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#333</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: white;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"믹스인-mixins\"><a href=\"#믹스인-mixins\" class=\"headerlink\" title=\"믹스인(mixins)\"></a>믹스인(mixins)</h3><p>CSS는 코드를 재사용 할 수 있는 기능이 제공되지 않기 때문에 코드 중복이 잦은 언어이다. 하지만 Sass는 코드를 효율적으로 재사용할 수 있도록 믹스인 기능을 제공한다. 믹스인을 이용해 재사용할 코드 그룹을  선언할 수 있다.</p>\n<p><strong>SCSS</strong></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@mixin</span> theme(<span class=\"variable\">$theme</span>: DarkGray) &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"variable\">$theme</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">1px</span> <span class=\"built_in\">rgba</span>(<span class=\"variable\">$theme</span>, .<span class=\"number\">25</span>);</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.info</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@include</span> theme;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.alert</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@include</span> theme(<span class=\"variable\">$theme</span>: DarkRed);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.success</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@include</span> theme(<span class=\"variable\">$theme</span>: DarkGreen);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>CSS</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.info</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: DarkGray;</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">1px</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">169</span>, <span class=\"number\">169</span>, <span class=\"number\">169</span>, <span class=\"number\">0.25</span>);</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.alert</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: DarkRed;</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">1px</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">139</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0.25</span>);</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.success</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: DarkGreen;</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">1px</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>, <span class=\"number\">100</span>, <span class=\"number\">0</span>, <span class=\"number\">0.25</span>);</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>@mixin</code>과 이름을 통해 믹스인을 만들 수 있다. 믹스인을 만든 후에는 <code>@include</code>와 이름을 선언해 믹스인을 이용 할 수 있다. 또한 믹스인은 JavaScript 함수처럼 매개변수를 설정할 수 있는데, 매개변수를 사용하면 믹스인 외부에서 사용자가 전달한 값을 믹스인 내부에서 사용해 재사용성을 더 높여줄 수 있다.</p>\n<h3 id=\"확장-x2F-상속-extend-x2F-inheritance\"><a href=\"#확장-x2F-상속-extend-x2F-inheritance\" class=\"headerlink\" title=\"확장&#x2F;상속 (extend&#x2F;inheritance)\"></a>확장&#x2F;상속 (extend&#x2F;inheritance)</h3><p>선택자 이름 앞에 <code>%</code>를 사용해 선언한 플레이스홀더 클래스는 스타일을 확장할 때만 사용되는 특수한 유형의 클래스로 여러 선택자에서 공유할 수 있다. 스타일 집합을 공유할 때는 <code>@extend</code>를 사용한다.</p>\n<p>이 방법은 스타일 코드를 반복 생성하는 믹스인과 달리, 스타일 코드 집합 하나를 재사용하는데 목적을 두고 있어 보다 코드를 깨끗하게 유지하는데 도움이 될 수 있다.</p>\n<p><strong>SCSS</strong></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%message-shared &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#333</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.message</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@extend</span> %message-shared;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.success</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@extend</span> %message-shared;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: green;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.error</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@extend</span> %message-shared;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.warning</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@extend</span> %message-shared;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: yellow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>CSS</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.message</span>, <span class=\"selector-class\">.success</span>, <span class=\"selector-class\">.error</span>, <span class=\"selector-class\">.warning</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#333</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.success</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: green;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.error</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.warning</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: yellow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"연산자-operators\"><a href=\"#연산자-operators\" class=\"headerlink\" title=\"연산자 (operators)\"></a>연산자 (operators)</h3><p>CSS에서 수학은 매우 유용하다. Sass는 산술연산자(<code>+</code>, <code>-</code>, <code>*</code>, <code>%</code>) 및 수학 함수(예: <code>math.div()</code>)를 제공한다.</p>\n<p><strong>SCSS</strong></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@use</span> <span class=\"string\">&quot;sass:math&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">article</span><span class=\"selector-attr\">[role=<span class=\"string\">&quot;main&quot;</span>]</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: math.<span class=\"built_in\">div</span>(<span class=\"number\">600px</span>, <span class=\"number\">960px</span>) * <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">aside</span><span class=\"selector-attr\">[role=<span class=\"string\">&quot;complementary&quot;</span>]</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: math.<span class=\"built_in\">div</span>(<span class=\"number\">300px</span>, <span class=\"number\">960px</span>) * <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin-left</span>: auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>CSS</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">article</span><span class=\"selector-attr\">[role=<span class=\"string\">&quot;main&quot;</span>]</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">62.5%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">aside</span><span class=\"selector-attr\">[role=<span class=\"string\">&quot;complementary&quot;</span>]</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">31.25%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin-left</span>: auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>특히 <code>math.div()</code>를 이용하기 위해서는 <code>@use &quot;sass:math&quot;</code>를 이용해 Sass에서 기본으로 제공하는 math 모듈을 불러와야 한다. 이때 as *를 이용해 사용한다면 div 태그와 구분이 가지 않으므로 <code>math.div()</code>의 기본 형태로 사용하는 것이 추천된다.</p>\n<hr>\n\n<h1 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h1><ul>\n<li><a href=\"https://sass-lang.com/guide\">https://sass-lang.com/guide</a></li>\n<li><a href=\"https://euid.notion.site/euid/Sass-04a97ad611cc4436a9f09e9ff052b183\">https://euid.notion.site/euid/Sass-04a97ad611cc4436a9f09e9ff052b183</a></li>\n<li><a href=\"https://heropy.blog/2018/01/31/sass/\">https://heropy.blog/2018/01/31/sass/</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Sass\"><a href=\"#Sass\" class=\"headerlink\" title=\"Sass?\"></a>Sass?</h1><p>CSS를 사용해 웹 애플리케이션 스타일을 관리하는 것은 애플리케이션 규모가 커지고 복잡해질수록 매우 어렵다.</p>\n<p>반면 Sass와 같은 프리프로세서(Pre-Processor, 전처리기)를 사용하면 매우 효과적으로 복잡한 애플리케이션 스타일을 관리할 수 있다.</p>\n<p>Sass란 Syntactically Awesome Style Sheets의 준말로 CSS가 아직은 할 수 없는 다양한 기능(중첩, 함수, 믹스인, 상속 등)을 제공한다.</p>\n<p>Sass말고도 Stylus, Less와 같은 전처리기가 존재하지만 현재 Sass가 통계상 가장 사용자가 많으면서 만족도가 높아 배웠을 때 가장 유용하다고 할 수 있다. (<a href=\"https://2021.stateofcss.com/ko-KR/technologies/#scatterplot_overview\">설문결과</a>)</p>\n<hr>\n\n<h2 id=\"설치\"><a href=\"#설치\" class=\"headerlink\" title=\"설치\"></a>설치</h2><p>Sass를 이용하기 위해선 먼저 설치를 해야한다. <a href=\"https://sass-lang.com/install\">공식사이트</a>를 참고해 다양한 방식으로 설치가 가능하다. 나는 Node.js를 이용하고 있기에 npm을 통해 설치해 주었다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g sass</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"컴파일\"><a href=\"#컴파일\" class=\"headerlink\" title=\"컴파일\"></a>컴파일</h2><p>Sass를 설치해 이용하고자 할 때, 웹 브라우저는 Sass파일을 해석할 수 없기에 Sass파일을 CSS파일로 변경해야 한다. 이를 컴파일이라 하는데 다음과 같이 사용 가능하다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sass input.scss output.css</span><br></pre></td></tr></table></figure>\n<p>단일 파일이 아니라 폴더 단위의 변경을 처리한다면 <code>:</code>을 이용할 수 있다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sass src/scss:public/css</span><br></pre></td></tr></table></figure>\n<p>더 많은 옵션은 <a href=\"https://sass-lang.com/documentation/cli/dart-sass\">Dart Sass CLI</a>를 참고할 수 있다.</p>\n<hr>\n\n<h2 id=\"문법\"><a href=\"#문법\" class=\"headerlink\" title=\"문법\"></a>문법</h2><p>Sass파일은 사용하는 문법에 따라 <code>.scss</code>의 확장자를 가진 SCSS 구문과 <code>.sass</code>를 가진 Sass구문 2가지로 나뉜다.</p>\n<h3 id=\"Sass-구문\"><a href=\"#Sass-구문\" class=\"headerlink\" title=\"Sass 구문\"></a>Sass 구문</h3><p>Sass 구문은 중괄호, 세미콜론을 생략하고 들여쓰기 문법을 사용한다. 좀 더 간결하고 작성하기 편리하며 <code>&#123;&#125;</code>나 <code>;</code>를 사용하지 않아도 되어 코드가 깔끔하다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.button</span><br><span class=\"line\">\tcursor: pointer</span><br><span class=\"line\">\t&amp;:disabled</span><br><span class=\"line\">\t\tcursor: not-allowed</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SCSS-구문\"><a href=\"#SCSS-구문\" class=\"headerlink\" title=\"SCSS 구문\"></a>SCSS 구문</h3><p>SCSS 구문은 CSS와 유사한 문법을 사용한다. 인라인 코드를 작성할 수 있고, CSS와 유사한 문법을 가지기 때문에 코드 통합이 훨씬 쉽다.</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.button</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">cursor</span>: pointer;</span><br><span class=\"line\">\t&amp;<span class=\"selector-pseudo\">:disabled</span> &#123;</span><br><span class=\"line\">\t  <span class=\"attribute\">cursor</span>: not-allowed;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>서로 장단점이 있기 때문에 회사나 팀에서 원하는 방식 혹은 개인의 취향에 따라서 선택할 수 있다. 일반적으로 CSS 구문과 문제없이 호환되는 SCSS구문이 많이 사용된다.</p>\n<hr>\n\n<h2 id=\"Sass-Basics\"><a href=\"#Sass-Basics\" class=\"headerlink\" title=\"Sass Basics\"></a>Sass Basics</h2><p>수업을 들으면서 Sass의 두 가지 구문중 SCSS를 사용했기에 Sass Basics에 대해 SCSS를 이용한 방법으로 정리하겠다.</p>\n<h3 id=\"변수-Variables\"><a href=\"#변수-Variables\" class=\"headerlink\" title=\"변수(Variables)\"></a>변수(Variables)</h3><p>CSS도 변수 사용이 가능하지만 Sass에서는 <code>$</code>를 이용해 더 쉽게 변수를 사용할 수 있다.</p>\n<p><strong>CSS 변수</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-pseudo\">:root</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">--spacing-1</span>: <span class=\"number\">4px</span>;</span><br><span class=\"line\">  <span class=\"attr\">--spacing-2</span>: <span class=\"number\">8px</span>;</span><br><span class=\"line\">  <span class=\"attr\">--primary-400</span>: <span class=\"built_in\">hsl</span>(<span class=\"number\">250</span>, <span class=\"number\">75%</span>, <span class=\"number\">60%</span>);</span><br><span class=\"line\">  <span class=\"attr\">--primary-500</span>: <span class=\"built_in\">hsl</span>(<span class=\"number\">250</span>, <span class=\"number\">75%</span>, <span class=\"number\">50%</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>: <span class=\"built_in\">var</span>(--spacing-<span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"built_in\">var</span>(--primary-<span class=\"number\">500</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>SCSS 변수</strong></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$spacing-1</span>: <span class=\"number\">4px</span>;</span><br><span class=\"line\"><span class=\"variable\">$spacing-2</span>: <span class=\"number\">8px</span>;</span><br><span class=\"line\"><span class=\"variable\">$primary-400</span>: <span class=\"built_in\">hsl</span>(<span class=\"number\">250</span>, <span class=\"number\">75%</span>, <span class=\"number\">60%</span>);</span><br><span class=\"line\"><span class=\"variable\">$primary-500</span>: <span class=\"built_in\">hsl</span>(<span class=\"number\">250</span>, <span class=\"number\">75%</span>, <span class=\"number\">50%</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>: <span class=\"variable\">$spacing-2</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"variable\">$primary-500</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"중첩-Nesting\"><a href=\"#중첩-Nesting\" class=\"headerlink\" title=\"중첩(Nesting)\"></a>중첩(Nesting)</h3><p>CSS는 HTML과 달리 시각적인 계층 구조와 명확히 중첩된 구문을 작성할 수 없다. 하지만 Sass는 HTML과 동일하게 시각적 계층 구조를 따르는 방식으로 스타일을 작성하는 방법을 지원한다.</p>\n<p><strong>CSS 구문</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">ul</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">list-style</span>: none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">6px</span> <span class=\"number\">12px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">text-decoration</span>: none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>SCSS 구문</strong></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"selector-tag\">ul</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">list-style</span>: none;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"selector-tag\">li</span> &#123; <span class=\"attribute\">display</span>: inline-block; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">6px</span> <span class=\"number\">12px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">text-decoration</span>: none;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Sass 중첩 구문은 시각적으로 계층 구조를 파악할 수 있어 CSS 보다 직관성이 높다. 하지만 많은 중첩은 오히려 복잡성을 증가시켜 가독성이 떨어지므로 피해야한다.</p>\n<h3 id=\"모듈-modules\"><a href=\"#모듈-modules\" class=\"headerlink\" title=\"모듈(modules)\"></a>모듈(modules)</h3><p>모듈은 독립적으로 묶인 작은 코드 조각으로, Sass는 관심사에 따라 여러 조각의 코드로 묶인 파일을 관리할 수 있는 기능인 모듈화를 제공한다. 모듈은 애플리케이션 스타일을 유지 관리하기 쉽게 만들어 주는 매우 효과적인 방법이다.</p>\n<p>Sass(정확히는 Dart Sass)에서는 <code>@import rule</code>대신 <code>@use</code>를 이용해 다른 스타일 모듈을 불러올 수 있다. Sass 파일 확장자와 언더스코어(_)는 생략 가능하다.</p>\n<p><strong>_base.scss</strong></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$font-stack</span>: Helvetica, sans-serif;</span><br><span class=\"line\"><span class=\"variable\">$primary-color</span>: <span class=\"number\">#333</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font</span>: <span class=\"number\">100%</span> <span class=\"variable\">$font-stack</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"variable\">$primary-color</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>불러온 모듈은 기본적으로 파일 이름을 네임스페이스(namespace)로 가지며 점(.) 문법을 사용해 모듈의 변수 등에 접근할 수 있다.</p>\n<p><strong>styles.scss</strong></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@use</span> <span class=\"string\">&#x27;base&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.inverse</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: base.<span class=\"variable\">$primary-color</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: white;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>네임스페이스 이름을 다른 이름으로 변경해 사용하고자 할 경우 as를 사용한다. 특히 as에 별(*) 기호를 사용할 경우 네임스페이스 없이 바로 모듈에서 내보낸 변수를 사용할 수 있다.</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@use</span> <span class=\"string\">&#x27;base&#x27;</span> as *;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.inverse</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"variable\">$primary-color</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: white;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>CSS</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font</span>: <span class=\"number\">100%</span> Helvetica, sans-serif;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#333</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.inverse</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#333</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: white;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"믹스인-mixins\"><a href=\"#믹스인-mixins\" class=\"headerlink\" title=\"믹스인(mixins)\"></a>믹스인(mixins)</h3><p>CSS는 코드를 재사용 할 수 있는 기능이 제공되지 않기 때문에 코드 중복이 잦은 언어이다. 하지만 Sass는 코드를 효율적으로 재사용할 수 있도록 믹스인 기능을 제공한다. 믹스인을 이용해 재사용할 코드 그룹을  선언할 수 있다.</p>\n<p><strong>SCSS</strong></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@mixin</span> theme(<span class=\"variable\">$theme</span>: DarkGray) &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"variable\">$theme</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">1px</span> <span class=\"built_in\">rgba</span>(<span class=\"variable\">$theme</span>, .<span class=\"number\">25</span>);</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.info</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@include</span> theme;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.alert</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@include</span> theme(<span class=\"variable\">$theme</span>: DarkRed);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.success</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@include</span> theme(<span class=\"variable\">$theme</span>: DarkGreen);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>CSS</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.info</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: DarkGray;</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">1px</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">169</span>, <span class=\"number\">169</span>, <span class=\"number\">169</span>, <span class=\"number\">0.25</span>);</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.alert</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: DarkRed;</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">1px</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">139</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0.25</span>);</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.success</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: DarkGreen;</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">1px</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>, <span class=\"number\">100</span>, <span class=\"number\">0</span>, <span class=\"number\">0.25</span>);</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>@mixin</code>과 이름을 통해 믹스인을 만들 수 있다. 믹스인을 만든 후에는 <code>@include</code>와 이름을 선언해 믹스인을 이용 할 수 있다. 또한 믹스인은 JavaScript 함수처럼 매개변수를 설정할 수 있는데, 매개변수를 사용하면 믹스인 외부에서 사용자가 전달한 값을 믹스인 내부에서 사용해 재사용성을 더 높여줄 수 있다.</p>\n<h3 id=\"확장-x2F-상속-extend-x2F-inheritance\"><a href=\"#확장-x2F-상속-extend-x2F-inheritance\" class=\"headerlink\" title=\"확장&#x2F;상속 (extend&#x2F;inheritance)\"></a>확장&#x2F;상속 (extend&#x2F;inheritance)</h3><p>선택자 이름 앞에 <code>%</code>를 사용해 선언한 플레이스홀더 클래스는 스타일을 확장할 때만 사용되는 특수한 유형의 클래스로 여러 선택자에서 공유할 수 있다. 스타일 집합을 공유할 때는 <code>@extend</code>를 사용한다.</p>\n<p>이 방법은 스타일 코드를 반복 생성하는 믹스인과 달리, 스타일 코드 집합 하나를 재사용하는데 목적을 두고 있어 보다 코드를 깨끗하게 유지하는데 도움이 될 수 있다.</p>\n<p><strong>SCSS</strong></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%message-shared &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#333</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.message</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@extend</span> %message-shared;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.success</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@extend</span> %message-shared;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: green;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.error</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@extend</span> %message-shared;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.warning</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@extend</span> %message-shared;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: yellow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>CSS</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.message</span>, <span class=\"selector-class\">.success</span>, <span class=\"selector-class\">.error</span>, <span class=\"selector-class\">.warning</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#333</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.success</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: green;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.error</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.warning</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: yellow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"연산자-operators\"><a href=\"#연산자-operators\" class=\"headerlink\" title=\"연산자 (operators)\"></a>연산자 (operators)</h3><p>CSS에서 수학은 매우 유용하다. Sass는 산술연산자(<code>+</code>, <code>-</code>, <code>*</code>, <code>%</code>) 및 수학 함수(예: <code>math.div()</code>)를 제공한다.</p>\n<p><strong>SCSS</strong></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@use</span> <span class=\"string\">&quot;sass:math&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">article</span><span class=\"selector-attr\">[role=<span class=\"string\">&quot;main&quot;</span>]</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: math.<span class=\"built_in\">div</span>(<span class=\"number\">600px</span>, <span class=\"number\">960px</span>) * <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">aside</span><span class=\"selector-attr\">[role=<span class=\"string\">&quot;complementary&quot;</span>]</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: math.<span class=\"built_in\">div</span>(<span class=\"number\">300px</span>, <span class=\"number\">960px</span>) * <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin-left</span>: auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>CSS</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">article</span><span class=\"selector-attr\">[role=<span class=\"string\">&quot;main&quot;</span>]</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">62.5%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">aside</span><span class=\"selector-attr\">[role=<span class=\"string\">&quot;complementary&quot;</span>]</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">31.25%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin-left</span>: auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>특히 <code>math.div()</code>를 이용하기 위해서는 <code>@use &quot;sass:math&quot;</code>를 이용해 Sass에서 기본으로 제공하는 math 모듈을 불러와야 한다. 이때 as *를 이용해 사용한다면 div 태그와 구분이 가지 않으므로 <code>math.div()</code>의 기본 형태로 사용하는 것이 추천된다.</p>\n<hr>\n\n<h1 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h1><ul>\n<li><a href=\"https://sass-lang.com/guide\">https://sass-lang.com/guide</a></li>\n<li><a href=\"https://euid.notion.site/euid/Sass-04a97ad611cc4436a9f09e9ff052b183\">https://euid.notion.site/euid/Sass-04a97ad611cc4436a9f09e9ff052b183</a></li>\n<li><a href=\"https://heropy.blog/2018/01/31/sass/\">https://heropy.blog/2018/01/31/sass/</a></li>\n</ul>\n"},{"title":"pageYOffset vs scrollY, scroll() vs scrollTo()","date":"2022-11-28T03:31:26.000Z","_content":"# 🤔What is Problem?\n\n페어 프로그래밍을 진행하면서 수직으로 스크롤한 거리에 따라 숨겨진 버튼을 활성화 하고, 스크롤 버튼을 클릭했을 때 맨 위로 스크롤하는 예제를 해결해야했다.\n\n이를 위해 수직으로 스크롤한 거리를 측정하는 방법과 스크롤을 시키는 방법이 필요해 이에 대해 알아보았는데, 같은 기능을 하는 프로퍼티와 메서드가 중복으로 존재해 어떤것을 사용해야하는지 고민이 되었다.\n\n## Window.pageYOffset vs Window.scrollY\n\n먼저 수직으로 스크롤한 거리를 측정하는 방법에는 Window.pageYOffset와 Window.scrollY가 존재했다. MDN에서는 pageYOffset이 scrollY의 다른이름이라고 했지만, 두 프로퍼티에는 브라우저 호환성의 차이가 존재했다.\n\n일부 오래된 브라우저는 scrollY 대신 pageYOffset만 지원했고 노후 환경을 신경쓰지 않아도 된다면 둘 중 아무거나 사용해도 괜찮지만, 별다른 요구조건이 없다면 하위호환성을 위해 pageYOffset을 사용하는 것이 더 좋은 코드라고 판단했다.\n\n## Window.scroll() vs Window.scrollTo()\n\n다음으로 맨 위로 스크롤하기 위해서는 Window.scroll() 이나 Window.scrollTo() 메서드를 사용할 수 있었다. 이 두 메서드는 차이 없이 동일해 둘 중 아무거나 사용해도 괜찮았다. 다만 scroll 메서드가 더 먼저 나왔기 때문에 실제로 사용된 코드도 많고 혹여나 버그등이 발생해 검색을 해야한다면 검색 결과도 많아 scroll을 사용하는것이 더 좋을 것이라고 판단했다.\n\n또 단순히 메서드의 인자로 x-좌표와 y-좌표를 주는것 이외에도 options를 통해 top, left, behavior를 줄 수 있다는 것을 알았다. 특히 behavior: smooth를 사용해 애니메이션을 따로 만들지 않더라도 부드럽게 이동할 수 있는점이 유용해 꼭 기억하자 생각했다.\n\n## 참고\n\n- https://developer.mozilla.org/ko/docs/Web/API/Window/pageYOffset\n- https://developer.mozilla.org/ko/docs/Web/API/Window/scrollY\n- https://developer.mozilla.org/en-US/docs/Web/API/Window/scroll\n- https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollTo\n- https://stackoverflow.com/questions/1925671/javascript-window-scroll-vs-window-scrollto\n\n","source":"_posts/pageYOffset-vs-scrollY-scroll-vs-scrollTo.md","raw":"---\ntitle: pageYOffset vs scrollY, scroll() vs scrollTo()\ndate: 2022-11-28 12:31:26\ntags:\n- JS\n---\n# 🤔What is Problem?\n\n페어 프로그래밍을 진행하면서 수직으로 스크롤한 거리에 따라 숨겨진 버튼을 활성화 하고, 스크롤 버튼을 클릭했을 때 맨 위로 스크롤하는 예제를 해결해야했다.\n\n이를 위해 수직으로 스크롤한 거리를 측정하는 방법과 스크롤을 시키는 방법이 필요해 이에 대해 알아보았는데, 같은 기능을 하는 프로퍼티와 메서드가 중복으로 존재해 어떤것을 사용해야하는지 고민이 되었다.\n\n## Window.pageYOffset vs Window.scrollY\n\n먼저 수직으로 스크롤한 거리를 측정하는 방법에는 Window.pageYOffset와 Window.scrollY가 존재했다. MDN에서는 pageYOffset이 scrollY의 다른이름이라고 했지만, 두 프로퍼티에는 브라우저 호환성의 차이가 존재했다.\n\n일부 오래된 브라우저는 scrollY 대신 pageYOffset만 지원했고 노후 환경을 신경쓰지 않아도 된다면 둘 중 아무거나 사용해도 괜찮지만, 별다른 요구조건이 없다면 하위호환성을 위해 pageYOffset을 사용하는 것이 더 좋은 코드라고 판단했다.\n\n## Window.scroll() vs Window.scrollTo()\n\n다음으로 맨 위로 스크롤하기 위해서는 Window.scroll() 이나 Window.scrollTo() 메서드를 사용할 수 있었다. 이 두 메서드는 차이 없이 동일해 둘 중 아무거나 사용해도 괜찮았다. 다만 scroll 메서드가 더 먼저 나왔기 때문에 실제로 사용된 코드도 많고 혹여나 버그등이 발생해 검색을 해야한다면 검색 결과도 많아 scroll을 사용하는것이 더 좋을 것이라고 판단했다.\n\n또 단순히 메서드의 인자로 x-좌표와 y-좌표를 주는것 이외에도 options를 통해 top, left, behavior를 줄 수 있다는 것을 알았다. 특히 behavior: smooth를 사용해 애니메이션을 따로 만들지 않더라도 부드럽게 이동할 수 있는점이 유용해 꼭 기억하자 생각했다.\n\n## 참고\n\n- https://developer.mozilla.org/ko/docs/Web/API/Window/pageYOffset\n- https://developer.mozilla.org/ko/docs/Web/API/Window/scrollY\n- https://developer.mozilla.org/en-US/docs/Web/API/Window/scroll\n- https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollTo\n- https://stackoverflow.com/questions/1925671/javascript-window-scroll-vs-window-scrollto\n\n","slug":"pageYOffset-vs-scrollY-scroll-vs-scrollTo","published":1,"updated":"2022-11-28T03:32:14.646Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb08iq6k000re4vk895xf720","content":"<h1 id=\"🤔What-is-Problem\"><a href=\"#🤔What-is-Problem\" class=\"headerlink\" title=\"🤔What is Problem?\"></a>🤔What is Problem?</h1><p>페어 프로그래밍을 진행하면서 수직으로 스크롤한 거리에 따라 숨겨진 버튼을 활성화 하고, 스크롤 버튼을 클릭했을 때 맨 위로 스크롤하는 예제를 해결해야했다.</p>\n<p>이를 위해 수직으로 스크롤한 거리를 측정하는 방법과 스크롤을 시키는 방법이 필요해 이에 대해 알아보았는데, 같은 기능을 하는 프로퍼티와 메서드가 중복으로 존재해 어떤것을 사용해야하는지 고민이 되었다.</p>\n<h2 id=\"Window-pageYOffset-vs-Window-scrollY\"><a href=\"#Window-pageYOffset-vs-Window-scrollY\" class=\"headerlink\" title=\"Window.pageYOffset vs Window.scrollY\"></a>Window.pageYOffset vs Window.scrollY</h2><p>먼저 수직으로 스크롤한 거리를 측정하는 방법에는 Window.pageYOffset와 Window.scrollY가 존재했다. MDN에서는 pageYOffset이 scrollY의 다른이름이라고 했지만, 두 프로퍼티에는 브라우저 호환성의 차이가 존재했다.</p>\n<p>일부 오래된 브라우저는 scrollY 대신 pageYOffset만 지원했고 노후 환경을 신경쓰지 않아도 된다면 둘 중 아무거나 사용해도 괜찮지만, 별다른 요구조건이 없다면 하위호환성을 위해 pageYOffset을 사용하는 것이 더 좋은 코드라고 판단했다.</p>\n<h2 id=\"Window-scroll-vs-Window-scrollTo\"><a href=\"#Window-scroll-vs-Window-scrollTo\" class=\"headerlink\" title=\"Window.scroll() vs Window.scrollTo()\"></a>Window.scroll() vs Window.scrollTo()</h2><p>다음으로 맨 위로 스크롤하기 위해서는 Window.scroll() 이나 Window.scrollTo() 메서드를 사용할 수 있었다. 이 두 메서드는 차이 없이 동일해 둘 중 아무거나 사용해도 괜찮았다. 다만 scroll 메서드가 더 먼저 나왔기 때문에 실제로 사용된 코드도 많고 혹여나 버그등이 발생해 검색을 해야한다면 검색 결과도 많아 scroll을 사용하는것이 더 좋을 것이라고 판단했다.</p>\n<p>또 단순히 메서드의 인자로 x-좌표와 y-좌표를 주는것 이외에도 options를 통해 top, left, behavior를 줄 수 있다는 것을 알았다. 특히 behavior: smooth를 사용해 애니메이션을 따로 만들지 않더라도 부드럽게 이동할 수 있는점이 유용해 꼭 기억하자 생각했다.</p>\n<h2 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h2><ul>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/API/Window/pageYOffset\">https://developer.mozilla.org/ko/docs/Web/API/Window/pageYOffset</a></li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/API/Window/scrollY\">https://developer.mozilla.org/ko/docs/Web/API/Window/scrollY</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/scroll\">https://developer.mozilla.org/en-US/docs/Web/API/Window/scroll</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollTo\">https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollTo</a></li>\n<li><a href=\"https://stackoverflow.com/questions/1925671/javascript-window-scroll-vs-window-scrollto\">https://stackoverflow.com/questions/1925671/javascript-window-scroll-vs-window-scrollto</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"🤔What-is-Problem\"><a href=\"#🤔What-is-Problem\" class=\"headerlink\" title=\"🤔What is Problem?\"></a>🤔What is Problem?</h1><p>페어 프로그래밍을 진행하면서 수직으로 스크롤한 거리에 따라 숨겨진 버튼을 활성화 하고, 스크롤 버튼을 클릭했을 때 맨 위로 스크롤하는 예제를 해결해야했다.</p>\n<p>이를 위해 수직으로 스크롤한 거리를 측정하는 방법과 스크롤을 시키는 방법이 필요해 이에 대해 알아보았는데, 같은 기능을 하는 프로퍼티와 메서드가 중복으로 존재해 어떤것을 사용해야하는지 고민이 되었다.</p>\n<h2 id=\"Window-pageYOffset-vs-Window-scrollY\"><a href=\"#Window-pageYOffset-vs-Window-scrollY\" class=\"headerlink\" title=\"Window.pageYOffset vs Window.scrollY\"></a>Window.pageYOffset vs Window.scrollY</h2><p>먼저 수직으로 스크롤한 거리를 측정하는 방법에는 Window.pageYOffset와 Window.scrollY가 존재했다. MDN에서는 pageYOffset이 scrollY의 다른이름이라고 했지만, 두 프로퍼티에는 브라우저 호환성의 차이가 존재했다.</p>\n<p>일부 오래된 브라우저는 scrollY 대신 pageYOffset만 지원했고 노후 환경을 신경쓰지 않아도 된다면 둘 중 아무거나 사용해도 괜찮지만, 별다른 요구조건이 없다면 하위호환성을 위해 pageYOffset을 사용하는 것이 더 좋은 코드라고 판단했다.</p>\n<h2 id=\"Window-scroll-vs-Window-scrollTo\"><a href=\"#Window-scroll-vs-Window-scrollTo\" class=\"headerlink\" title=\"Window.scroll() vs Window.scrollTo()\"></a>Window.scroll() vs Window.scrollTo()</h2><p>다음으로 맨 위로 스크롤하기 위해서는 Window.scroll() 이나 Window.scrollTo() 메서드를 사용할 수 있었다. 이 두 메서드는 차이 없이 동일해 둘 중 아무거나 사용해도 괜찮았다. 다만 scroll 메서드가 더 먼저 나왔기 때문에 실제로 사용된 코드도 많고 혹여나 버그등이 발생해 검색을 해야한다면 검색 결과도 많아 scroll을 사용하는것이 더 좋을 것이라고 판단했다.</p>\n<p>또 단순히 메서드의 인자로 x-좌표와 y-좌표를 주는것 이외에도 options를 통해 top, left, behavior를 줄 수 있다는 것을 알았다. 특히 behavior: smooth를 사용해 애니메이션을 따로 만들지 않더라도 부드럽게 이동할 수 있는점이 유용해 꼭 기억하자 생각했다.</p>\n<h2 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h2><ul>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/API/Window/pageYOffset\">https://developer.mozilla.org/ko/docs/Web/API/Window/pageYOffset</a></li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/API/Window/scrollY\">https://developer.mozilla.org/ko/docs/Web/API/Window/scrollY</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/scroll\">https://developer.mozilla.org/en-US/docs/Web/API/Window/scroll</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollTo\">https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollTo</a></li>\n<li><a href=\"https://stackoverflow.com/questions/1925671/javascript-window-scroll-vs-window-scrollto\">https://stackoverflow.com/questions/1925671/javascript-window-scroll-vs-window-scrollto</a></li>\n</ul>\n"},{"title":"WCAG 2.1 정리","date":"2022-09-06T11:53:37.000Z","_content":"# 👀 WCAG?\n> - WCAG는 Web Content Accessibility Guideline의 줄임말로 웹 콘텐츠를 접근성 있게 만들기 위한 권장 표준\n- 이 표준을 준수함을 통해 시각, 청각, 운동장애 등 광범위한 장애에 대한 접근성 있는 콘텐츠를 만들 수 있음\n- 웹 접근성의 기초를 제공하는 4가지 원칙인 인식의 용이성(Perceivable), 운용의 용이성(Operable), 이해의 용이성(Understandable), 견고성(Robust)에 기반을 두고 있음\n- 원칙을 기반으로 접근성을 위해 어떠한 목표를 달성해야 하는지에 대한 지침과 또 그 지침에 대한 검증가능한 성공기준을 제시하고 있음\n- 성공기준은 최저수준인 level A 부터 최고수준인 level AAA까지 3단계로 나누어짐\n\n<hr>\n\n# WCAG 2.0 VS WCAG 2.1\nWCAG 2.0 이 만들어졌을때는 주로 데스크탑 환경만을 고려했지만 그 후 모바일 산업의 폭발적인 확장으로 모바일 환경을 필수적으로 고려해야하는 상황이 찾아왔다.\n\nWCAG 2.1은 WCAG 2.0의 요구사항들을 상속하면서 추가적으로 인지나 학습장애가 있는 사용자, 저시력자, 모바일 기기를 사용하는데 장애가 있는 사용자의 접근성 지침을 개선하는 데 목표를 두고있다.\n\n즉 WCAG 2.1은 새로운 성공기준, 이를 지원하기 위한 정의, 추가사항을 조직하기 위한 지침, 그리고 준수 절(section)에 대한 몇 가지 사항을 추가하여 WCAG 2.0을 확장한 것이다.\n\n<hr>\n\n## 1. 인식의 용이성(Perceivable)\n- 정보와 사용자 인터페이스 요소는 사용자가 인식할 수 있는 방법으로 제시되어야 한다.\n- 4가지 지침과 그에 대한 29가지 성공기준을 가지고 있다.\n\n### 지침 1.1 대체텍스트\n- 텍스트가 아닌 콘텐츠의 경우 목적에 상응하는 대체 텍스트를 제공해야 한다. (ex - img alt속성)\n\n- 단 시력검사, 받아쓰기와 같은 Test나 특정 감각을 위한 악기연주 등 텍스트만으로 그 내용을 설명하기에 애매한 경우 콘텐츠의 용도만을 기술하는 것도 괜찮다.\n\n- 텍스트 아닌 콘텐츠가 순수한 장식이거나, 보이지 않는경우 대체텍스트를 제공하지 않는 편이 합리적이다\n\n### 지침 1.2 시간기반 미디어\n- 시간기반 미디어에 대한 대체수단을 제공해야 한다\n\n- 달성하기 비교적 쉬운 level A 부터 어려운 level AAA 까지 총 9개의 기준을 가지고 있다.\n\n- level이 올라갈수록 더 자세하고 많은 정보를 실시간으로 제공하는 것을 기준으로 삼고 있다.\n\n### 지침 1.3 적응가능\n- 콘텐츠가 정보나 구조의 손실 없이 다른 방법들로 표시될 수 있도록 제작되어야 한다.\n\n- 콘텐츠의 정보, 구조, 관계는 프로그래밍 방식으로 결정되어야 하고 또 콘텐츠가 표시되는 순서가 의미에 영향을 주는 경우 올바른 읽기 순서 역시 프로그래밍 방식으로 결정되어야 한다.\n>프로그래밍 방식으로 결정된다는 것은 확대기, 음성 인식 소프트웨어와 같은 보조공학을 포함한 user agent(웹 브라우저)가 개발자 제공 데이터로부터 정보를 추출해 사용자에게 다른 형식으로 제공할 수 있음을 뜻한다 - 대체텍스트의 img alt 속성 처럼\n\n- 콘텐츠를 이해하고 작동하기 위해 제공된 지시문은 모양, 색상, 크기, 시각적 위치 등 구성요소의 감각적 특성에 전적으로 의존해서는 안 된다.\n\n### 지침 1.4 식별 가능\n- 색상은 시각적 요소 구별을 위한 유일한 시각적 수단으로만 사용되어서는 안된다.\n\n- 웹 페이지에 있는 오디오를 컨트롤 할수 있어야 하고, 배경음이 낮거나 없어야한다 - 스크린리더 사용자를 위한 항목으로, 스크린리더 사용자는 청각을 통해 정보를 받아들이기 때문에 다른 오디오나 배경음이 지속된다면 콘텐츠를 이용하는데 불편함을 겪을 수 있음.\n\n- 텍스트 이미지 보다는 텍스트를 사용해야 하고, 텍스트의 명도대비, 크기 조정등을 통해 가시성을 높여야한다.\n\n<hr>\n\n추가중...\n\n<hr>\n\n# 참고\n- https://www.w3.org/TR/WCAG21/\n- http://www.kwacc.or.kr/WAI/wcag21/\n- http://www.websoul.co.kr/accessibility/WA_guide21.asp\n\n\n","source":"_posts/WCAG-2-1-organization.md","raw":"---\ntitle: WCAG 2.1 정리\ndate: 2022-09-06 20:53:37\ntags:\n- 개발\n- WCAG\n---\n# 👀 WCAG?\n> - WCAG는 Web Content Accessibility Guideline의 줄임말로 웹 콘텐츠를 접근성 있게 만들기 위한 권장 표준\n- 이 표준을 준수함을 통해 시각, 청각, 운동장애 등 광범위한 장애에 대한 접근성 있는 콘텐츠를 만들 수 있음\n- 웹 접근성의 기초를 제공하는 4가지 원칙인 인식의 용이성(Perceivable), 운용의 용이성(Operable), 이해의 용이성(Understandable), 견고성(Robust)에 기반을 두고 있음\n- 원칙을 기반으로 접근성을 위해 어떠한 목표를 달성해야 하는지에 대한 지침과 또 그 지침에 대한 검증가능한 성공기준을 제시하고 있음\n- 성공기준은 최저수준인 level A 부터 최고수준인 level AAA까지 3단계로 나누어짐\n\n<hr>\n\n# WCAG 2.0 VS WCAG 2.1\nWCAG 2.0 이 만들어졌을때는 주로 데스크탑 환경만을 고려했지만 그 후 모바일 산업의 폭발적인 확장으로 모바일 환경을 필수적으로 고려해야하는 상황이 찾아왔다.\n\nWCAG 2.1은 WCAG 2.0의 요구사항들을 상속하면서 추가적으로 인지나 학습장애가 있는 사용자, 저시력자, 모바일 기기를 사용하는데 장애가 있는 사용자의 접근성 지침을 개선하는 데 목표를 두고있다.\n\n즉 WCAG 2.1은 새로운 성공기준, 이를 지원하기 위한 정의, 추가사항을 조직하기 위한 지침, 그리고 준수 절(section)에 대한 몇 가지 사항을 추가하여 WCAG 2.0을 확장한 것이다.\n\n<hr>\n\n## 1. 인식의 용이성(Perceivable)\n- 정보와 사용자 인터페이스 요소는 사용자가 인식할 수 있는 방법으로 제시되어야 한다.\n- 4가지 지침과 그에 대한 29가지 성공기준을 가지고 있다.\n\n### 지침 1.1 대체텍스트\n- 텍스트가 아닌 콘텐츠의 경우 목적에 상응하는 대체 텍스트를 제공해야 한다. (ex - img alt속성)\n\n- 단 시력검사, 받아쓰기와 같은 Test나 특정 감각을 위한 악기연주 등 텍스트만으로 그 내용을 설명하기에 애매한 경우 콘텐츠의 용도만을 기술하는 것도 괜찮다.\n\n- 텍스트 아닌 콘텐츠가 순수한 장식이거나, 보이지 않는경우 대체텍스트를 제공하지 않는 편이 합리적이다\n\n### 지침 1.2 시간기반 미디어\n- 시간기반 미디어에 대한 대체수단을 제공해야 한다\n\n- 달성하기 비교적 쉬운 level A 부터 어려운 level AAA 까지 총 9개의 기준을 가지고 있다.\n\n- level이 올라갈수록 더 자세하고 많은 정보를 실시간으로 제공하는 것을 기준으로 삼고 있다.\n\n### 지침 1.3 적응가능\n- 콘텐츠가 정보나 구조의 손실 없이 다른 방법들로 표시될 수 있도록 제작되어야 한다.\n\n- 콘텐츠의 정보, 구조, 관계는 프로그래밍 방식으로 결정되어야 하고 또 콘텐츠가 표시되는 순서가 의미에 영향을 주는 경우 올바른 읽기 순서 역시 프로그래밍 방식으로 결정되어야 한다.\n>프로그래밍 방식으로 결정된다는 것은 확대기, 음성 인식 소프트웨어와 같은 보조공학을 포함한 user agent(웹 브라우저)가 개발자 제공 데이터로부터 정보를 추출해 사용자에게 다른 형식으로 제공할 수 있음을 뜻한다 - 대체텍스트의 img alt 속성 처럼\n\n- 콘텐츠를 이해하고 작동하기 위해 제공된 지시문은 모양, 색상, 크기, 시각적 위치 등 구성요소의 감각적 특성에 전적으로 의존해서는 안 된다.\n\n### 지침 1.4 식별 가능\n- 색상은 시각적 요소 구별을 위한 유일한 시각적 수단으로만 사용되어서는 안된다.\n\n- 웹 페이지에 있는 오디오를 컨트롤 할수 있어야 하고, 배경음이 낮거나 없어야한다 - 스크린리더 사용자를 위한 항목으로, 스크린리더 사용자는 청각을 통해 정보를 받아들이기 때문에 다른 오디오나 배경음이 지속된다면 콘텐츠를 이용하는데 불편함을 겪을 수 있음.\n\n- 텍스트 이미지 보다는 텍스트를 사용해야 하고, 텍스트의 명도대비, 크기 조정등을 통해 가시성을 높여야한다.\n\n<hr>\n\n추가중...\n\n<hr>\n\n# 참고\n- https://www.w3.org/TR/WCAG21/\n- http://www.kwacc.or.kr/WAI/wcag21/\n- http://www.websoul.co.kr/accessibility/WA_guide21.asp\n\n\n","slug":"WCAG-2-1-organization","published":1,"updated":"2022-10-08T11:54:56.113Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb08iq6k000se4vkhvf58tlr","content":"<h1 id=\"👀-WCAG\"><a href=\"#👀-WCAG\" class=\"headerlink\" title=\"👀 WCAG?\"></a>👀 WCAG?</h1><blockquote>\n<ul>\n<li>WCAG는 Web Content Accessibility Guideline의 줄임말로 웹 콘텐츠를 접근성 있게 만들기 위한 권장 표준</li>\n</ul>\n</blockquote>\n<ul>\n<li>이 표준을 준수함을 통해 시각, 청각, 운동장애 등 광범위한 장애에 대한 접근성 있는 콘텐츠를 만들 수 있음</li>\n<li>웹 접근성의 기초를 제공하는 4가지 원칙인 인식의 용이성(Perceivable), 운용의 용이성(Operable), 이해의 용이성(Understandable), 견고성(Robust)에 기반을 두고 있음</li>\n<li>원칙을 기반으로 접근성을 위해 어떠한 목표를 달성해야 하는지에 대한 지침과 또 그 지침에 대한 검증가능한 성공기준을 제시하고 있음</li>\n<li>성공기준은 최저수준인 level A 부터 최고수준인 level AAA까지 3단계로 나누어짐</li>\n</ul>\n<hr>\n\n<h1 id=\"WCAG-2-0-VS-WCAG-2-1\"><a href=\"#WCAG-2-0-VS-WCAG-2-1\" class=\"headerlink\" title=\"WCAG 2.0 VS WCAG 2.1\"></a>WCAG 2.0 VS WCAG 2.1</h1><p>WCAG 2.0 이 만들어졌을때는 주로 데스크탑 환경만을 고려했지만 그 후 모바일 산업의 폭발적인 확장으로 모바일 환경을 필수적으로 고려해야하는 상황이 찾아왔다.</p>\n<p>WCAG 2.1은 WCAG 2.0의 요구사항들을 상속하면서 추가적으로 인지나 학습장애가 있는 사용자, 저시력자, 모바일 기기를 사용하는데 장애가 있는 사용자의 접근성 지침을 개선하는 데 목표를 두고있다.</p>\n<p>즉 WCAG 2.1은 새로운 성공기준, 이를 지원하기 위한 정의, 추가사항을 조직하기 위한 지침, 그리고 준수 절(section)에 대한 몇 가지 사항을 추가하여 WCAG 2.0을 확장한 것이다.</p>\n<hr>\n\n<h2 id=\"1-인식의-용이성-Perceivable\"><a href=\"#1-인식의-용이성-Perceivable\" class=\"headerlink\" title=\"1. 인식의 용이성(Perceivable)\"></a>1. 인식의 용이성(Perceivable)</h2><ul>\n<li>정보와 사용자 인터페이스 요소는 사용자가 인식할 수 있는 방법으로 제시되어야 한다.</li>\n<li>4가지 지침과 그에 대한 29가지 성공기준을 가지고 있다.</li>\n</ul>\n<h3 id=\"지침-1-1-대체텍스트\"><a href=\"#지침-1-1-대체텍스트\" class=\"headerlink\" title=\"지침 1.1 대체텍스트\"></a>지침 1.1 대체텍스트</h3><ul>\n<li><p>텍스트가 아닌 콘텐츠의 경우 목적에 상응하는 대체 텍스트를 제공해야 한다. (ex - img alt속성)</p>\n</li>\n<li><p>단 시력검사, 받아쓰기와 같은 Test나 특정 감각을 위한 악기연주 등 텍스트만으로 그 내용을 설명하기에 애매한 경우 콘텐츠의 용도만을 기술하는 것도 괜찮다.</p>\n</li>\n<li><p>텍스트 아닌 콘텐츠가 순수한 장식이거나, 보이지 않는경우 대체텍스트를 제공하지 않는 편이 합리적이다</p>\n</li>\n</ul>\n<h3 id=\"지침-1-2-시간기반-미디어\"><a href=\"#지침-1-2-시간기반-미디어\" class=\"headerlink\" title=\"지침 1.2 시간기반 미디어\"></a>지침 1.2 시간기반 미디어</h3><ul>\n<li><p>시간기반 미디어에 대한 대체수단을 제공해야 한다</p>\n</li>\n<li><p>달성하기 비교적 쉬운 level A 부터 어려운 level AAA 까지 총 9개의 기준을 가지고 있다.</p>\n</li>\n<li><p>level이 올라갈수록 더 자세하고 많은 정보를 실시간으로 제공하는 것을 기준으로 삼고 있다.</p>\n</li>\n</ul>\n<h3 id=\"지침-1-3-적응가능\"><a href=\"#지침-1-3-적응가능\" class=\"headerlink\" title=\"지침 1.3 적응가능\"></a>지침 1.3 적응가능</h3><ul>\n<li><p>콘텐츠가 정보나 구조의 손실 없이 다른 방법들로 표시될 수 있도록 제작되어야 한다.</p>\n</li>\n<li><p>콘텐츠의 정보, 구조, 관계는 프로그래밍 방식으로 결정되어야 하고 또 콘텐츠가 표시되는 순서가 의미에 영향을 주는 경우 올바른 읽기 순서 역시 프로그래밍 방식으로 결정되어야 한다.</p>\n<blockquote>\n<p>프로그래밍 방식으로 결정된다는 것은 확대기, 음성 인식 소프트웨어와 같은 보조공학을 포함한 user agent(웹 브라우저)가 개발자 제공 데이터로부터 정보를 추출해 사용자에게 다른 형식으로 제공할 수 있음을 뜻한다 - 대체텍스트의 img alt 속성 처럼</p>\n</blockquote>\n</li>\n<li><p>콘텐츠를 이해하고 작동하기 위해 제공된 지시문은 모양, 색상, 크기, 시각적 위치 등 구성요소의 감각적 특성에 전적으로 의존해서는 안 된다.</p>\n</li>\n</ul>\n<h3 id=\"지침-1-4-식별-가능\"><a href=\"#지침-1-4-식별-가능\" class=\"headerlink\" title=\"지침 1.4 식별 가능\"></a>지침 1.4 식별 가능</h3><ul>\n<li><p>색상은 시각적 요소 구별을 위한 유일한 시각적 수단으로만 사용되어서는 안된다.</p>\n</li>\n<li><p>웹 페이지에 있는 오디오를 컨트롤 할수 있어야 하고, 배경음이 낮거나 없어야한다 - 스크린리더 사용자를 위한 항목으로, 스크린리더 사용자는 청각을 통해 정보를 받아들이기 때문에 다른 오디오나 배경음이 지속된다면 콘텐츠를 이용하는데 불편함을 겪을 수 있음.</p>\n</li>\n<li><p>텍스트 이미지 보다는 텍스트를 사용해야 하고, 텍스트의 명도대비, 크기 조정등을 통해 가시성을 높여야한다.</p>\n</li>\n</ul>\n<hr>\n\n<p>추가중…</p>\n<hr>\n\n<h1 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h1><ul>\n<li><a href=\"https://www.w3.org/TR/WCAG21/\">https://www.w3.org/TR/WCAG21/</a></li>\n<li><a href=\"http://www.kwacc.or.kr/WAI/wcag21/\">http://www.kwacc.or.kr/WAI/wcag21/</a></li>\n<li><a href=\"http://www.websoul.co.kr/accessibility/WA_guide21.asp\">http://www.websoul.co.kr/accessibility/WA_guide21.asp</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"👀-WCAG\"><a href=\"#👀-WCAG\" class=\"headerlink\" title=\"👀 WCAG?\"></a>👀 WCAG?</h1><blockquote>\n<ul>\n<li>WCAG는 Web Content Accessibility Guideline의 줄임말로 웹 콘텐츠를 접근성 있게 만들기 위한 권장 표준</li>\n</ul>\n</blockquote>\n<ul>\n<li>이 표준을 준수함을 통해 시각, 청각, 운동장애 등 광범위한 장애에 대한 접근성 있는 콘텐츠를 만들 수 있음</li>\n<li>웹 접근성의 기초를 제공하는 4가지 원칙인 인식의 용이성(Perceivable), 운용의 용이성(Operable), 이해의 용이성(Understandable), 견고성(Robust)에 기반을 두고 있음</li>\n<li>원칙을 기반으로 접근성을 위해 어떠한 목표를 달성해야 하는지에 대한 지침과 또 그 지침에 대한 검증가능한 성공기준을 제시하고 있음</li>\n<li>성공기준은 최저수준인 level A 부터 최고수준인 level AAA까지 3단계로 나누어짐</li>\n</ul>\n<hr>\n\n<h1 id=\"WCAG-2-0-VS-WCAG-2-1\"><a href=\"#WCAG-2-0-VS-WCAG-2-1\" class=\"headerlink\" title=\"WCAG 2.0 VS WCAG 2.1\"></a>WCAG 2.0 VS WCAG 2.1</h1><p>WCAG 2.0 이 만들어졌을때는 주로 데스크탑 환경만을 고려했지만 그 후 모바일 산업의 폭발적인 확장으로 모바일 환경을 필수적으로 고려해야하는 상황이 찾아왔다.</p>\n<p>WCAG 2.1은 WCAG 2.0의 요구사항들을 상속하면서 추가적으로 인지나 학습장애가 있는 사용자, 저시력자, 모바일 기기를 사용하는데 장애가 있는 사용자의 접근성 지침을 개선하는 데 목표를 두고있다.</p>\n<p>즉 WCAG 2.1은 새로운 성공기준, 이를 지원하기 위한 정의, 추가사항을 조직하기 위한 지침, 그리고 준수 절(section)에 대한 몇 가지 사항을 추가하여 WCAG 2.0을 확장한 것이다.</p>\n<hr>\n\n<h2 id=\"1-인식의-용이성-Perceivable\"><a href=\"#1-인식의-용이성-Perceivable\" class=\"headerlink\" title=\"1. 인식의 용이성(Perceivable)\"></a>1. 인식의 용이성(Perceivable)</h2><ul>\n<li>정보와 사용자 인터페이스 요소는 사용자가 인식할 수 있는 방법으로 제시되어야 한다.</li>\n<li>4가지 지침과 그에 대한 29가지 성공기준을 가지고 있다.</li>\n</ul>\n<h3 id=\"지침-1-1-대체텍스트\"><a href=\"#지침-1-1-대체텍스트\" class=\"headerlink\" title=\"지침 1.1 대체텍스트\"></a>지침 1.1 대체텍스트</h3><ul>\n<li><p>텍스트가 아닌 콘텐츠의 경우 목적에 상응하는 대체 텍스트를 제공해야 한다. (ex - img alt속성)</p>\n</li>\n<li><p>단 시력검사, 받아쓰기와 같은 Test나 특정 감각을 위한 악기연주 등 텍스트만으로 그 내용을 설명하기에 애매한 경우 콘텐츠의 용도만을 기술하는 것도 괜찮다.</p>\n</li>\n<li><p>텍스트 아닌 콘텐츠가 순수한 장식이거나, 보이지 않는경우 대체텍스트를 제공하지 않는 편이 합리적이다</p>\n</li>\n</ul>\n<h3 id=\"지침-1-2-시간기반-미디어\"><a href=\"#지침-1-2-시간기반-미디어\" class=\"headerlink\" title=\"지침 1.2 시간기반 미디어\"></a>지침 1.2 시간기반 미디어</h3><ul>\n<li><p>시간기반 미디어에 대한 대체수단을 제공해야 한다</p>\n</li>\n<li><p>달성하기 비교적 쉬운 level A 부터 어려운 level AAA 까지 총 9개의 기준을 가지고 있다.</p>\n</li>\n<li><p>level이 올라갈수록 더 자세하고 많은 정보를 실시간으로 제공하는 것을 기준으로 삼고 있다.</p>\n</li>\n</ul>\n<h3 id=\"지침-1-3-적응가능\"><a href=\"#지침-1-3-적응가능\" class=\"headerlink\" title=\"지침 1.3 적응가능\"></a>지침 1.3 적응가능</h3><ul>\n<li><p>콘텐츠가 정보나 구조의 손실 없이 다른 방법들로 표시될 수 있도록 제작되어야 한다.</p>\n</li>\n<li><p>콘텐츠의 정보, 구조, 관계는 프로그래밍 방식으로 결정되어야 하고 또 콘텐츠가 표시되는 순서가 의미에 영향을 주는 경우 올바른 읽기 순서 역시 프로그래밍 방식으로 결정되어야 한다.</p>\n<blockquote>\n<p>프로그래밍 방식으로 결정된다는 것은 확대기, 음성 인식 소프트웨어와 같은 보조공학을 포함한 user agent(웹 브라우저)가 개발자 제공 데이터로부터 정보를 추출해 사용자에게 다른 형식으로 제공할 수 있음을 뜻한다 - 대체텍스트의 img alt 속성 처럼</p>\n</blockquote>\n</li>\n<li><p>콘텐츠를 이해하고 작동하기 위해 제공된 지시문은 모양, 색상, 크기, 시각적 위치 등 구성요소의 감각적 특성에 전적으로 의존해서는 안 된다.</p>\n</li>\n</ul>\n<h3 id=\"지침-1-4-식별-가능\"><a href=\"#지침-1-4-식별-가능\" class=\"headerlink\" title=\"지침 1.4 식별 가능\"></a>지침 1.4 식별 가능</h3><ul>\n<li><p>색상은 시각적 요소 구별을 위한 유일한 시각적 수단으로만 사용되어서는 안된다.</p>\n</li>\n<li><p>웹 페이지에 있는 오디오를 컨트롤 할수 있어야 하고, 배경음이 낮거나 없어야한다 - 스크린리더 사용자를 위한 항목으로, 스크린리더 사용자는 청각을 통해 정보를 받아들이기 때문에 다른 오디오나 배경음이 지속된다면 콘텐츠를 이용하는데 불편함을 겪을 수 있음.</p>\n</li>\n<li><p>텍스트 이미지 보다는 텍스트를 사용해야 하고, 텍스트의 명도대비, 크기 조정등을 통해 가시성을 높여야한다.</p>\n</li>\n</ul>\n<hr>\n\n<p>추가중…</p>\n<hr>\n\n<h1 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h1><ul>\n<li><a href=\"https://www.w3.org/TR/WCAG21/\">https://www.w3.org/TR/WCAG21/</a></li>\n<li><a href=\"http://www.kwacc.or.kr/WAI/wcag21/\">http://www.kwacc.or.kr/WAI/wcag21/</a></li>\n<li><a href=\"http://www.websoul.co.kr/accessibility/WA_guide21.asp\">http://www.websoul.co.kr/accessibility/WA_guide21.asp</a></li>\n</ul>\n"},{"title":"API란 무엇일까?","date":"2022-08-14T10:29:18.000Z","_content":"JavaScript 구현공부를 시작하며 API를 이용하는 일이 많아졌다. API라는 용어에 대해 많이 들어보기도 했고 API가 무엇인지에 대해 대략적으로 알고 있다고 생각했었지만 막상 API에 대해 구체적으로 설명해보려고 하니 표현하기가 어려웠다. 그래서 API에 대해 정리해보면서 정확히 무엇인지 알아보고자 했다.\n<hr>\n\n## API\n먼저 API의 정의를 알아보았다. \n>**API**는 Application Programming Inerface의 줄임말로 응용 프로그램에서 사용할 수 있도록 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다. \n\n다른 부분들은 쉽게 이해가 갔지만 인터페이스가 무엇을 말하는지 모호했다. 그럼 인터페이스는 무엇일까?\n\n\n>**인터페이스(interface)** 는 컴퓨터 시스템끼리 정보를 교환하는 공유 경계를 의미한다. 터치 스크린과 같은 일부 컴퓨터 하드웨어 장치들은 인터페이스를 통해 데이터를 송수신 할 수 있으며, 마우스나 마이크와 같은 장치들은 오직 시스템에 데이터를 전송만 하는 인터페이스를 제공한다.\n\n쉽게 정리해 인터페이스는 시스템끼리 데이터를 주고받도록 하는 물리적, 가상적인 매개체를 뜻한다.\n\n조금 더 이해하기 쉽게 실생활에서 예를 들어보면 우리가 자판기를 통해 음료수를 사먹는다라고 할 때 실제 자판기가 어떻게 내부적으로 동작하는지는 몰라도 동전이나 지폐를 넣고 원하는 음료 버튼을 눌러 음료수가 나오게하는 과정을 쉽게 수행한다. 이때 동전과 지폐를 넣고 음료 버튼을 클릭하는등 사물과 사물 또는 사물과 인간 간의 의사소통이 가능하도록하는 물리적, 가상적인 매개체를 인터페이스라고 할 수 있다.\n\n즉 API는 응용 프로그램 (우리가 만든 앱과 같은 서비스)에서 운영체제나 프로그래밍 언어가 제공하는 기능(지도, 날씨, 페이기능등)을 제어할 수 있게 만든 매개체라고 볼 수 있다. \nAPI 문서에는 개발자가 이러한 요청과 응답을 구성하는 방법에 대한 정보가 들어 있어 API를 사용하기 이전에 API 문서를 통해 API의 사용법을 알 수 있다.\n\n<hr>\n\n## API는 어떻게 작동하는가? \n>API 아키텍처는 일반적으로 클라이언트와 서버 측면에서 설명된다. 요청을 보내는 애플리케이션을 클라이언트라고 하고 응답을 보내는 애플리케이션을 서버라고 한다. 따라서 날씨 예에서 기상청의 날씨 데이터베이스는 서버이고 모바일 앱은 클라이언트이다. \n\nAPI가 생성된 시기와 이유에 따라 API는 네 가지 방식으로 작동할 수 있다.\n\nAPI라는 단어는 1964년부터 등장하기 시작했다. 이때는 하드웨어 독립성을 위해서 많이 사용되어 졌는데, 예를 들어 서로 다른 하드웨어마다 개발자가 일일이 프로그래밍을 하기보단 HAL이라는 하드웨어 추상화 계층을 통해 한번만 display라는 함수를 작성하고 이를 이용해 각기 다른 모니터에 출력을 쉽게 할수 있었고 이것이 API의 시초라고 할 수 있다.\n\n1980년대 중반 Mac OS와 Windows가 등장하면서 그래픽이 좋은 컴퓨터가 등장하기 시작했다. 이런 각각의 운영체제에서 동작하는 어플리케이션을 만들기 위해서 운영체제에서 제공하는 API를 이용했다. \n\n그리고 1990년도 인터넷이 보편적으로 대중화되기 시작하면서 컴퓨터와 컴퓨터 다양한 기기들이 인터넷을 통해서 의사소통을 할 수 있게 되었다. 이때 다양한 기기에서 서버에 있는 데이터를 읽고 쓰기 위해서는 서버에서 제공하는 WEB APIs를 이용해서 처리 할 수 있었다.\n\n네트워크에서 기기들간에 의사소통 해나가는 규격사항을 HTTP(s)라고 부르며 이런 WEB API를 어떻게 디자인해서 만들건지 정의하는 것이 있다. 예전에는 SOAP(Simple Object Access Protocol)이라는 모든 네트워크 요청과 반응을 XML이라는 데이터 포맷에 저장해 주고 받았다면 요즘에는 REST(Representational State Transfer)이 보편적으로 많이 사용된다.\n\nREST는 총 4가지로 구성되어 있는데 새로운 데이터를 만들고(POST, create), 읽고(GET, read), 업데이트하고(PUT, update), 삭제(DELETE, delete)할 수 있다. 예를 들어 GET을 이용해 유저에 대한 정보를 요청하면 서버로부터 유저에 대한 데이터를 JSON이라는 포맷을 통해 받아 올 수 있다. 이처럼 서버에서 제공하는 WEB API를 통해 서버에 있는 데이터를 읽어오거나 업데이트 할 수 있다.\n","source":"_posts/What-is-an-API.md","raw":"---\ntitle: API란 무엇일까?\ndate: 2022-08-14 19:29:18\ntags:\n- 개발\n- 용어정리\n---\nJavaScript 구현공부를 시작하며 API를 이용하는 일이 많아졌다. API라는 용어에 대해 많이 들어보기도 했고 API가 무엇인지에 대해 대략적으로 알고 있다고 생각했었지만 막상 API에 대해 구체적으로 설명해보려고 하니 표현하기가 어려웠다. 그래서 API에 대해 정리해보면서 정확히 무엇인지 알아보고자 했다.\n<hr>\n\n## API\n먼저 API의 정의를 알아보았다. \n>**API**는 Application Programming Inerface의 줄임말로 응용 프로그램에서 사용할 수 있도록 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다. \n\n다른 부분들은 쉽게 이해가 갔지만 인터페이스가 무엇을 말하는지 모호했다. 그럼 인터페이스는 무엇일까?\n\n\n>**인터페이스(interface)** 는 컴퓨터 시스템끼리 정보를 교환하는 공유 경계를 의미한다. 터치 스크린과 같은 일부 컴퓨터 하드웨어 장치들은 인터페이스를 통해 데이터를 송수신 할 수 있으며, 마우스나 마이크와 같은 장치들은 오직 시스템에 데이터를 전송만 하는 인터페이스를 제공한다.\n\n쉽게 정리해 인터페이스는 시스템끼리 데이터를 주고받도록 하는 물리적, 가상적인 매개체를 뜻한다.\n\n조금 더 이해하기 쉽게 실생활에서 예를 들어보면 우리가 자판기를 통해 음료수를 사먹는다라고 할 때 실제 자판기가 어떻게 내부적으로 동작하는지는 몰라도 동전이나 지폐를 넣고 원하는 음료 버튼을 눌러 음료수가 나오게하는 과정을 쉽게 수행한다. 이때 동전과 지폐를 넣고 음료 버튼을 클릭하는등 사물과 사물 또는 사물과 인간 간의 의사소통이 가능하도록하는 물리적, 가상적인 매개체를 인터페이스라고 할 수 있다.\n\n즉 API는 응용 프로그램 (우리가 만든 앱과 같은 서비스)에서 운영체제나 프로그래밍 언어가 제공하는 기능(지도, 날씨, 페이기능등)을 제어할 수 있게 만든 매개체라고 볼 수 있다. \nAPI 문서에는 개발자가 이러한 요청과 응답을 구성하는 방법에 대한 정보가 들어 있어 API를 사용하기 이전에 API 문서를 통해 API의 사용법을 알 수 있다.\n\n<hr>\n\n## API는 어떻게 작동하는가? \n>API 아키텍처는 일반적으로 클라이언트와 서버 측면에서 설명된다. 요청을 보내는 애플리케이션을 클라이언트라고 하고 응답을 보내는 애플리케이션을 서버라고 한다. 따라서 날씨 예에서 기상청의 날씨 데이터베이스는 서버이고 모바일 앱은 클라이언트이다. \n\nAPI가 생성된 시기와 이유에 따라 API는 네 가지 방식으로 작동할 수 있다.\n\nAPI라는 단어는 1964년부터 등장하기 시작했다. 이때는 하드웨어 독립성을 위해서 많이 사용되어 졌는데, 예를 들어 서로 다른 하드웨어마다 개발자가 일일이 프로그래밍을 하기보단 HAL이라는 하드웨어 추상화 계층을 통해 한번만 display라는 함수를 작성하고 이를 이용해 각기 다른 모니터에 출력을 쉽게 할수 있었고 이것이 API의 시초라고 할 수 있다.\n\n1980년대 중반 Mac OS와 Windows가 등장하면서 그래픽이 좋은 컴퓨터가 등장하기 시작했다. 이런 각각의 운영체제에서 동작하는 어플리케이션을 만들기 위해서 운영체제에서 제공하는 API를 이용했다. \n\n그리고 1990년도 인터넷이 보편적으로 대중화되기 시작하면서 컴퓨터와 컴퓨터 다양한 기기들이 인터넷을 통해서 의사소통을 할 수 있게 되었다. 이때 다양한 기기에서 서버에 있는 데이터를 읽고 쓰기 위해서는 서버에서 제공하는 WEB APIs를 이용해서 처리 할 수 있었다.\n\n네트워크에서 기기들간에 의사소통 해나가는 규격사항을 HTTP(s)라고 부르며 이런 WEB API를 어떻게 디자인해서 만들건지 정의하는 것이 있다. 예전에는 SOAP(Simple Object Access Protocol)이라는 모든 네트워크 요청과 반응을 XML이라는 데이터 포맷에 저장해 주고 받았다면 요즘에는 REST(Representational State Transfer)이 보편적으로 많이 사용된다.\n\nREST는 총 4가지로 구성되어 있는데 새로운 데이터를 만들고(POST, create), 읽고(GET, read), 업데이트하고(PUT, update), 삭제(DELETE, delete)할 수 있다. 예를 들어 GET을 이용해 유저에 대한 정보를 요청하면 서버로부터 유저에 대한 데이터를 JSON이라는 포맷을 통해 받아 올 수 있다. 이처럼 서버에서 제공하는 WEB API를 통해 서버에 있는 데이터를 읽어오거나 업데이트 할 수 있다.\n","slug":"What-is-an-API","published":1,"updated":"2022-10-06T10:32:48.149Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb08iq6k000te4vk7uar8b2c","content":"<p>JavaScript 구현공부를 시작하며 API를 이용하는 일이 많아졌다. API라는 용어에 대해 많이 들어보기도 했고 API가 무엇인지에 대해 대략적으로 알고 있다고 생각했었지만 막상 API에 대해 구체적으로 설명해보려고 하니 표현하기가 어려웠다. 그래서 API에 대해 정리해보면서 정확히 무엇인지 알아보고자 했다.</p>\n<hr>\n\n<h2 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h2><p>먼저 API의 정의를 알아보았다. </p>\n<blockquote>\n<p><strong>API</strong>는 Application Programming Inerface의 줄임말로 응용 프로그램에서 사용할 수 있도록 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다. </p>\n</blockquote>\n<p>다른 부분들은 쉽게 이해가 갔지만 인터페이스가 무엇을 말하는지 모호했다. 그럼 인터페이스는 무엇일까?</p>\n<blockquote>\n<p><strong>인터페이스(interface)</strong> 는 컴퓨터 시스템끼리 정보를 교환하는 공유 경계를 의미한다. 터치 스크린과 같은 일부 컴퓨터 하드웨어 장치들은 인터페이스를 통해 데이터를 송수신 할 수 있으며, 마우스나 마이크와 같은 장치들은 오직 시스템에 데이터를 전송만 하는 인터페이스를 제공한다.</p>\n</blockquote>\n<p>쉽게 정리해 인터페이스는 시스템끼리 데이터를 주고받도록 하는 물리적, 가상적인 매개체를 뜻한다.</p>\n<p>조금 더 이해하기 쉽게 실생활에서 예를 들어보면 우리가 자판기를 통해 음료수를 사먹는다라고 할 때 실제 자판기가 어떻게 내부적으로 동작하는지는 몰라도 동전이나 지폐를 넣고 원하는 음료 버튼을 눌러 음료수가 나오게하는 과정을 쉽게 수행한다. 이때 동전과 지폐를 넣고 음료 버튼을 클릭하는등 사물과 사물 또는 사물과 인간 간의 의사소통이 가능하도록하는 물리적, 가상적인 매개체를 인터페이스라고 할 수 있다.</p>\n<p>즉 API는 응용 프로그램 (우리가 만든 앱과 같은 서비스)에서 운영체제나 프로그래밍 언어가 제공하는 기능(지도, 날씨, 페이기능등)을 제어할 수 있게 만든 매개체라고 볼 수 있다.<br>API 문서에는 개발자가 이러한 요청과 응답을 구성하는 방법에 대한 정보가 들어 있어 API를 사용하기 이전에 API 문서를 통해 API의 사용법을 알 수 있다.</p>\n<hr>\n\n<h2 id=\"API는-어떻게-작동하는가\"><a href=\"#API는-어떻게-작동하는가\" class=\"headerlink\" title=\"API는 어떻게 작동하는가?\"></a>API는 어떻게 작동하는가?</h2><blockquote>\n<p>API 아키텍처는 일반적으로 클라이언트와 서버 측면에서 설명된다. 요청을 보내는 애플리케이션을 클라이언트라고 하고 응답을 보내는 애플리케이션을 서버라고 한다. 따라서 날씨 예에서 기상청의 날씨 데이터베이스는 서버이고 모바일 앱은 클라이언트이다. </p>\n</blockquote>\n<p>API가 생성된 시기와 이유에 따라 API는 네 가지 방식으로 작동할 수 있다.</p>\n<p>API라는 단어는 1964년부터 등장하기 시작했다. 이때는 하드웨어 독립성을 위해서 많이 사용되어 졌는데, 예를 들어 서로 다른 하드웨어마다 개발자가 일일이 프로그래밍을 하기보단 HAL이라는 하드웨어 추상화 계층을 통해 한번만 display라는 함수를 작성하고 이를 이용해 각기 다른 모니터에 출력을 쉽게 할수 있었고 이것이 API의 시초라고 할 수 있다.</p>\n<p>1980년대 중반 Mac OS와 Windows가 등장하면서 그래픽이 좋은 컴퓨터가 등장하기 시작했다. 이런 각각의 운영체제에서 동작하는 어플리케이션을 만들기 위해서 운영체제에서 제공하는 API를 이용했다. </p>\n<p>그리고 1990년도 인터넷이 보편적으로 대중화되기 시작하면서 컴퓨터와 컴퓨터 다양한 기기들이 인터넷을 통해서 의사소통을 할 수 있게 되었다. 이때 다양한 기기에서 서버에 있는 데이터를 읽고 쓰기 위해서는 서버에서 제공하는 WEB APIs를 이용해서 처리 할 수 있었다.</p>\n<p>네트워크에서 기기들간에 의사소통 해나가는 규격사항을 HTTP(s)라고 부르며 이런 WEB API를 어떻게 디자인해서 만들건지 정의하는 것이 있다. 예전에는 SOAP(Simple Object Access Protocol)이라는 모든 네트워크 요청과 반응을 XML이라는 데이터 포맷에 저장해 주고 받았다면 요즘에는 REST(Representational State Transfer)이 보편적으로 많이 사용된다.</p>\n<p>REST는 총 4가지로 구성되어 있는데 새로운 데이터를 만들고(POST, create), 읽고(GET, read), 업데이트하고(PUT, update), 삭제(DELETE, delete)할 수 있다. 예를 들어 GET을 이용해 유저에 대한 정보를 요청하면 서버로부터 유저에 대한 데이터를 JSON이라는 포맷을 통해 받아 올 수 있다. 이처럼 서버에서 제공하는 WEB API를 통해 서버에 있는 데이터를 읽어오거나 업데이트 할 수 있다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>JavaScript 구현공부를 시작하며 API를 이용하는 일이 많아졌다. API라는 용어에 대해 많이 들어보기도 했고 API가 무엇인지에 대해 대략적으로 알고 있다고 생각했었지만 막상 API에 대해 구체적으로 설명해보려고 하니 표현하기가 어려웠다. 그래서 API에 대해 정리해보면서 정확히 무엇인지 알아보고자 했다.</p>\n<hr>\n\n<h2 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h2><p>먼저 API의 정의를 알아보았다. </p>\n<blockquote>\n<p><strong>API</strong>는 Application Programming Inerface의 줄임말로 응용 프로그램에서 사용할 수 있도록 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다. </p>\n</blockquote>\n<p>다른 부분들은 쉽게 이해가 갔지만 인터페이스가 무엇을 말하는지 모호했다. 그럼 인터페이스는 무엇일까?</p>\n<blockquote>\n<p><strong>인터페이스(interface)</strong> 는 컴퓨터 시스템끼리 정보를 교환하는 공유 경계를 의미한다. 터치 스크린과 같은 일부 컴퓨터 하드웨어 장치들은 인터페이스를 통해 데이터를 송수신 할 수 있으며, 마우스나 마이크와 같은 장치들은 오직 시스템에 데이터를 전송만 하는 인터페이스를 제공한다.</p>\n</blockquote>\n<p>쉽게 정리해 인터페이스는 시스템끼리 데이터를 주고받도록 하는 물리적, 가상적인 매개체를 뜻한다.</p>\n<p>조금 더 이해하기 쉽게 실생활에서 예를 들어보면 우리가 자판기를 통해 음료수를 사먹는다라고 할 때 실제 자판기가 어떻게 내부적으로 동작하는지는 몰라도 동전이나 지폐를 넣고 원하는 음료 버튼을 눌러 음료수가 나오게하는 과정을 쉽게 수행한다. 이때 동전과 지폐를 넣고 음료 버튼을 클릭하는등 사물과 사물 또는 사물과 인간 간의 의사소통이 가능하도록하는 물리적, 가상적인 매개체를 인터페이스라고 할 수 있다.</p>\n<p>즉 API는 응용 프로그램 (우리가 만든 앱과 같은 서비스)에서 운영체제나 프로그래밍 언어가 제공하는 기능(지도, 날씨, 페이기능등)을 제어할 수 있게 만든 매개체라고 볼 수 있다.<br>API 문서에는 개발자가 이러한 요청과 응답을 구성하는 방법에 대한 정보가 들어 있어 API를 사용하기 이전에 API 문서를 통해 API의 사용법을 알 수 있다.</p>\n<hr>\n\n<h2 id=\"API는-어떻게-작동하는가\"><a href=\"#API는-어떻게-작동하는가\" class=\"headerlink\" title=\"API는 어떻게 작동하는가?\"></a>API는 어떻게 작동하는가?</h2><blockquote>\n<p>API 아키텍처는 일반적으로 클라이언트와 서버 측면에서 설명된다. 요청을 보내는 애플리케이션을 클라이언트라고 하고 응답을 보내는 애플리케이션을 서버라고 한다. 따라서 날씨 예에서 기상청의 날씨 데이터베이스는 서버이고 모바일 앱은 클라이언트이다. </p>\n</blockquote>\n<p>API가 생성된 시기와 이유에 따라 API는 네 가지 방식으로 작동할 수 있다.</p>\n<p>API라는 단어는 1964년부터 등장하기 시작했다. 이때는 하드웨어 독립성을 위해서 많이 사용되어 졌는데, 예를 들어 서로 다른 하드웨어마다 개발자가 일일이 프로그래밍을 하기보단 HAL이라는 하드웨어 추상화 계층을 통해 한번만 display라는 함수를 작성하고 이를 이용해 각기 다른 모니터에 출력을 쉽게 할수 있었고 이것이 API의 시초라고 할 수 있다.</p>\n<p>1980년대 중반 Mac OS와 Windows가 등장하면서 그래픽이 좋은 컴퓨터가 등장하기 시작했다. 이런 각각의 운영체제에서 동작하는 어플리케이션을 만들기 위해서 운영체제에서 제공하는 API를 이용했다. </p>\n<p>그리고 1990년도 인터넷이 보편적으로 대중화되기 시작하면서 컴퓨터와 컴퓨터 다양한 기기들이 인터넷을 통해서 의사소통을 할 수 있게 되었다. 이때 다양한 기기에서 서버에 있는 데이터를 읽고 쓰기 위해서는 서버에서 제공하는 WEB APIs를 이용해서 처리 할 수 있었다.</p>\n<p>네트워크에서 기기들간에 의사소통 해나가는 규격사항을 HTTP(s)라고 부르며 이런 WEB API를 어떻게 디자인해서 만들건지 정의하는 것이 있다. 예전에는 SOAP(Simple Object Access Protocol)이라는 모든 네트워크 요청과 반응을 XML이라는 데이터 포맷에 저장해 주고 받았다면 요즘에는 REST(Representational State Transfer)이 보편적으로 많이 사용된다.</p>\n<p>REST는 총 4가지로 구성되어 있는데 새로운 데이터를 만들고(POST, create), 읽고(GET, read), 업데이트하고(PUT, update), 삭제(DELETE, delete)할 수 있다. 예를 들어 GET을 이용해 유저에 대한 정보를 요청하면 서버로부터 유저에 대한 데이터를 JSON이라는 포맷을 통해 받아 올 수 있다. 이처럼 서버에서 제공하는 WEB API를 통해 서버에 있는 데이터를 읽어오거나 업데이트 할 수 있다.</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"clb08iq5z0001e4vk6oilfq1h","tag_id":"clb08iq640003e4vkc0qfhnvp","_id":"clb08iq6f000ce4vkdws1g09n"},{"post_id":"clb08iq5z0001e4vk6oilfq1h","tag_id":"clb08iq6c0007e4vk7nbp6nna","_id":"clb08iq6g000ee4vkf358h2mz"},{"post_id":"clb08iq610002e4vk8gniasy2","tag_id":"clb08iq6c0007e4vk7nbp6nna","_id":"clb08iq6i000ke4vk1q2cf9bc"},{"post_id":"clb08iq610002e4vk8gniasy2","tag_id":"clb08iq6g000fe4vkf8poh5hz","_id":"clb08iq6i000me4vkavko058m"},{"post_id":"clb08iq660004e4vke6xvcktw","tag_id":"clb08iq6c0007e4vk7nbp6nna","_id":"clb08iq6l000ve4vkdnuw1jzv"},{"post_id":"clb08iq660004e4vke6xvcktw","tag_id":"clb08iq6i000ne4vk7vagbept","_id":"clb08iq6l000we4vk9kk6bhy5"},{"post_id":"clb08iq660004e4vke6xvcktw","tag_id":"clb08iq6j000qe4vkdciw71vs","_id":"clb08iq6l000ye4vk1tc65xhn"},{"post_id":"clb08iq6a0005e4vkassqfx7d","tag_id":"clb08iq6c0007e4vk7nbp6nna","_id":"clb08iq6m0011e4vk5wq74yc8"},{"post_id":"clb08iq6a0005e4vkassqfx7d","tag_id":"clb08iq6l000xe4vke3hte04g","_id":"clb08iq6m0012e4vk2nuqf5bn"},{"post_id":"clb08iq6a0005e4vkassqfx7d","tag_id":"clb08iq6l000ze4vk0l1ngos5","_id":"clb08iq6m0014e4vk9s4l906h"},{"post_id":"clb08iq6b0006e4vk771yaaif","tag_id":"clb08iq6c0007e4vk7nbp6nna","_id":"clb08iq6n0017e4vk7erc1hqr"},{"post_id":"clb08iq6b0006e4vk771yaaif","tag_id":"clb08iq6l000xe4vke3hte04g","_id":"clb08iq6n0018e4vkhiffgcdg"},{"post_id":"clb08iq6b0006e4vk771yaaif","tag_id":"clb08iq6l000ze4vk0l1ngos5","_id":"clb08iq6n001ae4vka4v8g5a4"},{"post_id":"clb08iq6c0008e4vkftaih3k9","tag_id":"clb08iq6c0007e4vk7nbp6nna","_id":"clb08iq6n001be4vkgne81rpo"},{"post_id":"clb08iq6c0008e4vkftaih3k9","tag_id":"clb08iq6i000ne4vk7vagbept","_id":"clb08iq6o001de4vkflfzcb44"},{"post_id":"clb08iq6d0009e4vkgn798aqz","tag_id":"clb08iq6c0007e4vk7nbp6nna","_id":"clb08iq6o001fe4vk1fj4864y"},{"post_id":"clb08iq6d0009e4vkgn798aqz","tag_id":"clb08iq6l000xe4vke3hte04g","_id":"clb08iq6o001ge4vkgcz8h8e4"},{"post_id":"clb08iq6d0009e4vkgn798aqz","tag_id":"clb08iq6l000ze4vk0l1ngos5","_id":"clb08iq6o001ie4vkafw5hret"},{"post_id":"clb08iq6e000be4vkdf7901i5","tag_id":"clb08iq6c0007e4vk7nbp6nna","_id":"clb08iq6p001ke4vk4u2c6109"},{"post_id":"clb08iq6e000be4vkdf7901i5","tag_id":"clb08iq6l000xe4vke3hte04g","_id":"clb08iq6p001le4vkbhpegifn"},{"post_id":"clb08iq6e000be4vkdf7901i5","tag_id":"clb08iq6l000ze4vk0l1ngos5","_id":"clb08iq6p001ne4vk337mfejx"},{"post_id":"clb08iq6f000de4vk289d0odc","tag_id":"clb08iq6c0007e4vk7nbp6nna","_id":"clb08iq6p001pe4vk8vxs1bia"},{"post_id":"clb08iq6f000de4vk289d0odc","tag_id":"clb08iq6l000xe4vke3hte04g","_id":"clb08iq6p001qe4vk46vi6637"},{"post_id":"clb08iq6f000de4vk289d0odc","tag_id":"clb08iq6l000ze4vk0l1ngos5","_id":"clb08iq6q001se4vkclb6aobr"},{"post_id":"clb08iq6g000ge4vk22zyclq8","tag_id":"clb08iq6c0007e4vk7nbp6nna","_id":"clb08iq6q001ue4vk14mq1kif"},{"post_id":"clb08iq6g000ge4vk22zyclq8","tag_id":"clb08iq6l000xe4vke3hte04g","_id":"clb08iq6q001ve4vkefzjero6"},{"post_id":"clb08iq6g000ge4vk22zyclq8","tag_id":"clb08iq6l000ze4vk0l1ngos5","_id":"clb08iq6q001xe4vk397d6r2u"},{"post_id":"clb08iq6g000he4vkhdxz4etd","tag_id":"clb08iq6c0007e4vk7nbp6nna","_id":"clb08iq6q001ze4vk5gnxdpiv"},{"post_id":"clb08iq6g000he4vkhdxz4etd","tag_id":"clb08iq6q001te4vkekbc1yp9","_id":"clb08iq6q0020e4vk8mo3b9bt"},{"post_id":"clb08iq6g000he4vkhdxz4etd","tag_id":"clb08iq6q001we4vk7j7n5so7","_id":"clb08iq6q0022e4vkeov92bq3"},{"post_id":"clb08iq6h000je4vk6kbh6ki4","tag_id":"clb08iq6c0007e4vk7nbp6nna","_id":"clb08iq6r0024e4vk9jrd1is2"},{"post_id":"clb08iq6h000je4vk6kbh6ki4","tag_id":"clb08iq6l000xe4vke3hte04g","_id":"clb08iq6r0025e4vkghy40e38"},{"post_id":"clb08iq6h000je4vk6kbh6ki4","tag_id":"clb08iq6l000ze4vk0l1ngos5","_id":"clb08iq6r0027e4vk7ditebtu"},{"post_id":"clb08iq6i000le4vkhcp07ywi","tag_id":"clb08iq6c0007e4vk7nbp6nna","_id":"clb08iq6r0028e4vkafd3805d"},{"post_id":"clb08iq6i000le4vkhcp07ywi","tag_id":"clb08iq6r0023e4vk6pf77krh","_id":"clb08iq6r002ae4vkd5n3ebxv"},{"post_id":"clb08iq6j000oe4vk6qsh87bv","tag_id":"clb08iq6c0007e4vk7nbp6nna","_id":"clb08iq6r002ce4vkfe5h672e"},{"post_id":"clb08iq6j000oe4vk6qsh87bv","tag_id":"clb08iq6l000xe4vke3hte04g","_id":"clb08iq6r002de4vkb5l25u4c"},{"post_id":"clb08iq6j000oe4vk6qsh87bv","tag_id":"clb08iq6l000ze4vk0l1ngos5","_id":"clb08iq6s002fe4vk98uxbbpw"},{"post_id":"clb08iq6j000pe4vkfto41tb8","tag_id":"clb08iq6c0007e4vk7nbp6nna","_id":"clb08iq6s002ge4vkarri0vfy"},{"post_id":"clb08iq6j000pe4vkfto41tb8","tag_id":"clb08iq6r002be4vk1skngxo1","_id":"clb08iq6s002ie4vk9ha6f2q4"},{"post_id":"clb08iq6k000re4vk895xf720","tag_id":"clb08iq6r002ee4vk718ed7xu","_id":"clb08iq6s002je4vk5iul3tq0"},{"post_id":"clb08iq6k000se4vkhvf58tlr","tag_id":"clb08iq6c0007e4vk7nbp6nna","_id":"clb08iq6s002le4vkfn90bhk0"},{"post_id":"clb08iq6k000se4vkhvf58tlr","tag_id":"clb08iq6s002he4vk99n24clc","_id":"clb08iq6s002me4vk7nmc7hky"},{"post_id":"clb08iq6k000te4vk7uar8b2c","tag_id":"clb08iq6c0007e4vk7nbp6nna","_id":"clb08iq6s002ne4vk2v9kebxu"},{"post_id":"clb08iq6k000te4vk7uar8b2c","tag_id":"clb08iq6s002ke4vk4ha4cxba","_id":"clb08iq6s002oe4vk2fr523y3"}],"Tag":[{"name":"일상","_id":"clb08iq640003e4vkc0qfhnvp"},{"name":"개발","_id":"clb08iq6c0007e4vk7nbp6nna"},{"name":"MDN","_id":"clb08iq6g000fe4vkf8poh5hz"},{"name":"CSS","_id":"clb08iq6i000ne4vk7vagbept"},{"name":"IR","_id":"clb08iq6j000qe4vkdciw71vs"},{"name":"자바스크립트","_id":"clb08iq6l000xe4vke3hte04g"},{"name":"모던 자바스크립트 Deep Dive","_id":"clb08iq6l000ze4vk0l1ngos5"},{"name":"JavaScript","_id":"clb08iq6q001te4vkekbc1yp9"},{"name":"코딩테스트","_id":"clb08iq6q001we4vk7j7n5so7"},{"name":"회고","_id":"clb08iq6r0023e4vk6pf77krh"},{"name":"Sass","_id":"clb08iq6r002be4vk1skngxo1"},{"name":"JS","_id":"clb08iq6r002ee4vk718ed7xu"},{"name":"WCAG","_id":"clb08iq6s002he4vk99n24clc"},{"name":"용어정리","_id":"clb08iq6s002ke4vk4ha4cxba"}]}}