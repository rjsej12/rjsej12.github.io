<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>6월 프리온보딩 프론트엔드 챌린지에 참가하며</title>
    <url>/2023/6%EC%9B%94-%ED%94%84%EB%A6%AC%EC%98%A8%EB%B3%B4%EB%94%A9-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%B1%8C%EB%A6%B0%EC%A7%80%EC%97%90-%EC%B0%B8%EA%B0%80%ED%95%98%EB%A9%B0/</url>
    <content><![CDATA[<p><img src="/../images/frontend_web.gif" alt="원티드 프리온보딩 프론트엔드 챌린지"></p>
<h1 id="참가-계기"><a href="#참가-계기" class="headerlink" title="참가 계기"></a>참가 계기</h1><p>프리온보딩 인턴십을 마친 후 열심히 구직활동을 하고있지만, 좋은 결과를 얻는게 쉬운일은 아닌 것 같다.<br>조금이라도 합격할 확률을 높이기 위해 기술면접 대비도 하고 알고리즘 공부도 하고 있지만 사실 서류가 합격되어야 이후 과정을 진행할 수 있으니 근본적으로 서류 합격률을 높일 방법을 찾고 있었다.</p>
<p>커리어코칭을 통해 이력서, 포트폴리오를 많이 수정해서 나름 괜찮다고 생각하는데도 서류 합격률이 낮은 이유는 신입 + 비전공자라는 의문점을 다 해결하지 못했기 때문이 아닐까?</p>
<p>더 많은 활동들을 통해 내가 얼마나 개발에 진심인지를 보여줘야 할 것 같다는 생각을 하고 어떤 활동들이 있을까 알아보던 중 원티드 배너에서 프론트엔드 챌린지를 발견했다. 2주라는 짧은 시간 동안 진행하는 프로그램이라 부담도 많지 않고, 컴포넌트 및 스토리북 이라는 챌린지의 주제 또한 도움이 많이 될 것 같아 챌린지에 참가하기로 결심했다.</p>
<h1 id="지원-절차"><a href="#지원-절차" class="headerlink" title="지원 절차"></a>지원 절차</h1><p>챌린지는 합불이 아닌 누구나 참가할 수 있는 프로그램이라 지원 폼을 작성해 정말 간단하게 신청을 할 수 있었다.<br>또 사전 미션이 존재하기는 했지만 인턴십 프로그램과는 다르게 필수가 아니였다.</p>
<p>사전 미션은 Figma를 활용하여 버튼 디자인 시안을 제작하는 것이였는데 디자인 시안을 제작한다는 것이 어떤것인지 사실 잘 와닿지 않았다. 그래도 GitHub에서 다른 참가자분들이 제출한 미션 결과를 확인할 수 있었는데, 이를 참고하여 간단하게 디자인 시안을 만들어보고 컴포넌트에 대해서도 한번 생각해 볼 수 있었다.</p>
<h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>2주동안 잘 참여해서 컴포넌트에 대한 이해도와 스토리북에 대해서도 잘 알아가고 싶다! 취준활동도 화이팅!</p>
]]></content>
      <tags>
        <tag>회고</tag>
      </tags>
  </entry>
  <entry>
    <title>MDN을 확신하지는 말자.</title>
    <url>/2022/Don-t-be-sure-of-MDN-always/</url>
    <content><![CDATA[<p>어제에 이어 position에 대해 공부하면서 position이 absolute인 경우 containing block은 가장 가까운 position이 static이 아닌 부모요소 외에도 다른 조건들이 있다고 해 MDN을 통해 공부를 하던 중 이상하다고 생각되는 점이 생겼다.</p>
<hr>

<h1 id="👀"><a href="#👀" class="headerlink" title="👀"></a>👀</h1><p><a href="https://developer.mozilla.org/ko/docs/Web/CSS/Containing_block">컨테이닝 블록의 모든것</a>이라는 MDN 문서에서 컨테이닝 블록 식별 항목을 읽어보면 다음과 같이 설명하고 있다.</p>
<blockquote>
<p>position 속성이 <strong>absolute</strong>나 <strong>fixed</strong>인 경우, 다음 조건 중 하나를 만족하는 가장 가까운 조상의 내부 여백 영역이 컨테이닝 블록이 될 수도 있습니다.</p>
</blockquote>
<ul>
<li>transform이나 perspective (en-US) 속성이 none이 아님.</li>
<li>will-change 속성이 transform이나 perspective임.</li>
<li>filter 속성이 none임. (Firefox에선 will-change가 filter일 때도 적용)</li>
<li>contain 속성이 paint임.</li>
</ul>
<p>각 속성들이 어떤 역할을 하는지 찾아보던 중 filter 속성을 검색해 보았는데 default value가 none임을 알았다. 그러자 다음과 같은 의문이 생겼다.</p>
<h1 id="🤔"><a href="#🤔" class="headerlink" title="🤔"></a>🤔</h1><p>음 이상한데? filter 속성이 none이면 containing block이 될 수 있고 filter 속성의 default value가 none이면 거의 모든것이 containing block이 될 수 있다는 소리인가? 그건 아닌것 같은데…<br>아 된다가 아니라 될 수도 있다네? 그러면 될 수 있는 조건과 안되는 조건은 무엇이지?</p>
<p>그러다 [position] (<a href="https://developer.mozilla.org/ko/docs/Web/CSS/position">https://developer.mozilla.org/ko/docs/Web/CSS/position</a>) MDN을 들어가 보니 fixed 항목이 이렇게 나와 있었다.</p>
<blockquote>
<p>요소를 일반적인 문서 흐름에서 제거하고, 페이지 레이아웃에 공간도 배정하지 않습니다. 대신 뷰포트의 초기 컨테이닝 블록을 기준으로 삼아 배치합니다. 단, 요소의 조상 중 하나가 transform, perspective, filter 속성 중 어느 하나라도 none이 아니라면 (CSS Transforms 명세 참조) 뷰포트 대신 그 조상을 컨테이닝 블록으로 삼습니다. (perspective와 filter의 경우 브라우저별로 결과가 다름에 유의) 최종 위치는 top, right, bottom, left 값이 지정합니다.</p>
</blockquote>
<p>앗 여기에는 filter 속성이 none이 아니라고 되어있네 뭐가 맞는거지? transform이나 perspective가 none이 아니여야 했으니 filter도 none이 아닌게 맞는것 같은데.. 라며 계속 고민하다 같이 공부하시는 분들의 도움을 받아 궁금증을 해결했다.</p>
<h1 id="✔"><a href="#✔" class="headerlink" title="✔"></a>✔</h1><p>바로 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block">영문 MDN 사이트</a>에는 filter 속성이 none이 아니라고 나와있던것! 사이트 번역과정에서 오류가 있었던것이다.</p>
<blockquote>
<ul>
<li>A filter value other than none or a will-change value of filter (only works on Firefox).</li>
</ul>
</blockquote>
<hr>

<p>MDN이 거의 공식문서 혹은 표준처럼 여겨지기는 하지만 번역문서 그리고 원문 역시도 contributor분들에 의해 쓰여지는 것이기 때문에 확신을 하지는 말고 여러 레퍼런스들을 통해 교차검증해야되겠다고 깨달았다.</p>
]]></content>
      <tags>
        <tag>MDN</tag>
      </tags>
  </entry>
  <entry>
    <title>Next/Image를 통한 이미지의 최적화</title>
    <url>/2023/Image-Optimiztion-With-Next-Image/</url>
    <content><![CDATA[<p><img src="/../images/next.png" alt="Next"></p>
<h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>Next.js를 사용해 프로젝트를 진행하면서 이미지를 위해 <code>&lt;img&gt; 태그</code>를 사용하던 중 다음과 같은 ESLint 오류가 발생했다.</p>
<p><img src="/../images/next-image.png" alt="Next/Image 사용"></p>
<p>Next&#x2F;Image에서 제공하는 <code>&lt;Image /&gt;</code>를 사용해 자동적으로 이미지를 최적화하라는 내용이었다.</p>
<p>처음 알게된 내용인만큼 Next&#x2F;Image 컴포넌트의 기능과 또 실제로 프로젝트에 적용하면서 겪은 문제점들에 대해 정리해보고자 한다.</p>
<h1 id="Next-x2F-Image를-활용한-이미지-최적화"><a href="#Next-x2F-Image를-활용한-이미지-최적화" class="headerlink" title="Next&#x2F;Image를 활용한 이미지 최적화"></a>Next&#x2F;Image를 활용한 이미지 최적화</h1><h2 id="Next-x2F-Image의-장점"><a href="#Next-x2F-Image의-장점" class="headerlink" title="Next&#x2F;Image의 장점"></a>Next&#x2F;Image의 장점</h2><p>Next&#x2F;Image 컴포넌트를 사용하면 대표적으로 다음의 3가지 이점을 얻을 수 있다.</p>
<ul>
<li>Lazy loading</li>
<li>이미지 사이즈 최적화</li>
<li>placeholder를 통한 스켈레톤 UI로 CLS 방지</li>
</ul>
<h3 id="Lazy-loading"><a href="#Lazy-loading" class="headerlink" title="Lazy loading"></a>Lazy loading</h3><p>Lazy loading이란 이미지를 로드하는 시점을 지연시키는 기술을 말한다. 페이지를 읽어들이는 시점에 중요하지 않은 리소스를 추후에 로딩함으로써 빠른 콘텐츠의 제공이 가능해진다.</p>
<p>기존 img 태그를 사용하는 경우 <code>loading=“lazy”</code> 속성을 통해 브라우저의 도움을 받거나 혹은 개발자가 Intersection Observer API, Scroll 이벤트를 통해 스크린에 element가 보일 때를 캐치하여 이미지를 로드하도록 직접 구현해야 했다. 하지만 Next&#x2F;Image의 경우 <code>자동으로 lazy loading이 적용</code>된다.</p>
<h3 id="이미지-사이즈-최적화"><a href="#이미지-사이즈-최적화" class="headerlink" title="이미지 사이즈 최적화"></a>이미지 사이즈 최적화</h3><p>여러 프로젝트를 경험하면서 이미지를 사용할때 중요하다고 느낀 점 중 하나는 이미지 사이즈의 최적화였다. 이를 위해 이미지의 포맷을 변경하고 이미지의 용량을 압축하는 등의 과정이 필요해 번거로웠다.</p>
<p>Next&#x2F;Image는 디바이스 크기 별로 srcSet을 미리 지정해두고, 사용자의 <code>디바이스에 맞는 이미지를 다운로드할 수 있게 지원</code>함과 동시에 이미지를 <code>webp와 같은 용량이 작은 포맷으로 변환해 제공</code>함으로써 쉽게 이미지 사이즈를 최적화 할 수 있다.</p>
<h3 id="Placeholder를-통한-스켈레톤-UI로-CLS-방지"><a href="#Placeholder를-통한-스켈레톤-UI로-CLS-방지" class="headerlink" title="Placeholder를 통한 스켈레톤 UI로 CLS 방지"></a>Placeholder를 통한 스켈레톤 UI로 CLS 방지</h3><p>Next&#x2F;Image는 레이아웃이 흔들리는 현상 즉 <code>CLS(Cumulative Layout Shift)를 방지하기 위한 placeholder를 제공</code>한다. Placeholder로 빈 영역 또는 blur 이미지 혹은 커스텀 이미지도 설정 가능하다.</p>
<h1 id="Next-x2F-Image-적용하면서-발생한-문제점"><a href="#Next-x2F-Image-적용하면서-발생한-문제점" class="headerlink" title="Next&#x2F;Image 적용하면서 발생한 문제점"></a>Next&#x2F;Image 적용하면서 발생한 문제점</h1><h2 id="리모트-이미지-설정"><a href="#리모트-이미지-설정" class="headerlink" title="리모트 이미지 설정"></a>리모트 이미지 설정</h2><p>Next&#x2F;Image는 next&#x2F;image로부터 Image를 import해 사용하기만 하면 되어 정말 간단했다.</p>
<p>다만 리모트 이미지의 경우 Next.js 서버에서 이미지를 가지고 있는 리모트 서버에 직접 요청을 하기 때문에 보안상의 이유로 모든 url에 대한 접근을 방지한다는 문제가 존재했다. 때문에 리모트 이미지를 사용하기 위해서는 next.config.js 파일에 <code>CDN의 host를 명시</code>해 주어야 했다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// next.config.js</span></span><br><span class="line"><span class="keyword">const</span> nextConfig = &#123;</span><br><span class="line">	<span class="attr">images</span>: &#123;</span><br><span class="line">		<span class="attr">domains</span>: [<span class="string">&#x27;cdn-host&#x27;</span>],</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="리모트-이미지-placeholder"><a href="#리모트-이미지-placeholder" class="headerlink" title="리모트 이미지 placeholder"></a>리모트 이미지 placeholder</h2><p>리모트 이미지의 경우 로컬 이미지와 다르게 빌드 타임에 이미지 파일에 접근하는 것이 불가능하기 때문에 placeholder를 blur로 설정해도 blur 이미지가 존재하지 않았다.</p>
<p>이 문제는 Image의 <code>blurDataURL</code> 속성에 직접적인 데이터를 추가함으로써 해결할 수 있었다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// prettier-ignore</span></span><br><span class="line">&lt;<span class="title class_">Image</span></span><br><span class="line">  width=<span class="string">&quot;60&quot;</span></span><br><span class="line">  height=<span class="string">&quot;60&quot;</span></span><br><span class="line">  alt=&#123;name&#125;</span><br><span class="line">  src=&#123;imageUrl&#125;</span><br><span class="line">  placeholder=<span class="string">&quot;blur&quot;</span></span><br><span class="line">  blurDataURL=&#123;<span class="variable constant_">BLUR_DATA_URL</span>&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>Next.js를 사용하는 이유로 <strong>‘SEO(Search Engine Optimization)를 위한 Server-Side Rendering(SSR)을 가능하게 함’</strong> 정도만 알고 있었는데, 이번 프로젝트를 진행하면서 Image의 자동 최적화, 편리한 라우팅 시스템과 같은 다양한 장점들이 존재함을 알 수 있었다.</p>
<p>왜 많은 기업들이 Next.js를 사용하고 있는지 약간은 알 것 같다. 더 자세히 공부해봐야지!</p>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li><a href="https://nextjs.org/docs/pages/api-reference/components/image">https://nextjs.org/docs/pages/api-reference/components/image</a></li>
<li><a href="https://nextjs.org/docs/pages/building-your-application/optimizing/images">https://nextjs.org/docs/pages/building-your-application/optimizing/images</a></li>
<li><a href="https://fe-developers.kakaoent.com/2022/220714-next-image/">https://fe-developers.kakaoent.com/2022/220714-next-image/</a></li>
</ul>
]]></content>
      <tags>
        <tag>Next</tag>
        <tag>최적화</tag>
      </tags>
  </entry>
  <entry>
    <title>두번째 프로젝트와 커넥to과정을 마치고</title>
    <url>/2022/After-Second-Project/</url>
    <content><![CDATA[<h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>약 2주동안의 프로젝트가 종료되었다. 벌써 4개월간의 커넥to 과정이 끝났다는게 믿기지 않을 정도로 시간이 너무 빨리 흘러간 것 같다. 프로젝트를 시작하면서 갑자기 허리디스크가 생겨서 프로젝트에 집중하기가 어려웠는데, 그래도 좋은 팀원들 덕분에 잘 마무리한 것 같다. 이번 프로젝트 역시 배운점도 많았고 아쉬운점도 많았는데 회고를 하며 정리해보려고 한다.</p>
<hr>

<h1 id="프로젝트-DUI"><a href="#프로젝트-DUI" class="headerlink" title="프로젝트 DUI"></a>프로젝트 DUI</h1><p>이번 프로젝트는 주어진 조건이 몇가지가 존재했다.</p>
<ol>
<li>바닐라 JS를 사용해 구현한 SPA(Single Page Application)일 것.</li>
<li>CRUD를 구현할 것.</li>
<li>Routing 기능을 구현할 것.</li>
<li>JWT를 사용해 로그인 기능을 구현할 것.</li>
</ol>
<p>이 조건들을 만족시킬 프로젝트 주제가 무엇인지 고민하다가, 다른 팀원분이 블로그를 구현하는 것이 어떻겠냐고 제안하셨고 다들 적절하다고 생각해 Draw yoUr Idea 의 줄임말인 DUI라는 이름으로 프로젝트를 진행하게 되었다.</p>
<p>개발 기간은 2022-12-12 ~ 2022-12-23로 약 2주 동안 진행되었고, 팀원은 총 3명이었다.</p>
<p>좀 더 자세한 사항은 <a href="https://github.com/rjsej12/public-DUI">https://github.com/rjsej12/public-DUI</a> 에서 확인 가능하다.</p>
<hr>

<h2 id="KPT"><a href="#KPT" class="headerlink" title="KPT"></a>KPT</h2><h3 id="Keep"><a href="#Keep" class="headerlink" title="Keep"></a>Keep</h3><ul>
<li><p>이번에도 프로젝트를 시작하기 전에 환경설정을 중요시 여기고 이 부분에 대해 많이 논의 했는데 그 결과 폴더구조가 깔끔하게 구성된것 같아서 만족스러웠다.</p>
</li>
<li><p>저번 프로젝트를 진행하면서 다음번엔 꼭 문서화를 잘 해보자 생각했었는데, 만족스러울 만큼은 아니지만 저번보다는 결과물이 좋게 나왔다고 생각되었다.</p>
</li>
</ul>
<h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><ul>
<li><p>프로젝트 시작때부터 갑자기 허리 디스크가 생겨서 프로젝트에 집중하기 어려웠다.</p>
</li>
<li><p>이번 프로젝트에서는 History API를 이용해 Routing 기능을 구현했는데, History API를 보완한 Navigation API를 사용해보고 싶다.</p>
</li>
<li><p>정확하게 코딩 컨벤션을 설정하고 시작하지 않아 처음에 서로의 코드 구조가 일치하지 않았던게 아쉬웠다.</p>
</li>
</ul>
<h3 id="Try"><a href="#Try" class="headerlink" title="Try"></a>Try</h3><ul>
<li>소통하자! - 프로젝트를 시작하기 전 각자가 사용하길 원하는 기술 스택을 상의하면서 팀원 중 한 분이 tailwind의 편의성을 설명하였고, 빠른 적용에 모두 동의하여 프로젝트의 스타일 프레임워크로 Tailwind CSS를 사용하기로 결정했다. 또한 적극적인 class 이름을 활용해 작은 컴포넌트 단위의 완성된 스타일을 대표하기를 원하셨는데 그 분을 제외한 우리 둘은 정확한 이해를 하지 못했었고 이게 맞는지 고민하며 작업을 수행했고 결과물은 역시 원하는 바와 달랐다. 이전 우아할 프로젝트때는 이해가 안되는 부분이 존재할 때 계속해서 소통하며 이해가 될 때까지 넘어가지 않았었는데, 이번에는 건강 문제를 핑계로 소통에 소홀했던 것 같다. 협업에서 가장 중요한 것이 다른 사람의 생각을 이해하는 것이니 만큼 소통하는데에 있어서 적극적이어야할 필요를 다시 한 번 느꼈다.</li>
</ul>
<hr>

<h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>이번 프로젝트를 끝으로 약 4개월간의 긴(?) 과정이 종료되었다. 커넥to 과정을 시작할때와 비교해보면 스스로 정말 많이 성장했음을 느끼는것 같다. 단순히 새로운 지식을 배웠기 때문이 아니라, 모르는 부분이 생겼을때 그것을 찾아 나가는 방법과 더 나은 코드를 위해 어떠한 고민을 해야 하는지 또 다른 사람과 협업을 할 때 어떻게 커뮤니케이션 해야 할 지 등 앞으로 개발자로 살아가면서 가져야 할 마인드, 태도가 달라졌다고 느끼기 때문이다. 아직 많이 부족하지만, 이렇게 지속해서 공부해 나간다면 그래도 좋은 개발자가 될 수 있지 않을까 하는 일말의 자신감도 생긴것 같다.</p>
<p>사실 개발자로의 취직을 준비하면서 가장 걱정되었던 부분은 (많이 고민하고 결정하기는 했지만) ‘내가 지속해서 공부를 잘 할수 있을까?’ 였다. 어릴 때 부터 흥미를 못 느끼는 일에는 집중을 잘 하지 못하던 터라 겉핥기만 했을때는 재미있다 느꼈지만 깊게 공부하게 되었을때도 재미가 유지될지에 대해 의심이 존재했다. 하지만 4개월 동안 느낀 것은 ‘재밌다’였다. 뭐 아직도 깊게 파고든것은 아니라고 할 수 있겠지만, 문제를 만나고 해결하고 결과물을 실제로 볼 수 있는등 여러 부분들이 오랜만에 ‘공부를 해야해서 하는게 아니라 재밌어서 하는 경우도 있었지’라고 생각하게 했다.</p>
<p>여전히 부족함을 느끼는 만큼, 또 프로젝트를 하면서 vanilla js의 불편함을 느꼈어서 얼른 react와 같은 프레임워크도 공부하고 싶고 vue는 또 뭐가 다를지 등등 배움에 대한 욕구가 생기는 것 같다. 과정이 끝나더라도 열심히 해서 지속적으로 성장할 수 있는 기반을 쌓아야겠다.</p>
]]></content>
      <tags>
        <tag>회고</tag>
      </tags>
  </entry>
  <entry>
    <title>헥소로 블로그 옮기기</title>
    <url>/2022/Create-hexo-blog/</url>
    <content><![CDATA[<p>커넥to git 수업동안 hexo와 Github pages를 이용해 블로그를 만들어보았다.</p>
<p>원래는 velog를 통해 여러 글들을 포스팅 하고 있었는데 디자인에 대한 커스텀이나 지속적인 관리가 (특히 github 잔디를 지속해서 심을 수 있다는 점) 수월해 보여 블로그를 옮겨보기로 결정했다.</p>
<p>그동안 썼던 글들도 차근차근 옮기며 잘 관리해봐야겠다!</p>
]]></content>
      <tags>
        <tag>일상</tag>
      </tags>
  </entry>
  <entry>
    <title>원티드 프리온보딩 프론트엔드 인턴십을 참가하며</title>
    <url>/2023/Accepted-Wanted-Pre-Onboarding-Frontend-InternShip/</url>
    <content><![CDATA[<p><img src="/images/wanted-preonboarding.jpeg" alt="원티드 프리온보딩 프론트엔드 인턴십"></p>
<h1 id="지원-계기"><a href="#지원-계기" class="headerlink" title="지원 계기"></a>지원 계기</h1><p>작년 12월에 제로베이스 커넥to 과정을 마치고 개인적으로 React, Next등의 기술 스택을 공부하고 관련한 개인 프로젝트를 진행하며 프론트엔드 개발자로의 취업을 위해 노력중이었다. 하지만 이전에 부트캠프를 통해 공부를 할때와는 다르게 내가 올바른 방향으로 학습하고 있는지도 확신할 수 없었고 아무래도 혼자서 프로젝트를 진행하다 보니 의지도 나약해지는 부분이 생겨 단기간에 학습을 마무리하고 본격적으로 구직활동을 시작하려고 마음먹었다.</p>
<p>신입들을 뽑는 기업들에는 어떤 곳이 있을까 궁금하여 원티드에 들어갔다가, 배너를 통해 프리온보딩 프론트엔드 인턴십이라는 프로그램을 알게 되었다. 4주 동안 기업 과제를 수행하며 기술 역량과 협업 역량 향상을 시키고 실제 기업 채용으로 까지도 이어지고 있다는 얘기에 관심이 생겼다.</p>
<p>커리큘럼을 살펴보니 React Hook의 심층 활용, 관심사의 분리, 프론트엔드 테스트 기법 이해하기 등 공부는 하고 있었으나 실제로 잘 이해되지 않거나 부족하다고 느꼈던 부분들에 대해 채울 수 있는 과정이라 생각했고, 바로 취업을 하는 것보다 장기적으로 더 나은 개발자가 되는데 도움이 되지 않을까 생각하여 지원하기로 결심했다.</p>
<h1 id="지원-절차"><a href="#지원-절차" class="headerlink" title="지원 절차"></a>지원 절차</h1><p>지원절차는 사전과제와 더불어 원티드 이력서만 제출하면 되어 간단했다. 물론 사전과제의 실현도에 따라 불합격 가능성이 있어서 걱정이 되긴 했었는데 과제 난이도가 높지는 않아서 충분히 합격할 수 있지 않을까 생각했다. 다음은 내가 수행한 사전과제의 github 주소이다. <a href="https://github.com/rjsej12/wanted-pre-onboarding-frontend">사전과제</a></p>
<h1 id="결과"><a href="#결과" class="headerlink" title="결과"></a>결과</h1><p>나름대로 과제 수행을 잘 했다고 생각하여 합격하지 않을까 생각했지만, 약간의 불안감도 존재하기는 해서 혹시라도 불합격하면 바로 구직활동을 시작해야겠다 마음먹고 포트폴리오를 마무리 하고 있었고, 결과발표 당일 언제 발표가 나는거지 기다리고 있었는데 다행히 합격 문자를 받았다.<br><img src="/images/wanted-accepted.jpg" alt="합격문자"></p>
<h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>4주동안의 짧다면 짧고 길다면 긴 기간동안 열심히 몰입해서 많이 성장할 수 있도록 노력해야겠다. 4주 후의 회고에서는 꼭 만족스러운 모습으로 볼 수 있길!</p>
]]></content>
      <tags>
        <tag>회고</tag>
      </tags>
  </entry>
  <entry>
    <title>[Github] remote: fatal error in commit_refs</title>
    <url>/2023/Git-remote-fatal-error-in-commitrefs/</url>
    <content><![CDATA[<h1 id="😱-문제발생"><a href="#😱-문제발생" class="headerlink" title="😱 문제발생"></a>😱 문제발생</h1><p>오늘 배운 내용을 간단히 정리하며 TIL을 작성하고 Github에 push하려고 하는데 다음과 같은 오류가 발생했다.</p>
<p><img src="/../images/git-remote-fatal-error.png" alt="Git Error"></p>
<p>갑자기 이게 무슨 오류지? 혹시 내가 원격 저장소에서 무슨 작업을 했었나? 생각하며 <code>git pull</code>을 하고 다시 <code>git push</code>를 해도 실패.. 이외에도 여러가지 방법으로 해결을 시도했지만 전부 실패했다.</p>
<h1 id="😊-문제해결"><a href="#😊-문제해결" class="headerlink" title="😊 문제해결"></a>😊 문제해결</h1><p>다시한번 log를 살펴보다가 <code>remote: fatal error in commit_refs</code>를 발견하고 구글링을 해보았더니…</p>
<blockquote>
<p>Github의 서버오류로 정상적으로 작동하지 않았던것!</p>
</blockquote>
<p>생각보다 너무 허무했지만 앞으로는 같은 문제를 겪어도 당황하지 않을 수 있을것 같다.<br>추가적으로 <a href="https://www.githubstatus.com/">https://www.githubstatus.com</a>를 통해 GitHub site status를 확인 할 수 있다고 하니 앞으로 참고해야겠다.</p>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li><a href="https://stackoverflow.com/questions/37341960/how-do-i-fix-remote-fatal-error-in-commit-refs-errors-trying-to-push-with-git">https://stackoverflow.com/questions/37341960/how-do-i-fix-remote-fatal-error-in-commit-refs-errors-trying-to-push-with-git</a></li>
</ul>
]]></content>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>이미지 스프라이트(Image Sprite)</title>
    <url>/2022/Image-Sprite/</url>
    <content><![CDATA[<p>이미지 스프라이트란 여러 개의 이미지를 하나로 합쳐서 관리하는 이미지를 의미한다.</p>
<p>웹 페이지에 이미지를 사용한다면 웹 브라우저는 해당 이미지의 다운로드를 위해 서버에 요청을 보낸다. 만약 사용된 이미지가 많을 경우 요청 하는 횟수가 많아지므로 웹 페이지의 로딩 시간이 오래 걸리게 된다. 하지만 만약 이미지 스프라이트를 사용한다면 스프라이트 이미지 파일 하나가 여러 이미지를 가지고 있기에 서버 요청 횟수를 줄일 수 있다.</p>
<p>개인적인 블로그와 같은 일반적인 사이트에서는 굳이 이미지 스프라이트를 사용 할 필요가 없지만, 트래픽이 매우 많거나 많은 사람이 이용하는 검색포털과 같은 사이트에서는 이미지 스프라이트를 사용하여 서버 요청을 줄이고 웹 페이지의 로딩 시간을 단축시켜 사이트의 품질을 높일 수 있다.</p>
<p>다음은 네이버 메인페이지의 스프라이트 이미지이다.<br><img src="https://velog.velcdn.com/images/rjsej12/post/34bfd37f-ea3a-4073-8a76-7c5cfbf8b1fc/image.png"></p>
<p>이처럼 여러개의 이미지를 하나로 합쳐두고 CSS의 <code>background-position</code>을 이용해 사용하려는 이미지만을 보여 줄 수 있다. 이 때 <code>background-position</code>의 값은 하나씩 position값을 변경해보며 찾을 수 도 있지만 <a href="http://www.spritecow.com/">Sprite Cow</a>와 같은 사이트를 이용 할 수 있다.</p>
<p>추가적으로 스프라이트 이미지를 만들기 위해 포토샵, 피그마 등으로 에디팅 할 수 도 있지만 <a href="https://www.toptal.com/developers/css/sprite-generator/">CSS Sprites Generator</a>라는 사이트를 이용 가능하다.</p>
<hr>

<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li><a href="https://creativestudio.kr/1653">https://creativestudio.kr/1653</a></li>
<li><a href="http://www.tcpschool.com/css/css_basic_imageSprites">http://www.tcpschool.com/css/css_basic_imageSprites</a></li>
</ul>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>[Deep Dive] 변수</title>
    <url>/2022/Modern-JavaScript-Deep-Dive-Chapter-4-Variable-Summary/</url>
    <content><![CDATA[<p>모던 자바스크립트 Deep Dive에 대한 러버덕을 진행하면서 각 장에 대해 중요하다고 생각되는 부분들에 대해 정리해보고자 한다.</p>
<hr>

<h1 id="변수의-정의"><a href="#변수의-정의" class="headerlink" title="변수의 정의"></a>변수의 정의</h1><p>변수란 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.</p>
<hr>

<h1 id="변수는-왜-필요할까"><a href="#변수는-왜-필요할까" class="headerlink" title="변수는 왜 필요할까?"></a>변수는 왜 필요할까?</h1><p>예를들어 10 + 20이라는 식을 생각해보자. 사람이 위 식을 계산하려면 10, 20을 기억하고 + 연산을 진행해 30이라는 값을 얻어야한다.<br>컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억한다.<br>메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체이다. 메모리 셀 하나의 크기는 기기 사양마다 다르지만 보통 1바이트이다.<br>각 셀은 고유의 메모리 주소를 가진다.</p>
<p>다시 식으로 돌아가보면 숫자 값 10과 20은 메모리 상의 임의의 위치에 저장되고 CPU는 이 값을 읽어 연산한다.<br>결과인 30이라는 숫자 값 역시 메모리 상의 임의의 위치에 저장된다.</p>
<p>이때 30이라는 숫자값을 어떻게 재사용 할 수 있을까?<br>값이 저장된 메모리 주소를 통해 값에 접근할 수 있다.<br>하지만 이 경우는 실수로 운영체제가 사용하고 있는 값을 변경할수도 있고, 값이 저장될 메모리 주소 또한 임의로 결정되기에 올바른 방법이 아니다.</p>
<p>프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해 변수라는 메커니즘을 제공한다.</p>
<p>결국 값을 저장할 수 있도록 하나의 값을 저장하기 위해 확보한 메모리 공간에 상징적인 이름을 붙인 것이 변수이다.</p>
<hr>

<h1 id="변수는-어떻게-생성하는가"><a href="#변수는-어떻게-생성하는가" class="headerlink" title="변수는 어떻게 생성하는가?"></a>변수는 어떻게 생성하는가?</h1><p>변수의 생성은 선언을 통해 일어난다.</p>
<p>변수 선언은 변수를 선언하는 var, let, const의 키워드와 변수 이름을 사용한다.<br>이 때 변수 이름을 식별자라고도 하는데, 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.<br>식별자라는 용어는 변수 이름에만 국한되지 않고 변수, 함수, 클래스 등의 이름 모두를 식별자라 한다.<br>즉 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름 모두가 식별자이다.</p>
<p>자바스크립트 엔진은 변수 선언을 선언 단계와 초기화 단계로 나누어 수행한다.<br>선언 단계는 변수 이름을 등록해 자바스크립트 엔진에 변수의 존재를 알리고 메모리 공간을 확보하는 것이며, 초기화 단계에서는 확보한 메모리 공간에 최초로 값을 할당하는 것을 말한다.</p>
<p>var 키워드의 경우 선언 단계와 초기화 단계가 동시에 진행 되는데, 변수 선언 후 암묵적으로 undefined값을 넣어 초기화를 수행한다. 따라서 var 키워드로 선언한 변수는 어떠한 값을 할당하지 않아도 undefined라는 값을 갖는다.</p>
<p>왜 undefined 값을 통해 초기화를 진행하는 것일까?<br>변수가 선언되어 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아 있을 수 있다. 이러한 값을 쓰레기 값이라 하는데, 만약 초기화가 진행되지 않은 상태에서 변수를 참조한다면 쓰레기 값이 나올 위험성이 있다. 이러한 위험을 피하기 위해 자바스크립트의 var 키워드는 undefined를 통해 암묵적인 초기화를 수행한다.</p>
<h2 id="메모리-확보란-무엇인가"><a href="#메모리-확보란-무엇인가" class="headerlink" title="메모리 확보란 무엇인가?"></a>메모리 확보란 무엇인가?</h2><p>메모리 확보란 변수가 사용할 메모리 공간을 지정하고 변수 이름과 그 공간을 연결해 값을 저장할 수 있도록 준비하는 것이다. 이 때 중요한 점은 확보된 메모리 공간은 확보가 해제 되기 전까지 누구도 사용할 수 없도록 보호된다는 점이다.</p>
<h2 id="변수-이름은-어디에-등록되는가"><a href="#변수-이름은-어디에-등록되는가" class="headerlink" title="변수 이름은 어디에 등록되는가"></a>변수 이름은 어디에 등록되는가</h2><p>변수 이름 또한 어딘가에 등록이 되어 있어야 읽어서 사용 할 수 있을 것이다. 변수 이름을 비롯한 모든 식별자는 바로 실행 컨텍스트에 등록된다. 실행 컨텍스트란 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환겨을 제공하고 코드의 실행결과를 실제로 관리하는 영역이다.</p>
<hr>

<h1 id="변수-선언의-실행-시점"><a href="#변수-선언의-실행-시점" class="headerlink" title="변수 선언의 실행 시점"></a>변수 선언의 실행 시점</h1><p>변수 선언은 소스코드가 한 줄씩 순차적으로 실행되는 시점인 런타임이 아니라 그 이전에 먼저 실행된다.</p>
<p>자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서 먼저 소스코드의 평가 과정을 거치는데, 이 때 변수 선언을 포함한 모든 선언문을 소스코드에서 뽑아내 먼저 실행한다. 그리고 소스코드의 평가 과정이 끝나면 선언문을 제외한 소스코드를 한 줄씩 순차적으로 실행한다.</p>
<p>즉 자바스크립트 엔진은 변수 선언이 소스코드의 어느 위치에 있던 다른 코드보다 먼저 실행하는데, 이처럼 변수 선언문이 코드의 최상단으로 끌어 올려진 것처럼 동작하는 것을 변수 호이스팅이라 한다.</p>
<p>변수 호이스팅에 의해 다음과 같은 현상이 일어날 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(score); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> score;</span><br></pre></td></tr></table></figure>

<hr>

<h1 id="할당이-일어나는-시점"><a href="#할당이-일어나는-시점" class="headerlink" title="할당이 일어나는 시점"></a>할당이 일어나는 시점</h1><p>변수는 값을 저장해 재사용 하기 위한 메커니즘이므로 일반적으로 선언 이후 재사용 할 값을 할당하게 된다.</p>
<p>이 때 변수의 선언과 값의 할당은 실행 시점이 다른데, 변수 선언은 런타임 이전에 실행되는 반면 값의 할당은 런타임에 실행된다.</p>
<p>일반적으로 변수를 다음과 같이 2개의 문으로 사용하지만 하나의 문으로 단축 표현 할 수도 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> score;</span><br><span class="line">score = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> score = <span class="number">80</span>; <span class="comment">// 단축 표현</span></span><br></pre></td></tr></table></figure>

<p>변수 선언과 값의 할당을 2개의 문으로 나눈 코드와 하나의 문으로 단축 표현한 코드는 정확히 동일하게 동작한다.</p>
<hr>

<h1 id="재할당"><a href="#재할당" class="headerlink" title="재할당"></a>재할당</h1><p>var 키워드로 선언한 변수는 값을 재할당할 수 있다. 재할당은 현재 변수에 저장된 값을 버리고 새로운 값을 저장하는 것이다. var 키워드는 선언시 undefined로 초기화되기 때문에 변수에 처음으로 값을 할당하는 것도 사실 재할당이다.</p>
<p>만약 재할당이 불가능해 변수에 저장된 값을 변경할 수 없다면 이를 상수라고 한다. 즉 상수는 단 한번만 할당이 가능한 변수이다.</p>
<p>만약 변수에 값을 재할당 하면 변수의 값을 이전 값에서 재할당한 값으로 변하게 된다. 이때 메모리에서는 어떤 일이 일어날까? 재할당시에는 메모리 공간에서 이전 값을 지우고 새로운 값을 할당하는것이 아닌 변수가 새로운 메모리 공간을 확보하고 그 공간에 새로운 값을 저장하게 된다.</p>
<p>이 때 이전 값이 들어 있던 메모리 공간은 어떤 식별자와도 연결되어 있지 않으므로 불필요한 값이 된다.<br>이 경우 가비지 콜렉터에 의해서 메모리에서 자동 해제되지만 언저 해제될지 예측은 불가능하다.</p>
]]></content>
      <tags>
        <tag>자바스크립트</tag>
        <tag>모던 자바스크립트 Deep Dive</tag>
      </tags>
  </entry>
  <entry>
    <title>[Javascript] 문자열 자르기 메서드 정리</title>
    <url>/2023/Javascript-String-Cutting-Method/</url>
    <content><![CDATA[<h1 id="😂-들어가며"><a href="#😂-들어가며" class="headerlink" title="😂 들어가며"></a>😂 들어가며</h1><p>코딩테스트 대비를 위해 프로그래머스의 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/76502">Lv.2 괄호 회전하기</a>를 푸는 중이었다. 전형적인 스택 자료구조를 이용하는 문제라 비슷한 유형의 문제를 풀어본 경험이 있어서 수월하게 코드를 작성하고 채점을 하는데 <code>TypeError: doubledS.splice is not a function</code>의 오류가 발생했다. string에는 splice 메서드가 없는데 배열과 착각했던 것이다.</p>
<p>그래서 splice를 slice로 바꾸어 주었는데, 이번에는 테스트를 통과하지 못한 문항이 존재했다. 아무리 생각해도 알고리즘 상 틀린 부분이 없는데 왜 그러는거지 생각하다가 자른 문자열을 <code>console.log</code>를 이용해 확인해 보았더니 내가 원하던 형태로 잘리지가 않아 있었다. 내가 원했던 형태는 문자열을 index로 부터 length만큼 자르는거였는데, <code>String.slice()</code>의 2번째 인자는 length가 아니라 indexEnd였기 때문이다.</p>
<p>결국 <code>Array.splice()</code>와 비슷한 기능을 하는 String의 메서드가 뭐였는지 기억이 나지 않아 검색을 통해 내가 원했던 메서드는 <code>String.substr()</code> 임을 알고 수정해 문제를 해결했다.</p>
<p>평소 배열 자료구조만을 거의 활용하다 보니 문자열의 메서드들에 대해서 잊어버린 것 같다. 문자열을 다루는 문제들도 자주 나오는데 또 잊어버리면 안되니 이번 기회에 정리해보자고 결심했다.</p>
<details>
<summary>나의 괄호 회전하기 풀이</summary>
<div markdown="1">

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">solution</span>(<span class="params">s</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> pair = &#123;</span><br><span class="line">		<span class="string">&#x27;(&#x27;</span>: <span class="string">&#x27;)&#x27;</span>,</span><br><span class="line">		<span class="string">&#x27;[&#x27;</span>: <span class="string">&#x27;]&#x27;</span>,</span><br><span class="line">		<span class="string">&#x27;&#123;&#x27;</span>: <span class="string">&#x27;&#125;&#x27;</span>,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="title function_">getIsCorrectArray</span> = (<span class="params">string</span>) =&gt; &#123;</span><br><span class="line">		<span class="keyword">const</span> stack = [];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; string.<span class="property">length</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (stack.<span class="property">length</span> === <span class="number">0</span>) stack.<span class="title function_">push</span>(string[i]);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (string[i] === pair[stack[stack.<span class="property">length</span> - <span class="number">1</span>]]) stack.<span class="title function_">pop</span>();</span><br><span class="line">			<span class="keyword">else</span> stack.<span class="title function_">push</span>(string[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> stack.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> doubledS = s + s;</span><br><span class="line">	<span class="keyword">let</span> correctString = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="title function_">getIsCorrectArray</span>(doubledS.<span class="title function_">splice</span>(i, s.<span class="property">length</span>))) correctString++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> correctString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>
</details>

<h1 id="문자열-자르기"><a href="#문자열-자르기" class="headerlink" title="문자열 자르기"></a>문자열 자르기</h1><p>자바스크립트에서 문자열을 자르기 위해서는 substr(), substring(), slice() 메서드를 사용하면 된다. 세 가지의 함수 중 상황에 맞는 적절한 함수를 사용하면 되는데 각 메서드에 대해 알아보자.</p>
<h2 id="substr-특정-index에서-원하는-길이만큼-잘라서-문자열로-리턴"><a href="#substr-특정-index에서-원하는-길이만큼-잘라서-문자열로-리턴" class="headerlink" title="substr(): 특정 index에서 원하는 길이만큼 잘라서 문자열로 리턴"></a>substr(): 특정 index에서 원하는 길이만큼 잘라서 문자열로 리턴</h2><h3 id="문법"><a href="#문법" class="headerlink" title="문법"></a>문법</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str.<span class="title function_">substr</span>(start[, length])</span><br></pre></td></tr></table></figure>

<h3 id="매개변수"><a href="#매개변수" class="headerlink" title="매개변수"></a>매개변수</h3><ul>
<li><p><code>start</code></p>
<ul>
<li>추출하고자 하는 문자들의 시작위치입니다. 만약 음수가 주어진다면, 문자열총길이 + start의 값으로 취급합니다. 예를 들면, start에 -3을 설정하면, 자동적으로 문자열총길이 - 3으로 설정하게 됩니다.</li>
</ul>
</li>
<li><p><code>length</code></p>
<ul>
<li>옵션값. 추출할 문자들의 총 숫자.</li>
</ul>
</li>
</ul>
<h2 id="substring-시작-index에서-끝-index전까지-문자열-잘라서-리턴"><a href="#substring-시작-index에서-끝-index전까지-문자열-잘라서-리턴" class="headerlink" title="substring(): 시작 index에서 끝 index전까지 문자열 잘라서 리턴"></a>substring(): 시작 index에서 끝 index전까지 문자열 잘라서 리턴</h2><h3 id="문법-1"><a href="#문법-1" class="headerlink" title="문법"></a>문법</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str.<span class="title function_">substring</span>(indexStart[, indexEnd])</span><br></pre></td></tr></table></figure>

<h3 id="매개변수-1"><a href="#매개변수-1" class="headerlink" title="매개변수"></a>매개변수</h3><ul>
<li><p><code>indexStart</code></p>
<ul>
<li>반환문자열의 시작 인덱스</li>
</ul>
</li>
<li><p><code>indexEnd</code></p>
<ul>
<li>옵션. 반환문자열의 마지막 인덱스 (포함하지 않음.)</li>
</ul>
</li>
</ul>
<h3 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h3><ul>
<li>만약 indexEnd 가 생략된 경우, substring() 문자열의 끝까지 모든 문자를 추출</li>
<li>만약 indexStart 가 indexEnd와 같을 경우, substring() 빈 문자열을 반환</li>
<li><strong>만약 indexStart 가 indexEnd보다 큰 경우, substring() 메서드는 마치 두 개의 인자를 바꾼 듯 작동</strong></li>
</ul>
<h2 id="slice-substring과-비슷하지만-살짝-다른-메서드"><a href="#slice-substring과-비슷하지만-살짝-다른-메서드" class="headerlink" title="slice(): substring과 비슷하지만 살짝 다른 메서드"></a>slice(): substring과 비슷하지만 살짝 다른 메서드</h2><h3 id="문법-2"><a href="#문법-2" class="headerlink" title="문법"></a>문법</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str.<span class="title function_">slice</span>(beginIndex[, endIndex])</span><br></pre></td></tr></table></figure>

<h3 id="매개변수-2"><a href="#매개변수-2" class="headerlink" title="매개변수"></a>매개변수</h3><ul>
<li><p><code>beginIndex</code></p>
<ul>
<li>반환문자열의 시작 인덱스</li>
</ul>
</li>
<li><p><code>endIndex</code></p>
<ul>
<li>옵션. 반환문자열의 마지막 인덱스 (포함하지 않음.)</li>
</ul>
</li>
</ul>
<h3 id="특징-1"><a href="#특징-1" class="headerlink" title="특징"></a>특징</h3><ul>
<li>인자로 음수가 전달되었을 때, <code>substring()은 빈 문자열을 리턴</code>하지만 <code>slice()는 음수 Index를 적용하여 문자열을 잘라줌</code>.</li>
</ul>
<h2 id="😅-없어질-메서드"><a href="#😅-없어질-메서드" class="headerlink" title="😅 없어질 메서드??"></a>😅 없어질 메서드??</h2><p>substr() 메서드에 대해 정확히 알아보기 위해 MDN에 검색을 하는 중에 다음과 같은 경고가 달려있었다.</p>
<blockquote>
<p>경고: 엄밀히 말해서 String.prototype.substr() 메서드가 더 이상 사용되지 않는, 즉 “웹 표준에서 제거된” 건 아닙니다. 그러나 substr()이 포함된 ECMA-262 표준의 부록 B는 다음과 같이 명시하고 있습니다.&gt; … 본 부록이 포함한 모든 언어 기능과 행동은 하나 이상의 바람직하지 않은 특징을 갖고 있으며 사용처가 없어질 경우 명세에서 제거될 것입니다. …</p>
</blockquote>
<p><code>아니 그러면 length로 자르기 위해서는 어떻게 하라는거지?</code> 생각했는데 <code>str.slice()</code>나 <code>str.substr()</code>의 메서드의 인자를 잘 이해하고 맞추어서 사용해야 하는 것 같다. 그래도 기본적으로 원하는 length만큼 자르기 위해선 str.slice(beginIndex, beginIndex + length)로 하면 될 것 같다.(<del>사실 이번 문제도 이렇게 하면 됐을텐데 시야가 너무 좁았던것 같다. 더 많은 문제를 풀어보면 괜찮아지려나..?</del>)</p>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substr">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substr</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substring">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substring</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice</a></li>
</ul>
]]></content>
      <tags>
        <tag>자바스크립트</tag>
      </tags>
  </entry>
  <entry>
    <title>[Deep Dive] 제어문</title>
    <url>/2022/Modern-JavaScript-Deep-Dive-Chapter-8-Control-Flow-Statement/</url>
    <content><![CDATA[<h1 id="제어문"><a href="#제어문" class="headerlink" title="제어문"></a>제어문</h1><p>제어문은 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용한다.<br>일반적으로 코드는 위에서 아래 방향으로 순차적으로 실행된다.<br>제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어할 수 있다.</p>
<p>하지만 코드의 실행 순서가 변경되는 것은 코드의 흐름을 혼란스럽게 만들어 가독성을 해치는 단점이 있다.<br>가독성이 좋지 않은 코드는 오류를 발생시키는 원인이 되므로 forEach, map, filter, reduce 같은 고차 함수를 사용한 함수형 프로그래밍 기법에서는 제어문의 사용을 억제하여 복잡성을 해결하려고 노력한다.</p>
<p>하지만 제어문을 바르게 이해하는 것은 코딩 스킬에 많은 영향을 준다.<br>특히 for 문은 매우 중요하므로 확실히 살펴보도록 하자.</p>
<h2 id="블록문"><a href="#블록문" class="headerlink" title="블록문"></a>블록문</h2><p>블록문은 0개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라고 부르기도 한다.<br>자바스크립트는 블록문을 하나의 실행 단위로 취급한다.<br>블록문은 단독으로 사용 가능하나 일반적으로 제어문이나 함수를 정의할 때 사용한다.</p>
<p>문의 끝에는 세미콜론을 붙이는 것이 일반적이나 블록문은 자체 종결성을 갖기 때문에 블록문의 끝에는 세미콜론을 붙이지 않는다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 블록문</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">var</span> foo = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 제어문</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">10</span>) &#123;</span><br><span class="line">	x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 선언문</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="조건문"><a href="#조건문" class="headerlink" title="조건문"></a>조건문</h2><p>조건문은 주어진 조건식의 평가 결과에 따라 코드 블록의 실행을 결정한다.<br>조건식은 불리언 값으로 평가될 수 있는 표현식이다.</p>
<p>자바스크립트는 if…else 문과 switch 문의 두 가지 조건문을 제공한다.</p>
<h3 id="if…else-문"><a href="#if…else-문" class="headerlink" title="if…else 문"></a>if…else 문</h3><p>if…else 문은 주어진 조건식의 평가 결과에 따라 실행할 코드 블록을 결정한다.<br>조건식의 평가 결과가 true일 경우 if 문의 코드 블록이 실행되고 false일 경우 else 문의 코드 블록이 실행된다.</p>
<pre>
if (조건식) {
  // 조건식이 참이면 이 코드 블록이 실행
} else {
  // 조건식이 거짓이면 이 코드 블록이 실행
}
</pre>

<p>if 문의 조건식은 불리언 값으로 평가되어야 한다. 만약 if 문의 조건식이 불리언 값이 아닌 값으로 평가되면 자바스크립트 엔진에 의해 암묵적으로 불리언 값으로 강제 변환되어 실행할 코드 블록을 결정한다.</p>
<p>만약 코드 블록 내의 문이 하나라면 중괄호를 생략할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> kind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">0</span>) kind = <span class="string">&#x27;양수&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">0</span>) kind = <span class="string">&#x27;음수&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> kind = <span class="string">&#x27;영&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(kind); <span class="comment">// 양수</span></span><br></pre></td></tr></table></figure>

<p>대부분의 if…else 문은 삼항 조건 연산자로 바꿔 쓸 수 있다.<br>연산자에서도 살펴보았듯이 조건에 따라 단순히 값을 결정하여 변수에 할당하는 경우 if…else 문보다 삼항 조건 연산자를 사용하는 편이 가독성이 좋다.<br>하지만 조건에 따라 실행해야 할 내용이 복잡하여 여러 줄의 문이 필요하다면 if…else 문을 사용하는 편이 가독성이 좋다.</p>
<h3 id="switch-문"><a href="#switch-문" class="headerlink" title="switch 문"></a>switch 문</h3><p>switch 문은 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 흐름을 옮긴다.<br>case 문은 상황을 의미하는 표현식을 지정하고 콜론으로 마친다. 그리고 그 뒤에 실행할 문들을 위치시킨다.</p>
<p>switch 문의 표현식과 일치하는 case 문이 없다면 실행 순서는 default 문으로 이동한다. default 문은 선택사항이다.</p>
<pre>
switch (표현식) {
 case 표현식1:
  switch 문의 표현식과 표현식 1이 일치하면 실행될 문;
  break;
 case 표현식2:
  switch 문의 표현식과 표현식 2가 일치하면 실행될 문;
  break;
 default:
  switch 문의 표현식과 일치하는 case 문이 없을 때 실행될 문;
}
</pre>

<p>if…else 문의 조건식은 불리언 값으로 평가되어야 하지만 switch 문의 표현식은 불리언 값보다는 문자열이나 숫자 값인 경우가 많다.<br>즉 switch 문은 논리적 참, 거짓보다는 다양한 상황(case)에 따라 실행할 코드 블록을 결정할 때 사용한다.</p>
<p>swtich 문은 case, default, break 등 다양한 키워드를 사용해야 하고 폴스루가 발생한느 등 문법도 복잡하다.<br>따라서 C 언어를 기반으로 하는 프로그래밍 언어는 대부분 switch 문을 지원하지만 파이썬과 같이 switch 문ㅇ을 지원하지 않는 프로그래밍 언어도 있다.</p>
<p>만약 if…else 문으로 해결할 수 있다면 switch 문보다 if…else 문을 사용하는 편이 좋다.<br>하지만 조건이 너무 많아 if…else 문보다 switch 문을 사용했을 때 가독성이 더 좋다면 switch문을 사용하는 편이 좋다.</p>
<h2 id="반복문"><a href="#반복문" class="headerlink" title="반복문"></a>반복문</h2><p>반복문은 조건식의 평가 결과가 참인 경우 코드 블록을 실행한다. 그 후 조건식을 다시 평가하여 여전히 참인 경우 코드 블록을 다시 실행한다.<br>이는 조건식이 거짓일 때까지 반복된다.</p>
<p>자바스크립트는 for 문, while 문, do…while 문의 세 가지 반복문을 제공한다</p>
<h3 id="for-문"><a href="#for-문" class="headerlink" title="for 문"></a>for 문</h3><p>for 문은 조건식이 거짓으로 평가될 때까지 코드 블록을 반복 실행한다. 가장 일반적으로 사용되는 for 문의 형태는 다음과 같다.</p>
<pre>
for (변수 선언문 또는 할당문; 조건식; 증감식) {
 조건식이 참인 경우 반복 실행될 문;
}
</pre>

<p>for 문은 매우 중요하므로 어떻게 동작하는지 많은 연습을 통해 확실히 이해해야 한다.</p>
<p>for 문의 변수 선언문, 조건식, 증감식은 모두 옵션이므로 반드시 사용할 필요는 없다. 단, 어떤 식도 선언하지 않으면 무한루프가 된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;...&#125; <span class="comment">// 무한루프</span></span><br></pre></td></tr></table></figure>

<p>for 문 내에 for 문을 중첩해 사용할 수 있다. 이를 중첩 for 문이라 한다. 다음은 두 개의 주사위를 던졌을 때 두 눈의 합이 6이 되는 모든 경우의 수를 출력하기 위해 이중 중첩 for 문을 사용한 예다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= <span class="number">6</span>; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i + j === <span class="number">6</span>) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[<span class="subst">$&#123;i&#125;</span>, <span class="subst">$&#123;j&#125;</span>]`</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [1, 5] [2, 4] [3, 3] [4, 2] [5, 1]</span></span><br></pre></td></tr></table></figure>

<h3 id="while-문"><a href="#while-문" class="headerlink" title="while 문"></a>while 문</h3><p>while 문은 주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복 실행한다.<br>for 문은 반복 횟수가 명확할 때 주로 사용하고 while 문은 반복 횟수가 불명확할 때 주로 사용한다.</p>
<p>while 문은 조건문의 평가 결과가 거짓이 되면 코드 블록을 실행하지 않고 종료한다. 만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 강제 변환하여 논리적 참, 거짓을 구별한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">3</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(count); <span class="comment">// 0 1 2</span></span><br><span class="line">	count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>조건식의 평가 결과가 언제나 참이면 무한루프가 된다.<br>무한루프에서 탈출하기 위해서는 코드 블록 내에 if 문으로 탈출 조건을 만들고 break 문으로 코드 블록을 탈출한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 무한루프</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(count); <span class="comment">// 0 1 2</span></span><br><span class="line">	count++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (count === <span class="number">3</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="do…while-문"><a href="#do…while-문" class="headerlink" title="do…while 문"></a>do…while 문</h3><p>do…while 문은 코드 블록을 먼저 실행하고 조건식을 평가한다. 따라서 코드 블록은 무조건 한 번 이상 실행된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(count); <span class="comment">// 0 1 2</span></span><br><span class="line">	count++;</span><br><span class="line">&#125; <span class="keyword">while</span> (count &lt; <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h2 id="break-문"><a href="#break-문" class="headerlink" title="break 문"></a>break 문</h2><p>switch 문과 while 문에서 살펴보았듯이 break 문은 코드 블록을 탈출한다.<br>더 정확히 말하자면 레이블 문, 반복문 또는 switch 문의 코드 블록을 탈출한다. 레이블 문, 반복문, switch 문의 코드 블록 외에 break 문을 사용하면 SyntaxError가 발생한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">break</span>; <span class="comment">// Uncaught SyntaxError: Illegal break statement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>참고로 레이블 문은 식별자가 붙은 문을 말한다.<br>레이블 문은 프로그램의 실행 순서를 제어하는데 사용한다. 사실 switch 문의 case 문과 default 문 역시 레이블 문이다.<br>레이블 문을 탈출하려면 break 문에 레이블 식별자를 지정한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">foo</span>: &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">break</span> foo;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Done!&#x27;</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// Done!</span></span><br></pre></td></tr></table></figure>

<p>레이블 문을 사용하면 프로그램의 흐름이 복잡해져서 가독성이 나빠지고 오류를 발생시킬 가능성이 높아지기 때문에 일반적으로 권장하지 않는다.</p>
</blockquote>
<h2 id="continue-문"><a href="#continue-문" class="headerlink" title="continue 문"></a>continue 문</h2><p>continue 문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다.<br>break 문처럼 반복문을 탈출하지는 않는다.</p>
<p>다음은 문자열에서 특정 문자의 개수를 세는 예다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;Hello World.&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> search = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; string.<span class="property">length</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span> (string[i] !== search) <span class="keyword">continue</span>; <span class="comment">// &#x27;l&#x27;이 아니면 현 지점에서 실행을 중단하고 반복문의 증감식으로 이동한다.</span></span><br><span class="line">	count++; <span class="comment">// continue 문이 실행되면 이 문은 실행되지 않는다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>자바스크립트</tag>
        <tag>모던 자바스크립트 Deep Dive</tag>
      </tags>
  </entry>
  <entry>
    <title>[Deep Dive] 객체 리터럴</title>
    <url>/2022/Modern-Javascript-Deep-Dive-Chapter-10-Summary/</url>
    <content><![CDATA[<h1 id="객체란"><a href="#객체란" class="headerlink" title="객체란?"></a>객체란?</h1><p>자바스크립트는 객체 기반의 프로그래밍 언어이며, 자바스크립트를 구성하는 거의 모든것이 객체이다.<br>원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등)은 모두 객체다.</p>
<p>원시 타입은 단 하나의 값만 나타내지만 객체타입은 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조다.<br>원시 타입의 값은 변경 불가능한 값이지만 객체 타입의 값은 변경 가능한 값이다.</p>
<p>객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키와 값으로 구성된다.</p>
<p>자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있다. 자바스크립트의 함수는 일급 객체로 값으로 취급할 수 있다.<br>따라서 함수도 프로퍼티 값으로 사용 가능한데, 프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라 한다.</p>
<p>이처럼 객체는 프로퍼티와 메서드로 구성된 집합체이며 프로퍼티와 메서드의 역할은 다음과 같다.</p>
<ul>
<li>프로퍼티: 객체의 상태를 나타내는 값(data)</li>
<li>메서드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)</li>
</ul>
<p>객체는 프로퍼티와 메서드를 통해 상태와 동작을 하나의 단위로 구조화할 수 있어 유용하다.</p>
<h2 id="객체-리터럴에-의한-객체-생성"><a href="#객체-리터럴에-의한-객체-생성" class="headerlink" title="객체 리터럴에 의한 객체 생성"></a>객체 리터럴에 의한 객체 생성</h2><p>C++이나 자바와 같은 클래스 기반 객체지향 언어는 클래스를 사전에 정의하고 필요한 시점에 new 연산자와 함께 생성자를 호출하여 인스턴스를 생성하는 방식으로 객체를 생성한다.</p>
<p>자바스크립트는 프로토타입 기반 객체지향 언어로 클래스 기반 객체지향 언어와는 달리 다양한 객체 생성 방법을 지원한다.</p>
<ul>
<li>객체 리터럴</li>
<li>Object 생성자 함수</li>
<li>생성자 함수</li>
<li>Object.create 메서드</li>
<li>클래스(ES6)</li>
</ul>
<p>객체 생성 방법 중에서 가장 일반적이고 간단한 방법은 객체 리터럴을 사용하는 방법이다.<br>객체 리터럴은 중괄호({…}) 내에 0개 이상의 프로퍼티를 정의한다. 자바스크립트 엔진은 변수에 할당되는 시점에 객체 리터럴을 해석해 객체를 생성한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;rongrong&#x27;</span>,</span><br><span class="line">	<span class="attr">sayHello</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello! my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>.`</span>);</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> person); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123;name: &#x27;rongrong&#x27;, sayHello: f&#125;</span></span><br></pre></td></tr></table></figure>

<p>객체 리터럴의 중괄호는 코드 블록을 의미하지 않는다는것에 주의하자. 코드 블록의 닫는 중괄호 뒤에는 세미콜론을 붙이지 않는다.<br>하지만 객체 리터럴은 값으로 평가되는 표현식으로 객체 리터럴의 닫는 괄호 뒤에는 세미콜론을 붙인다.</p>
<p>객체 리터럴은 자바스크립트의 유연함과 강력함을 대표하는 객체 생성 방식으로 객체 리터럴에 프로퍼티를 포함시켜 객체를 생성함과 동시에 프로퍼티를 만들 수도 있고, 객체를 생성한 이후에 프로퍼티를 동적으로 추가할 수도 있다.</p>
<p>그렇다면 프로퍼티에 대해 자세히 알아보자.</p>
<h2 id="프로퍼티"><a href="#프로퍼티" class="headerlink" title="프로퍼티"></a>프로퍼티</h2><p>객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.<br>프로퍼티를 나열할 때는 쉼표로 구분한다. 일반적으로 마지막 프로퍼티 뒤에는 쉼표를 사용하지 않지만 사용해도 괜찮다.</p>
<p>프로퍼티 키와 프로퍼티 값으로 사용할 수 있는 값은 다음과 같다.</p>
<ul>
<li>프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 또는 심벌 값</li>
<li>프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값</li>
</ul>
<p>프로퍼티 키는 프로퍼티 값에 접근할 수 있는 이름으로 식별자의 역할을 한다. 하지만 반드시 식별자 네이밍규칙을 따라야 하는 것은 아니다.<br>단, 식별자 네이밍 규칙을 준수하는 프로퍼티 키와 그렇지 않은 키에는 차이가 존재한다.</p>
<p>심벌 값도 프로퍼티 키로 사용할 수 있지만 일반적으로 문자열을 사용한다. 이때 프로퍼티 키는 문자열이므로 따옴표로 묶어야 한다.<br>하지만 식별자 네이밍 규칙을 준수하는 이름은 따옴표를 생략할 수 있다. 반대로 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	<span class="attr">firstName</span>: <span class="string">&#x27;rong&#x27;</span>, <span class="comment">// 식별자 네이밍 규칙을 준수한 프로퍼티 키</span></span><br><span class="line">	<span class="string">&#x27;last-name&#x27;</span>: <span class="string">&#x27;rong&#x27;</span>, <span class="comment">// 식별자 네이밍 규칙을 준수하지 않은 프로퍼티 키</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123;firstName: &#x27;rong&#x27;, last-name: &#x27;rong&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>프로퍼티 키로 사용한 firstName은 식별자 네이밍 규칙을 준수하므로 따옴표를 생략할 수 있다.<br>하지만 last-name은 식별자 네이밍 규칙을 주수하지 않으므로 따옴표를 생략할 수 없다. 자바스크립트 엔진은 따옴표를 생략한 last-name을 - 연산자가 있는 표현식으로 해석한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;rong&#x27;</span>,</span><br><span class="line">  last-<span class="attr">name</span>: <span class="string">&#x27;rong&#x27;</span>, <span class="comment">// SyntaxError: Unexpected token -</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>문자열 또는 문자열로 평가할 수 있는 표현식을 사용해 프로퍼티 키를 동적으로 생성 가능하다. 이 경우에는 프로퍼티 키로 사용할 표현식을 대괄호로 묶어야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> key = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line">obj[key] = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123;hello: &#x27;world&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>이미 존재하는 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다.<br>이때 에러가 발생하지 않으니 주의해야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;Kim&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// &#123;name: &#x27;Kim&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="메서드"><a href="#메서드" class="headerlink" title="메서드"></a>메서드</h2><p>자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값으로 사용할 수 있다고 했다.<br>자바스크립트의 함수는 일급객체로 값으로 취급할 수 있기 때문에 프로퍼티 값으로 사용 가능하다.</p>
<p>프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라 부르는데 즉 메서드는 객체에 묶여 있는 함수를 의미한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> circle = &#123;</span><br><span class="line">	<span class="attr">radius</span>: <span class="number">5</span>, <span class="comment">// 프로퍼티</span></span><br><span class="line">	<span class="comment">// 원의 지름을 구하는 메서드</span></span><br><span class="line">	<span class="attr">getDiameter</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span> * <span class="variable language_">this</span>.<span class="property">radius</span>;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(circle.<span class="title function_">getDiameter</span>()); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h2 id="프로퍼티-접근"><a href="#프로퍼티-접근" class="headerlink" title="프로퍼티 접근"></a>프로퍼티 접근</h2><p>프로퍼티에 접근하는 방법은 다음과 같이 두 가지이다.</p>
<ul>
<li>마침표 프로퍼티 접근 연산자(.)를 사용하는 마침표 표기법</li>
<li>대괄호 프로퍼티 접근 연산자([…])를 사용하는 대괄호 표기법</li>
</ul>
<p>프로퍼티 키가 식별자 네이밍 규칙을 준수하는 이름이면 마침표 표기법과 대괄호 표기법을 모두 사용할 수 있다.</p>
<p>대괄호 표기법을 사용하는 경우 대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다.<br>대괄호 프로퍼티 접근 연산자 내에 따옴표로 감싸지 않은 이름을 프로퍼티 키로 사용하면 자바스크립트 엔진은 식별자로 해석한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;rongrong&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// &#x27;rongrong&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person[<span class="string">&#x27;name&#x27;</span>]); <span class="comment">// &#x27;rongrong&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person[name]); <span class="comment">// ReferenceError: name is not defined</span></span><br></pre></td></tr></table></figure>

<p>위 코드에서 ReferenceError가 발생한 이유는 대괄호 연산자 내의 따옴표로 감싸지 않은 이름, 즉 식별자 name을 평가하기 위해 선언된 name을 찾았지만 찾지 못했기 때문이다.</p>
<p>객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환한다. 이때 ReferenceError가 발생하지 않는데에 주의하자</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;rongrong&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">age</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않으면 반드시 대괄호 표기법을 사용해야 한다.<br>단 프로퍼티 키가 숫자로 이루어진 문자열인 경우 따옴표를 생략할 수 있다.</p>
<h2 id="프로퍼티-값-갱신"><a href="#프로퍼티-값-갱신" class="headerlink" title="프로퍼티 값 갱신"></a>프로퍼티 값 갱신</h2><p>이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신된다</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;Kim&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123;name: &quot;Kim&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="프로퍼티-동적-생성"><a href="#프로퍼티-동적-생성" class="headerlink" title="프로퍼티 동적 생성"></a>프로퍼티 동적 생성</h2><p>존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;rongrong&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="property">age</span> = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123;name: &#x27;rongrong&#x27;, age: 25&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="프로퍼티-삭제"><a href="#프로퍼티-삭제" class="headerlink" title="프로퍼티 삭제"></a>프로퍼티 삭제</h2><p>delete 연산자는 객체의 프로퍼티를 삭제한다. 이때 delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이어야 한다.<br>이때 존재하지 않는 프로퍼티를 삭제해도 아무런 에러 없이 무시된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;rongrong&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="property">age</span> = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person.<span class="property">age</span>; <span class="comment">// 프로퍼티 동적 생성 후 삭제</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person.<span class="property">address</span>; <span class="comment">// 존재하지 않는 프로퍼티 삭제, 에러 없이 무시</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123;name: &#x27;rongrong&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="ES6에서-추가된-객체-리터럴의-확장-기능"><a href="#ES6에서-추가된-객체-리터럴의-확장-기능" class="headerlink" title="ES6에서 추가된 객체 리터럴의 확장 기능"></a>ES6에서 추가된 객체 리터럴의 확장 기능</h2><p>ES6에서는 더욱 간편하고 표현력 있는 객체 리터럴의 확장 기능을 제공한다.</p>
<h3 id="프로퍼티-축약-표현"><a href="#프로퍼티-축약-표현" class="headerlink" title="프로퍼티 축약 표현"></a>프로퍼티 축약 표현</h3><p>객체 리터럴의 프로퍼티는 프로퍼티 키와 프로퍼티 값으로 구성된다. 프로퍼티 값은 변수에 할당된 값, 즉 식별자 표현식일 수도 있다.</p>
<p>ES6에서는 프로퍼티 값으로 변수를 사용하는 경우 변수 이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티 키를 생략할 수 있다.<br>이때 프로퍼티 키는 변수 이름으로 자동 생성된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>,</span><br><span class="line">  y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; x, y &#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="메서드-축약-표현"><a href="#메서드-축약-표현" class="headerlink" title="메서드 축약 표현"></a>메서드 축약 표현</h3><p>ES5에서 메서드를 정의하려면 프로퍼티 값으로 함수를 할당한다.</p>
<p>ES6에서는 메서드를 정의할 때 function 키워드를 생략한 축약 표현을 사용할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;rongrong&#x27;</span>,</span><br><span class="line">	<span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi! &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">sayHi</span>(); <span class="comment">// &#x27;Hi! rongrong&#x27;</span></span><br></pre></td></tr></table></figure>

<p>ES6의 메서드 축약 표현으로 정의한 메서드는 프로퍼티에 할당한 함수와 다르게 동작한다.</p>
]]></content>
      <tags>
        <tag>자바스크립트</tag>
        <tag>모던 자바스크립트 Deep Dive</tag>
      </tags>
  </entry>
  <entry>
    <title>[Deep Dive] 원시 값과 객체의 비교</title>
    <url>/2022/Modern-Javascript-Deep-Dive-Chapter-11-Summary/</url>
    <content><![CDATA[<h1 id="원시-값-vs-객체-값"><a href="#원시-값-vs-객체-값" class="headerlink" title="원시 값 vs 객체 값"></a>원시 값 vs 객체 값</h1><p>앞서 데이터 타입에서 살펴보았듯이 자바스크립트가 제공하는 데이터타입은 크게 원시 타입과 객체 타입으로 구분할 수 있다.</p>
<p>데이터 타입을 원시 타입과 객체 타입으로 구분하는 이유는 무엇일까?<br>원시 타입과 객체 타입은 근본적으로 다르다는 의미일 것이다. 원시타입과 객체 타입은 크게 세 가지 측면에서 다르다.</p>
<ul>
<li>원시 타입의 값은 변경 불가능한 값이다. 반면 객체(참조) 타입의 값은 변경 가능한 값이다.</li>
<li>원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다. 반면 객체를 변수에 할당하면 변수에는 참조 값이 저장된다.</li>
<li>원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달이라고 한다. 반면 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달이라고 한다.</li>
</ul>
<p>원시 타입과 객체 타입에 대해 조금 더 자세히 살펴보자</p>
<h2 id="원시-값"><a href="#원시-값" class="headerlink" title="원시 값"></a>원시 값</h2><h3 id="변경-불가능한-값"><a href="#변경-불가능한-값" class="headerlink" title="변경 불가능한 값"></a>변경 불가능한 값</h3><p>원시 타입의 값은 변경 불가능한 값이다. 다시 말해, 한번 생성된 원시 값은 읽기 전용 값으로 변경할 수 없다.</p>
<p>값을 변경할 수 없다는 것이 어떤 의미일까? 먼저 변수와 값을 정확히 구분해야 한다.<br>변수란 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이고, 값이란 변수에 저장된 데이터로 표현식이 평가되어 생성된 결과이다. 값을 변경할 수 없다는 것은 변수에 관한 것이 아닌 값에 대한 진술이다.</p>
<p>즉 원시 값을 변경할 수 없다는 것은 원시 값 자체를 변경할 수 없다는 것이지 변수 값을 변경할 수 없다는 것이 아니다. 변수 값은 재할당을 통해 언제든지 변경 가능하다. 단 상수는 재할당이 금지된 변수이므로 변수 값을 변경할 수 없다.</p>
<p>원시 값은 변경 불가능한 값이므로 데이터의 신뢰성을 보장한다.</p>
<p>변수에서 살펴보았듯이 원시 값을 할당한 변수에 새로운 원시 값을 재할당하면 메모리 공간에 저장되어 있는 재할당 이전의 원시 값을 변경하는 것이 아니라 새로운 메모리 공간을 확보하고 재할당할 값을 저장한 후 변수가 새롭게 재할당한 원시 값을 가리킨다.</p>
<p>변수가 참조하던 메모리 공간의 주소가 변경된 이유는 변수에 할당된 원시 값이 변경 불가능한 값이기 때문이다.<br>만약 원시 값이 변경 가능한 값이라면 변수에 새로운 원시 값을 재할당했을 때 변수가 가리키던 메모리 공간의 주소를 바꿀 필요 없이 원시 값 자체를 변경하면 될 것이다.</p>
<p>하지만 원시 값은 불변성을 가지므로 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.</p>
<h3 id="값에-의한-전달"><a href="#값에-의한-전달" class="headerlink" title="값에 의한 전달"></a>값에 의한 전달</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> score = <span class="number">80</span>;</span><br><span class="line"><span class="keyword">var</span> copy = score;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(score); <span class="comment">// 80</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy); <span class="comment">// 80</span></span><br><span class="line"></span><br><span class="line">score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(score); <span class="comment">// 100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>score 변수에 숫자 값 80을 할당 한 후 copy 변수에 score 변수를 할당했다. 그 후, score 변수에 새로운 숫자 값 100을 재할당하면 copy 변수의 값은 어떻게 될까?</p>
<p>이 질문은 결국 “변수에 변수를 할당했을 때 무엇이 어떻게 전달되는가?”이다. copy &#x3D; score에서 score는 변수 값 80으로 평가되므로 copy 변수에도 80이 할당된다. 이처럼 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시 값이 복사되어 전달되는데 이를 값에 의한 전달이라 한다.</p>
<p>score 변수와 copy 변수는 숫자 값 80을 갖는다는 점은 동일하지만 score 변수와 copy 변수의 값 80은 다른 메모리 공간에 저장된 별개의 값이다.<br>따라서 score변수의 값을 변경하더라도 copy 변수의 값은 어떠한 영향을 주지 않는다. 즉 마지막 <code>console.log(copy)</code>의 결과는 80이다.</p>
<p>사실 이는 실제 자바스크립트 엔진의 내부 동작과 정확히 일치하지 않을 수 있다. ECMAScript 사양에는 변수를 통해 메모리를 어떻게 관리해야 하는지 명확하게 정의되어 있지 않다. 따라서 실제 자바스크립트 엔진을 구현하는 제조사에 따라 내부 동작은 차이가 있을 수 있다.</p>
<p>위에서는 변수에 원시 값을 갖는 변수를 할당하면 원시 값이 복사되어 새로운 메모리 공간에 할당한다고 설명했지만, 변수에 원시 값을 갖는 변수를 할당하는 시점에는 두 변수가 같은 원시 값을 참조하다가 어느 한쪽의 변수에 재할당이 이뤄졌을 때 비로소 새로운 메모리 공간에 재할당된 값을 저장하도록 동작할 수도 있다.</p>
<p>또한 엄격히 말하자면 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하기에 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달된다. 따라서 “값에 의한 전달”이라는 용어도 사실 오해가 있을 수 있다.</p>
<p>결국 “값에 의한 전달”도 사실은 값이 아니라 메모리 주소를 전달한다. 단 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.<br>중요한 것은 변수에 원시 값을 갖는 변수를 할당하면 변수 할당 시점이든, 두 변수 중 어느 하나의 변수에 값을 재할당하는 시점이든 결국은 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다는 것이다.</p>
<h2 id="객체"><a href="#객체" class="headerlink" title="객체"></a>객체</h2><p>객체는 프로퍼티의 개수가 정해져 있지 않으며, 동적으로 추가되고 삭제할 수 있다. 또 프로퍼티의 값에도 제약이 없다.<br>즉 객체는 원시 값과는 다르게 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.</p>
<p>따라서 객체는 원시 값과는 다른 방식으로 동작하도록 설계되어 있다. 원시 값과의 차이를 통해 객체에 대해 이해해보자.</p>
<h3 id="변경-가능한-값"><a href="#변경-가능한-값" class="headerlink" title="변경 가능한 값"></a>변경 가능한 값</h3><p>객체 타입의 값은 변경 가능한 값이다. 이게 어떤 의미일까? 먼저 변수에 객체를 할당하면 어떤 일이 일어나는지 살펴보자</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>원시 값을 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 원시 값에 접근할 수 있다.<br>즉, 원시 값을 할당한 변수는 원시 값 자체를 값으로 갖는다. 하지만 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값에 접근할 수 있다. 참조 값은 생성된 객체가 저장된 메모리 공간의 주소이다.</p>
<p>원시 값을 할당한 변수를 참조하면 메모리에 저장되어 있는 원시 값에 접근한다. 하지만 객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조 값을 통해 실제 객체에 접근한다.</p>
<p>원시 값은 변경 불가능한 값이므로 원시 값을 갖는 변수의 값을 변경하려면 재할당 외에는 방법이 없다. 하지만 객체는 변경 가능한 값이므로 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다. 재할당 없이 프로퍼티를 동적으로 추가할 수도 있고 프로퍼티 값을 갱신할 수도 있으며 프로퍼티 자체를 삭제할 수도 있다.</p>
<p>이때 객체를 할당한 변수에 재할당을 하지 않았으므로 객체를 할당한 변수의 참조 값은 변경되지 않는다.<br>이는 메모리 사용의 효율성과 성능을 위해 어느 정도의 구조적인 단점을 감안한 설계라고 할 수 있다.</p>
<p>객체는 이러한 구조적 단점에 따른 부작용이 존재한다. 원시 값과는 다르게 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이다.</p>
<h3 id="참조에-의한-전달"><a href="#참조에-의한-전달" class="headerlink" title="참조에 의한 전달"></a>참조에 의한 전달</h3><p>여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이 무슨 의미인지, 어떤 부작용이 발생하는지 알아보자.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Lee&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> copy = person;</span><br></pre></td></tr></table></figure>

<p>객체를 가리키는 변수(원본, person)을 다른 변수(사본, copy)에 할당하면 원본의 참조 값이 복사되어 전달되는데 이를 참조에 의한 전달이라 한다.</p>
<p>원본 person과 사본 copy는 저장된 메모리 주소는 다르지만 동일한 참조 값을 가지므로 원본 person과 사본 copy 모두 동일한 객체를 가리키게 된다.<br>이것이 두 개의 식별자가 하나의 객체를 공유한다는 것을 의미한다. 따라서 원본 또는 사본 중 어느 한 쪽에서 객체를 변경하면 서로 영향을 주고받는다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> copy = person;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy === person); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">copy.<span class="property">name</span> = <span class="string">&#x27;Kim&#x27;</span>;</span><br><span class="line">person.<span class="property">address</span> = <span class="string">&#x27;Seoul&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy와 person은 동일한 객체를 가리키므로 서로 영향을 주고 받는다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123;name: &#x27;Kim&#x27;, address: &#x27;Seoul&#x27;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy); <span class="comment">// &#123;name: &#x27;Kim&#x27;, address: &#x27;Seoul&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>결국 “값에 의한 전달”과 “참조에 의한 전달”은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해 전달한다는 면에서 동일하다.<br>다만 식별자가 기억하는 메모리 공간, 즉 변수에 저장되어 있는 값이 원시 값이냐 참조 값이냐의 차이만 있을 뿐이다. 따라서 자바스크립트에는 “참조에 의한 전달”은 존재하지 않고 “값에 의한 전달”만이 존재한다고 말할 수 있지만 전달되는 값이 원시 값인지 참조 값인지 구별해 강조하는 의미로 구분해 부른다고 할 수 있다.</p>
]]></content>
      <tags>
        <tag>자바스크립트</tag>
        <tag>모던 자바스크립트 Deep Dive</tag>
      </tags>
  </entry>
  <entry>
    <title>[Deep Dive] 데이터 타입</title>
    <url>/2022/Modern-Javascript-Deep-Dive-Chapter-6-Data-Type-Summary/</url>
    <content><![CDATA[<p>데이터 타입은 값의 종류를 말한다. 자바스크립트의 모든 값은 데이터 타입을 갖는다. 자바스크립트는 8개의 데이터 타입을 가지며 7개의 원시 타입(primitive type)과 1개의 객체 타입(object&#x2F;reference type)으로 분류 가능하다.</p>
<p>데이터 타입의 종류에 따른 특징에 대해 살펴보고 데이터 타입이 왜 필요한지에 대해 알아보자.</p>
<hr>

<p>먼저 원시 타입에 대해 알아보자.</p>
<h1 id="원시-타입"><a href="#원시-타입" class="headerlink" title="원시 타입"></a>원시 타입</h1><p>원시 타입에는 숫자(Number) 타입, Bigint 타입, 문자열(String) 타입, 불리언(Boolean) 타입, undefined 타입, null 타입, 심벌(Symbol) 타입이 존재한다. 순서대로 각 타입에 대해 살펴보겠다.</p>
<h2 id="숫자-타입"><a href="#숫자-타입" class="headerlink" title="숫자 타입"></a>숫자 타입</h2><p>타 프로그래밍 언어에서는 정수(소수점 이하가 없는 숫자)와 실수(소수점 이하가 있는 숫자)를 구분해 int, long, float, double 등과 같은 다양한 숫자 타입을 제공한다. 하지만 자바스크립트는 독특하게 하나의 숫자 타입만 존재한다.</p>
<p>자바스크립트의 숫자 타입의 값은 배정밀도 64비트 부동소수점 형식을 따르기 때문에 모든 수를 실수로 처리한다.</p>
<p>숫자 타입은 추가적으로 세가지 특별한 값을 표현할 수 있다.</p>
<blockquote>
<ul>
<li>Infinity : 양의 무한대</li>
<li>-Infinity : 음의 무한대</li>
<li>NaN : 산술 연산 불가(Not-a-Number)</li>
</ul>
</blockquote>
<p>자바스크립트는 대소문자를 구별하므로 NaN을 NAN,Nan,nan과 같이 표현하면 에러가 발생한다. 자바스크립트는 NAN,Nan,nan을 식별자로 해석한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = nan; <span class="comment">// ReferenceError: nan is not defined</span></span><br></pre></td></tr></table></figure>

<h3 id="부동소수점-형식이란"><a href="#부동소수점-형식이란" class="headerlink" title="부동소수점 형식이란?"></a>부동소수점 형식이란?</h3><p>부동소수점 형식은 실수를 컴퓨터 상에서 근사하여 표현할 때 소수점의 위치를 고정하지 않고 그 위치를 나타내는 수를 따로 적는 것으로, 유효숫자를 나타내는 가수와 소수점의 위치를 풀이하는 지수로 나누어 표현한다.</p>
<p>몇 비트를 기반으로 하는지에 따라 정밀도가 달라지며 32비트를 단정밀도, 64비트를 배정밀도라 한다.</p>
<p>32비트의 경우는 부호 1비트 + 지수 8비트 + 가수 23비트로 나누어지며 64비트는 부호 1비트 + 지수 11비트 + 가수 52비트로 나누어진다.</p>
<p>지수부 계산시 bias를 더해줌으로 음수값을 가지는 지수와 양수값을 가지는 지수를 폭 넓게 표현 가능하다. (bias: 32비트-127, 64비트-1023)</p>
<h2 id="Bigint-타입"><a href="#Bigint-타입" class="headerlink" title="Bigint 타입"></a>Bigint 타입</h2><p>자바스크립트의 숫자 타입은 64비트 부동소수점 형식의 2진수로 저장된다고 했다. 64비트 부동소수점 형식으로 안정적으로 나타낼 수 있는 최대치는 2^53^ - 1이다.</p>
<p>대부분의 소규모 프로그래밍이나 웹 개발에서 안정적으로 나타낼 수 있는 수의 최대치가 존재하는것이 큰 문제는 아니었다.<br>하지만 자바스크립트가 백엔드 언어로서도 점점 유용해지고 데이터베이스에서도 사용하게 되면서 큰 정수 ID나 고정밀 타임 스탬프를 표현해야 하는 일이 생기게 되었다.</p>
<p>ES11에서는 기존의 숫자 타입보다 큰 수를 표현할 수 있도록 새로운 원시 값인 Bigint 타입을 추가하게 되었다.</p>
<p>Bigint 값은 정수 리터럴 뒤에 n을 붙이거나 Bigint 함수를 호출해 생성할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10n</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="title class_">BigInt</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h2 id="문자열-타입"><a href="#문자열-타입" class="headerlink" title="문자열 타입"></a>문자열 타입</h2><p>문자열 타입은 텍스트 데이터를 나타내는 데 사용한다. 문자열은 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합이다.</p>
<p>문자열은 작은따옴표(‘’), 큰 따옴표(“”), 백틱(&#96;&#96;)으로 텍스트를 감싼다.</p>
<p>다른 타입의 값과 달리 문자열을 따옴표로 감싸는 이유는 키워드나 식별자와 같은 토큰과 구분하기 위함이다. 만약 문자열을 따옴표로 감싸지 않으면 자바스크립트 엔진은 이를 키워드나 식별자 같은 토큰으로 인식한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = hello; <span class="comment">// ReferenceError: hello is not defined</span></span><br></pre></td></tr></table></figure>

<h3 id="템플릿-리터럴"><a href="#템플릿-리터럴" class="headerlink" title="템플릿 리터럴"></a>템플릿 리터럴</h3><p>ES6부터 템플릿 리터럴이라고 하는 새로운 문자열 표기법이 도입되었다.</p>
<p>템플릿(template)의 뜻은 주형이며 리터럴(literal)의 뜻은 정확한이다. 이를 해석해보면 정확한 주형이란 뜻이 되는데 템플릿 리터럴은 해석 그대로 리터럴 내부의 문자열을 정확히 표현한다고 생각하면 편하다.</p>
<p>템플릿 리터럴은 백틱(&#96;&#96;)으로 감싸 표현하며 멀티라인 문자열, 표현식 삽입, 태그드 템플릿과 같은 편리한 문자열 처리 기능을 제공한다.</p>
<h3 id="일반-문자열과는-어떤-차이가-있을까"><a href="#일반-문자열과는-어떤-차이가-있을까" class="headerlink" title="일반 문자열과는 어떤 차이가 있을까?"></a>일반 문자열과는 어떤 차이가 있을까?</h3><p>템플릿 리터럴은 멀티라인 문자열, 표현식 삽입과 같은 편리한 기능을 제공한다고 했다. 그럼 위 기능들이 제공되지 않는다는 소리인데 일반 문자열은 어떻게 개행과 문자열의 연결을 수행했을까?</p>
<blockquote>
<p>일반 문자열은 공백과 같은 특수 문자를 표현하기 위해 백스페이스()로 시작하는 이스케이프 시퀀스를 이용한다.</p>
<ul>
<li><code>\0(null), \b(백스페이스), \f(폼 피드, 프린터로 출력시 다음 페이지 시작지점으로 이동), \n(개행 LF), \r(개행 CR), \t(수평 탭), \v(수직 탭), \&#39;(작은 따옴표), \&quot;(큰 따옴표), \\(백슬래시)</code></li>
</ul>
</blockquote>
<blockquote>
<p>일반 문자열은 문자열 연결 연산자 +를 이용하지만 템플릿 리터럴은 표현식 삽입(${})을 이용해 문자열을 연결한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fisrst = <span class="string">&#x27;rong&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> last = <span class="string">&#x27;rong&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;My name is &#x27;</span> + first + last + <span class="string">&#x27;.&#x27;</span>); <span class="comment">// ES5의 문자열 연결, My name is rongrong.</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;first&#125;</span><span class="subst">$&#123;last&#125;</span>.`</span>); <span class="comment">// ES6 템플릿 리터럴의 표현식 삽입, My name is rongrong.</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="불리언-타입"><a href="#불리언-타입" class="headerlink" title="불리언 타입"></a>불리언 타입</h2><p>불리언 타입의 값은 논리적 참, 거짓을 나타내는 true와 false가 있다.</p>
<p>불리언 타입의 값은 참과 거짓으로 구분되는 조건에 의해 프로그램의 흐름을 제어하는 조건문에서 자주 사용된다.</p>
<h2 id="undefined-타입"><a href="#undefined-타입" class="headerlink" title="undefined 타입"></a>undefined 타입</h2><p>undefined 타입의 값은 undefined가 유일하다.</p>
<p>앞서서 var 키워드로 선언한 변수는 암묵적으로 undefined로 초기화 되는것을 살펴보았다.<br>이처럼 undefined는 개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화 할 때 사용하는 값이다.<br>변수를 참조했을 때 undefined가 반환된다면 참조한 변수가 선언 이후 초기화되지 않은 변수임을 알 수 있다.</p>
<p>undefined를 개발자가 의도적으로 변수에 할당하는 것은 본래 취지와 어긋날뿐더러 혼란을 줄 수 있으므로 좋지 않다.</p>
<p>그렇다면 변수에 값이 없다는 것을 명시하고 싶을 때는 어떻게 하면 좋을까? null을 할당해주면 된다.</p>
<h2 id="null-타입"><a href="#null-타입" class="headerlink" title="null 타입"></a>null 타입</h2><p>null 타입의 값은 null이 유일하다. 자바스크립트는 대소문자를 구별하므로 null은 Null, NULL 등과 다르다.</p>
<p>프로그래밍 언어에서 null은 변수에 값이 없다는 것을 의도적으로 명시할 때 사용한다. 변수에 null을 할당하는 것은 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미이다.</p>
<p>함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 한다. 예를들어, HTML 요소를 검색해 반환하는 document.querySelector 메서드는 조건에 부합하는 HTML 요소를 검색할 수 없는 경우 에러가 아닌 null을 반환한다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.myClass&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(element); <span class="comment">// null</span></span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="심벌-타입"><a href="#심벌-타입" class="headerlink" title="심벌 타입"></a>심벌 타입</h2><p>심벌은 ES6에서 추가된 타입으로, 변경 불가능한 원시 타입의 값이다. 심벌 값은 다른 값과 중복되지 않는 유일무이한 값이다.<br>따라서 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.</p>
<p>심벌값은 리터럴이 아닌 Symbol 함수를 호출해 생성한다.</p>
<hr>

<h1 id="객체-타입"><a href="#객체-타입" class="headerlink" title="객체 타입"></a>객체 타입</h1><p>자바스크립트는 크게 원시 타입과 객체 타입으로 분류한다. 이는 객체 타입이 다른 원시 타입들과는 다른 특성을 가짐을 의미한다.</p>
<p>객체 타입에 대해서는 다음에 자세하게 알아보도록 하겠다.</p>
<hr>

<p>지금 까지 자바스크립트의 8가지 데이터 타입에 대해 알아보았다. 그렇다면 데이터 타입은 왜 필요한 것일까?</p>
<h1 id="데이터-타입의-필요성"><a href="#데이터-타입의-필요성" class="headerlink" title="데이터 타입의 필요성"></a>데이터 타입의 필요성</h1><p>값은 메모리에 저장하고 참조할 수 있어야 한다. 값을 메모리에 저장하기 위해서는 값이 들어가기 위한 메모리 공간의 크기를 결정해야 한다.<br>즉 몇 바이트의 메모리 공간을 사용해야 낭비와 손실 없이 값을 저장할 수 있는지 알아야 한다.</p>
<p>다음과 같은 코드를 실행해보자.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> score = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>자바스크립트 엔진은 정수 리터럴 100을 평가해 숫자 타입의 값 100을 만들어 score라는 변수에 할당한다.<br>자바스크립트의 숫자 타입은 64비트 부동소수점 방식을 따른다고 했으니 숫자 타입의 값을 저장하기 위해서는 8바이트의 공간이 필요할 것이다.</p>
<p>이처럼 자바스크립트 엔진은 데이터 타입, 즉 값의 종류에 따라 정해진 크기의 메모리 공간을 확보한다.</p>
<p>이번에는 값을 참조하는 경우를 생각해보자. 식별자 score를 통해 숫자 타입의 값 100이 저장되어 있는 메모리 공간의 주소를 찾아갈 수 있다.<br>이 때 값을 참조하려면 한 번에 읽어 들여야 할 메모리 공간의 크기를 알아야 한다. score 변수의 경우, 저장되어 있는 값이 숫자 타입이므로 8바이트 단위로 읽어 들이지 않는다면 값이 훼손될 것이다.</p>
<p>역시 자바스크립트 엔진은 데이터 타입을 통해 한번에 읽어 들여야 할 메모리 공간의 크기를 결정한다.</p>
<p>아직 문제가 남아 있다. 메모리에서 읽어 들인 2진수를 어떻게 해석해야 하느냐다.<br>모든 값은 데이터 타입을 가지며 메모리에 2진수로 저장된다. 메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있다. 예를 들어, 메모리에 저장된 값 0100 0001을 숫자로 해석하면 65지만 문자열로 해석하면 ‘A’이다.</p>
<p>자바스크립트 엔진은 데이터 타입에 따라 메모리 공간에서 읽어들인 2진수를 해석한다.</p>
<p>정리하자면 다음과 같은 이유로 데이터 타입이 필요하다고 할 수 있다.</p>
<blockquote>
<ul>
<li>값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해</li>
<li>값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해</li>
<li>메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해</li>
</ul>
</blockquote>
<hr>

<p>자바스크립트의 모든 값은 데이터 타입을 가진다. 그렇다면 변수 역시 데이터 타입을 가질까?</p>
<p>C나 자바와 같은 정적 타입 언어는 변수를 선언할 때 변수에 할당할 수 있는 값의 종류(데이터 타입)을 사전에 선언해야 한다. 이를 명시적 타입 선언이라 한다.</p>
<p>정적 타입 언어는 변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있다.</p>
<p>자바스크립트는 정적 타입 언어와 다르게 변수를 선언할 때 타입을 선언하지 않고 var, let, const 키워드만 사용해 변수를 선언한다.<br>자바스크립트의 변수는 어떠한 데이터 타입의 값이라도 자유롭게 할당할 수 있다. 따라서 자바스크립트의 데이터 타입은 정적 타입 언어의 데이터 타입과는 개념이 다르다.</p>
<p>자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론)된다. 그리고 재할당에 의해 변수의 데이터 타입이 언제든지 동적으로 변할 수 있다. 이러한 특징을 동적 타이핑이라 하며, 정적 타입 언어와 구분하기 위해 동적 타입 언어라 한다.</p>
<p>동적 타입 언어는 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당 가능하므로 편리하다. 하지만 이로 인한 구조적인 단점 역시 존재한다.<br>변수 값은 언제든지 변경될 수 있기 때문에 복잡한 프로그램에서는 변화하는 변수 값을 추적하기 어려울 수 있다.</p>
<p>그 뿐만 아니라 값의 변경에 의해서도 타입도 언제든 변경될 수 있다. 따라서 동적 타입 언어의 변수는 값을 확인하기 전 타입을 확신할 수 없다.<br>또 자바스크립트는 개발자의 의도와는 관계없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환하는 경우도 존재한다.</p>
<p>이처럼 동적 타입 언어는 유연성은 높지만 신뢰성은 떨어진다.</p>
<blockquote>
<p>이러한 단점을 해결하기 위해 자바스크립트를 정적 타입 언어처럼 사용할 수 있는 타입스크립트가 등장했다. 웹의 규모가 커지면서 더 복잡한 프로그램을 만들어야 하는 경우가 많아지고 있고 따라서 타입스크립트를 다룬 경험을 요구하는 기업 또한 많아지고 있다. 자바스크립트의 동적인 부분이 단점으로 다가오는 경우가 많은것 같다. 이런 부분에 대해서도 고민이 필요할 것 같다.</p>
</blockquote>
]]></content>
      <tags>
        <tag>자바스크립트</tag>
        <tag>모던 자바스크립트 Deep Dive</tag>
      </tags>
  </entry>
  <entry>
    <title>[Deep Dive] 타입 변환과 단축 평가</title>
    <url>/2022/Modern-Javascript-Deep-Dive-Chapter-9-Summary/</url>
    <content><![CDATA[<h1 id="타입-변환이란"><a href="#타입-변환이란" class="headerlink" title="타입 변환이란?"></a>타입 변환이란?</h1><p>앞서 자바스크립트의 모든 값은 타입이 있음을 알아보았다.<br>값의 타입은 개발자의 의도에 따라 다른 타입으로 변환할 수 있는데 이를 명시적 타입 변환 또는 타입 캐스팅이라 한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 명시적 타입 변환, 숫자 -&gt; 문자열</span></span><br><span class="line"><span class="keyword">var</span> str = x.<span class="title function_">toString</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> str, str); <span class="comment">// string 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 변수의 값이 변경된 것은 아님</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> x, x); <span class="comment">// number 10</span></span><br></pre></td></tr></table></figure>

<p>개발자의 의도와는 상관없이 표현식을 평가하는 도중 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다.<br>이를 암묵적 타입 변환 또는 타입 강제 변환이라 한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 암묵적 타입 변환, 숫자 -&gt; 문자열</span></span><br><span class="line"><span class="keyword">var</span> str = x + <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> str, str); <span class="comment">// string 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 변수의 값이 변경된 것은 아님</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> x, x); <span class="comment">// number 10</span></span><br></pre></td></tr></table></figure>

<p>예시에서 볼 수 있듯이 명시적 타입 변환이나 암묵적 타입 변환이 기존 원시 값을 직접 변경하는 것은 아니다.<br>원시 값은 변경 불가능한 값으로 변경할 수 없다. 타입 변환이란 기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것이다.</p>
<p>명시적 타입 변환은 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 드러난다.<br>하지만 암묵적 타입 강제 변환은 자바스크립트 엔진에 의해 암묵적으로, 즉 드러나지 않게 타입이 자동 변환되기 때문에 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 나타나지 않는다.</p>
<p>따라서 자신이 작성한 코드에서 암묵적 타입 변환이 발생하는지, 발생한다면 어떤 타입의 어떤 값으로 변환되는지 예측 가능해야 한다.<br>만약 타입 변환 결과를 예측하지 못하거나 예측이 결과와 일치하지 않는다면 오류를 생산할 가능성이 높아진다.<br>타입 변환이 어떻게 동작하는지 정확히 이해하고 사용하자.</p>
<h2 id="암묵적-타입-변환"><a href="#암묵적-타입-변환" class="headerlink" title="암묵적 타입 변환"></a>암묵적 타입 변환</h2><p>표현식을 평가할 때 코드의 문맥메 부합하지 않는 다양한 상황이 발생할 수 있다. 이때 프로그래밍 언어에 따라 에러를 발생시키기도 하지만 자바스크립트는 가급적 에러를 발생시키지 않도록 암묵적 타입 변환을 통해 표현식을 펴가한다.</p>
<p>암묵적 타입 변환이 발생하면 문자열, 숫자, 불리언과 같은 원시 타입 중 하나로 타입을 자동 변환한다.<br>타입 별로 암묵적 타입 변환이 어떻게 발생하는지 살펴보자.</p>
<h3 id="문자열-타입으로-변환"><a href="#문자열-타입으로-변환" class="headerlink" title="문자열 타입으로 변환"></a>문자열 타입으로 변환</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">&#x27;2&#x27;</span>; <span class="comment">// &#x27;12&#x27;</span></span><br></pre></td></tr></table></figure>

<p>위 코드의 + 연산잔느 피연산자 중 하나 이상이 문자열이므로 문자열 연결 연산자로 동작한다.<br>문자열 연결 연산자의 역할은 문자열 값을 만드는 것이다. 따라서 문자열 연결 연산자의 모든 피연산자는 코드의 문맥상 모두 문자열 타입이어야 한다.</p>
<p>자바스크립트 엔진은 문자열 연결 연산자 표현식을 평가하기 위해 문자열 연결 연산자의 피연산자 중에서 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적 타입 변환한다.</p>
<p>자바스크립트 엔진은 문자열 타입이 아닌 값을 문자열 타입으로 암묵적 타입 변환을 수행할 때 다음과 같이 동작한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 숫자 타입</span></span><br><span class="line"><span class="number">0</span> + <span class="string">&#x27;&#x27;</span> <span class="comment">// &#x27;0&#x27;</span></span><br><span class="line">-<span class="number">0</span> + <span class="string">&#x27;&#x27;</span> <span class="comment">// &#x27;0&#x27;</span></span><br><span class="line"><span class="number">1</span> + <span class="string">&#x27;&#x27;</span> <span class="comment">// &#x27;1&#x27;</span></span><br><span class="line">-<span class="number">1</span> + <span class="string">&#x27;&#x27;</span> <span class="comment">// &#x27;-1&#x27;</span></span><br><span class="line"><span class="title class_">NaN</span> + <span class="string">&#x27;&#x27;</span> <span class="comment">// &#x27;NaN&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 불리언 타입</span></span><br><span class="line"><span class="literal">true</span> + <span class="string">&#x27;&#x27;</span> <span class="comment">// &#x27;true&#x27;</span></span><br><span class="line"><span class="literal">false</span> + <span class="string">&#x27;&#x27;</span> <span class="comment">// &#x27;false&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null 타입</span></span><br><span class="line"><span class="literal">null</span> + <span class="string">&#x27;&#x27;</span> <span class="comment">// &#x27;null&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined 타입</span></span><br><span class="line"><span class="literal">undefined</span> + <span class="string">&#x27;&#x27;</span> <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 심벌 타입</span></span><br><span class="line">(<span class="title class_">Symbol</span>()) + <span class="string">&#x27;&#x27;</span> <span class="comment">// TypeError: Cannot convert a Symbol value to a string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체 타입</span></span><br><span class="line">(&#123;&#125;) + <span class="string">&#x27;&#x27;</span> <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="title class_">Math</span> + <span class="string">&#x27;&#x27;</span> <span class="comment">// &#x27;[object Math]&#x27;</span></span><br><span class="line">[] + <span class="string">&#x27;&#x27;</span> <span class="comment">// &#x27;&#x27;</span></span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>] + <span class="string">&#x27;&#x27;</span> <span class="comment">// &#x27;10,20&#x27;</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;) + <span class="string">&#x27;&#x27;</span> <span class="comment">// &#x27;function()&#123;&#125;&#x27;</span></span><br><span class="line"><span class="title class_">Array</span> + <span class="string">&#x27;&#x27;</span> <span class="comment">// &#x27;function Array() &#123; [native code] &#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="숫자-타입으로-변환"><a href="#숫자-타입으로-변환" class="headerlink" title="숫자 타입으로 변환"></a>숫자 타입으로 변환</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> - <span class="string">&#x27;1&#x27;</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="number">1</span> * <span class="string">&#x27;10&#x27;</span>; <span class="comment">// 10</span></span><br><span class="line"><span class="number">1</span> / <span class="string">&#x27;one&#x27;</span>; <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>위 코드에서 사용한 연산자는 모두 산술 연산자이다.<br>산술 연산자의 역할은 숫자 값을 만드는 것이므로 산술 연산자의 모든 피연산자는 코드 문맥상 모두 숫자 타입이어야 한다.</p>
<p>자바스크립트 엔진은 산술 연산자 표현식을 평가하기 위해 산술 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다. 이때 피연산자를 숫자 타입으로 변환할 수 없는 경우는 산술 연산을 수행할 수 없으므로 표현식의 평가 결과는 NaN이 된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;1&#x27;</span> &gt; <span class="number">0</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>비교 연산자의 역할은 불리언 값을 만드는 것이다. &gt; 비교 연산자는 피연산자의 크기를 비교하므로 모든 피연산자는 코드 문맥상 모두 숫자 타입이어야 한다.<br>자바스크립트 엔진은 비교 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다.</p>
<p>자바스크립트 엔진은 숫자 타입이 아닌 값을 숫자 타입으로 암묵적 타입 변환을 수행할 때 다음과 같이 동작한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 문자열 타입</span></span><br><span class="line">+<span class="string">&#x27;&#x27;</span> + <span class="comment">// 0</span></span><br><span class="line">	<span class="string">&#x27;0&#x27;</span> + <span class="comment">// 0</span></span><br><span class="line">	<span class="string">&#x27;1&#x27;</span> + <span class="comment">// 1</span></span><br><span class="line">	<span class="string">&#x27;string&#x27;</span> + <span class="comment">// NaN</span></span><br><span class="line">	<span class="comment">// 불리언 타입</span></span><br><span class="line">	<span class="literal">true</span> + <span class="comment">// 1</span></span><br><span class="line">	<span class="literal">false</span> + <span class="comment">// 0</span></span><br><span class="line">	<span class="comment">// null 타입</span></span><br><span class="line">	<span class="literal">null</span> / <span class="number">0</span> +</span><br><span class="line">	<span class="comment">// undefined 타입</span></span><br><span class="line">	<span class="literal">undefined</span> + <span class="comment">// NaN</span></span><br><span class="line">	<span class="comment">// 심벌 타입</span></span><br><span class="line">	<span class="title class_">Symbol</span>() + <span class="comment">// TypeError: Cannot convert a Symbol value to a number</span></span><br><span class="line">	<span class="comment">// 객체 타입</span></span><br><span class="line">	&#123;&#125; + <span class="comment">// NaN</span></span><br><span class="line">	[] + <span class="comment">// 0</span></span><br><span class="line">	[<span class="number">10</span>, <span class="number">20</span>] + <span class="comment">// NaN</span></span><br><span class="line">	<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;; <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>빈 문자열(‘’), 빈 배열([]), null, false는 0으로 true는 1로 변환된다.<br>객체와 빈 배열이 아닌 배열, undefined는 변환되지 않아 NaN이 되는 것에 주의하자.</p>
<h3 id="불리언-타입으로-변환"><a href="#불리언-타입으로-변환" class="headerlink" title="불리언 타입으로 변환"></a>불리언 타입으로 변환</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;&#x27;</span>) <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br></pre></td></tr></table></figure>

<p>if 문이나 for 문과 같은 제어문 또는 삼항 조건 연산자의 조건식은 불리언 값, 즉 논리적 참과 거짓으로 평가되어야 한느 표현식이다.<br>자바스크립트 엔진은 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환한다.</p>
<p>이때 자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분한다.</p>
<p>false로 평가되는 Falsy 값은 다음과 같다.</p>
<ul>
<li>false</li>
<li>undefined</li>
<li>null</li>
<li>0, -0</li>
<li>NaN</li>
<li>‘’(빈 문자열)</li>
</ul>
<p>Falsy 값 외의 모든 값은 모두 true로 평가되는 Truthy 값이다.</p>
<h2 id="명시적-타입-변환"><a href="#명시적-타입-변환" class="headerlink" title="명시적 타입 변환"></a>명시적 타입 변환</h2><p>개발자의 의도에 따라 명시적으로 타입을 변경하는 방법은 다양하다.<br>표준 빌트인 생성자 함수(String, Number, Boolean)을 new 연산자 없이 호출하는 방법과 빌트인 메서드를 사용하는 방법, 그리고 앞서 살펴본 암묵적 타입 변환을 이용하는 방법이 있다.</p>
<h3 id="문자열-타입으로-변환-1"><a href="#문자열-타입으로-변환-1" class="headerlink" title="문자열 타입으로 변환"></a>문자열 타입으로 변환</h3><p>문자열 타입이 아닌 값을 문자열 타입으로 변환하는 방법은 다음과 같다.</p>
<ul>
<li>String 생성자 함수를 new 연산자 없이 호출</li>
<li>Object.prototype.toString 메서드를 사용</li>
<li>문자열 연결 연산자를 이용</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span>(<span class="number">1</span>); <span class="comment">// &#x27;1&#x27;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="title class_">NaN</span>); <span class="comment">// &#x27;NaN&#x27;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">true</span>); <span class="comment">// &#x27;true&#x27;</span></span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>).<span class="title function_">toString</span>(); <span class="comment">// &#x27;1&#x27;</span></span><br><span class="line"><span class="title class_">NaN</span>.<span class="title function_">toString</span>(); <span class="comment">// &#x27;NaN&#x27;</span></span><br><span class="line"><span class="literal">true</span>.<span class="title function_">toString</span>(); <span class="comment">// &#x27;true&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> + <span class="string">&#x27;&#x27;</span>; <span class="comment">// &#x27;1&#x27;</span></span><br><span class="line"><span class="title class_">NaN</span> + <span class="string">&#x27;&#x27;</span>; <span class="comment">// &#x27;NaN&#x27;</span></span><br><span class="line"><span class="literal">true</span> + <span class="string">&#x27;&#x27;</span>; <span class="comment">// &#x27;true&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="숫자-타입으로-변환-1"><a href="#숫자-타입으로-변환-1" class="headerlink" title="숫자 타입으로 변환"></a>숫자 타입으로 변환</h3><p>숫자 타입이 아닌 값을 숫자 타입으로 변환하는 방법은 다음과 같다.</p>
<ul>
<li>Number 생성자 함수를 new 연산자 없이 호출</li>
<li>parseInt, parseFloat 함수를 사용(문자열만 숫자 타입으로 변환 가능)</li>
<li>+ 단항 산술 연산자를 이용</li>
<li>* 산술 연산자를 이용</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;0&#x27;</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;10.53&#x27;</span>); <span class="comment">// 10.53</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">true</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;0&#x27;</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;10.53&#x27;</span>); <span class="comment">// 10.53</span></span><br><span class="line"></span><br><span class="line">+<span class="string">&#x27;0&#x27;</span>; <span class="comment">// 0</span></span><br><span class="line">+<span class="string">&#x27;10.53&#x27;</span>; <span class="comment">// 10.53</span></span><br><span class="line"><span class="literal">true</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> * <span class="number">1</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="string">&#x27;10.53&#x27;</span> * <span class="number">1</span>; <span class="comment">// 10.53</span></span><br><span class="line"><span class="literal">true</span> * <span class="number">1</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="불리언-타입으로-변환-1"><a href="#불리언-타입으로-변환-1" class="headerlink" title="불리언 타입으로 변환"></a>불리언 타입으로 변환</h3><p>불리언 타입이 아닌 값을 불리언 타입으로 변환하는 방법은 다음과 같다.</p>
<ul>
<li>Boolean 생성자 함수를 new 연산자 없이 호출</li>
<li>부정 논리 연산자(!)를 두전 사용</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Boolean</span>(<span class="string">&#x27;x&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="string">&#x27;&#x27;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(&#123;&#125;); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">!!<span class="string">&#x27;x&#x27;</span>; <span class="comment">// true</span></span><br><span class="line">!!<span class="string">&#x27;&#x27;</span>; <span class="comment">// false</span></span><br><span class="line">!!&#123;&#125;; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="단축-평가"><a href="#단축-평가" class="headerlink" title="단축 평가"></a>단축 평가</h2><p>이전에 연산자를 공부하면서 논리합(||) 연산자와 논리곱(&amp;&amp;) 연산자에 대해 살펴 본 적이 있다.<br>논리합(||) 또는 논리곱(&amp;&amp;) 연산자 표현식은 언제나 2개의 피연산자 중 한쪽으로 평가되는데 이를 설명하기 위해서는 암묵적 타입 변환을 알아야 한다.<br>앞서 암묵적 타입 변환에 대해 살펴보았으니 이에 대해 알아보자.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Cat&#x27;</span> &amp;&amp; <span class="string">&#x27;Dog&#x27;</span>; <span class="comment">// &#x27;Dog&#x27;</span></span><br></pre></td></tr></table></figure>

<p>논리곱(&amp;&amp;) 연산자는 두 개의 피연산자가 모두 true로 평가될 때 true를 반환한다. 논리곱 연산자는 좌항에서 우항으로 평가가 진행된다.</p>
<p>첫 번째 피연산자 ‘Cat’은 Truthy 값이므로 true로 평가된다. 하지만 이 시점까지는 위 표현식을 평가할 수 없다.<br>두 번째 피연산자까지 평가해 보아야 위 표현식을 평가할 수 있다. 즉 두 번째 피연산자가 논리곱 연산자 표현식의 평가 결과를 결정한다.<br>이때 논리곱 연산자는 논리 연산의 결과를 결정하는 두 번째 피연산자 문자열 ‘Dog’를 타입 변환 없이 그대로 반환한다.</p>
<p>논리합(||) 연산자도 논리곱(&amp;&amp;) 연산자와 동일하게 동작한다.</p>
<p>논리곱(&amp;&amp;) 연산자와 논리합(||) 연산자는 이처럼 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환한다.<br>이를 단축평가라 한다. 단축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말한다.</p>
<p>단축 평가를 사용하면 if 문을 대체할 수 있다. 어떤 조건이 Truthy 값일 때 무언가를 해야 한다면 논리곱(&amp;&amp;) 연산자를, 어떤 조건이 Falsy 값일 때 무언가를 해야 한다면 논리합(||) 연산자를 이용할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (done) message = <span class="string">&#x27;완료&#x27;</span>;</span><br><span class="line">message = done &amp;&amp; <span class="string">&#x27;완료&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// 완료</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (done) message = <span class="string">&#x27;미완료&#x27;</span>;</span><br><span class="line">message = done || <span class="string">&#x27;미완료&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// 미완료</span></span><br></pre></td></tr></table></figure>

<h3 id="옵셔널-체이닝-연산자"><a href="#옵셔널-체이닝-연산자" class="headerlink" title="옵셔널 체이닝 연산자"></a>옵셔널 체이닝 연산자</h3><p>ES11에서 도입된 옵셔널 체이닝 연산자 ?.는 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elem = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = elem?.<span class="property">value</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>옵셔널 체이닝 연산자는 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때 유용하다.<br>옵셔널 체이닝 연산자가 도입되기 이전에는 논리곱 연산자를 사용한 단축 평가를 통해 변수가 null 또는 undefined인지 확인했다.</p>
<p>논리곱 연산자는 좌항의 피연산자가 Falsy 값이면 좌항 피연산자를 그대로 반환한다. 좌항 피연산자가 Falsy 값인 0이나 ‘’인 경우도 마찬가지다.<br>하지만 0이나 ‘’은 객체로 평가될 때도 있다. 옵셔널 체이닝 연산자는 좌항 피연산자가 Falsy 값이라도 null 또는 undefined가 아니면 우항의 프로퍼티 참조를 이어간다는 차이점이 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> length1 = str &amp;&amp; str.<span class="property">length</span>;</span><br><span class="line"><span class="keyword">var</span> length2 = str?.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(length1); <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(length2); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h3 id="null-병합-연산자"><a href="#null-병합-연산자" class="headerlink" title="null 병합 연산자"></a>null 병합 연산자</h3><p>ES11에서 도입된 null 병합 연산자 ??는 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">null</span> ?? <span class="string">&#x27;default string&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// &#x27;default string&#x27;</span></span><br></pre></td></tr></table></figure>

<p>null 병합 연산자는 변수에 기본값을 설정할 때 유용하다. null 병합 연산자가 도입되기 이전에는 논리합 연산자를 사용한 단축 평가를 통해 변수에 기본값을 설정했다.</p>
<p>논리합 연산자는 좌항의 피연산자가 Falsy 값이면 우항의 피연산자를 반환한다. 만약 Falsy 값인 0이나 ‘’도 기본값으로 유효하다면 예기치 않은 동작이 발생할 수 있다. 하지만 null 병합 연산자는 좌항의 피연산자가 Falsy 값이라도 null 또는 undefined가 아니면 좌항의 피연산자를 그대로 반환한다는 차이점이 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo1 = <span class="string">&#x27;&#x27;</span> || <span class="string">&#x27;default string&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> foo2 = <span class="string">&#x27;&#x27;</span> ?? <span class="string">&#x27;default string&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo1); <span class="comment">// &#x27;default string&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo2); <span class="comment">// &#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>자바스크립트</tag>
        <tag>모던 자바스크립트 Deep Dive</tag>
      </tags>
  </entry>
  <entry>
    <title>[Deep Dive] 연산자</title>
    <url>/2022/Modern-Javascript-Deep-Dive-Chapter-7-Operator-Summary/</url>
    <content><![CDATA[<h1 id="연산자"><a href="#연산자" class="headerlink" title="연산자"></a>연산자</h1><p>연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다.</p>
<p>이 때 연산의 대상을 피연산자라 한다. 피연산자는 값으로 평가될 수 있는 표현식이어야 한다.<br>그리고 피연산자와 연산자의 조합으로 이뤄진 연산자 표현식도 값으로 평가될 수 있는 표현식이다.</p>
<p>자바스크립트가 제공하는 다양한 연산자에 대해 살펴보자.</p>
<h2 id="산술-연산자"><a href="#산술-연산자" class="headerlink" title="산술 연산자"></a>산술 연산자</h2><p>산술 연산자는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다.<br>산술 연산이 불가능한 경우, NaN을 반환한다.</p>
<p>산술 연산자는 피연산자의 개수에 따라 이항 산술 연산자와 단항 산술 연산자로 구분할 수 있다.</p>
<h3 id="이항-산술-연산자"><a href="#이항-산술-연산자" class="headerlink" title="이항 산술 연산자"></a>이항 산술 연산자</h3><p>이항 산술 연산자는 2개의 피연산자를 산술 연산하여 숫자 값을 만든다.</p>
<p>모든 이항 산술 연산자는 피연산자의 값을 변경하는 부수효과가 없다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> + <span class="number">2</span>; <span class="comment">// 7</span></span><br><span class="line"><span class="number">5</span> - <span class="number">2</span>; <span class="comment">// 3</span></span><br><span class="line"><span class="number">5</span> * <span class="number">2</span>; <span class="comment">// 10</span></span><br><span class="line"><span class="number">5</span> / <span class="number">2</span>; <span class="comment">// 2.5</span></span><br><span class="line"><span class="number">5</span> % <span class="number">2</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="단항-산술-연산자"><a href="#단항-산술-연산자" class="headerlink" title="단항 산술 연산자"></a>단항 산술 연산자</h3><p>단항 산술 연산자는 1개의 피연산자를 산술 연산하여 숫자 값을 만든다.</p>
<p>이 때 증가&#x2F;감소(++&#x2F;–) 연산자는 피연산자의 값을 변경한느 부수 효과가 있어 주의해야 한다.<br>즉 증가&#x2F;감소 연산을 하면 피연산자의 값을 변경하는 암묵적 할당이 이뤄진다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">x++; <span class="comment">// x = x + 1;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">x--; <span class="comment">// x = x - 1;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>또한 증가&#x2F;감소 연산자는 위치에 따라 선 할당후 연산이 이루어지는지, 연산이 수행되고 할당이 이루어지는지 다르므로 주의해야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>,</span><br><span class="line">	result;</span><br><span class="line"></span><br><span class="line">result = x++; <span class="comment">// 선할당 후증가</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result, x); <span class="comment">// 5 6</span></span><br><span class="line"></span><br><span class="line">result = ++x; <span class="comment">// 선증가 후할당</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result, x); <span class="comment">// 7 7</span></span><br><span class="line"></span><br><span class="line">result = x--; <span class="comment">// 선할당 후감소</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result, x); <span class="comment">// 7 6</span></span><br><span class="line"></span><br><span class="line">result = --x; <span class="comment">// 선감소 후할당</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result, x); <span class="comment">// 5 5</span></span><br></pre></td></tr></table></figure>

<p>+ 단항 연산자는 피연산자에 어떠한 효과도 없다.<br>다만 숫자 타입이 아닌 피연산자에 + 단항 연산자를 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다.<br>이때 피연산자를 변경하는 것은 아니고 숫자 타입으로 변환한 값을 생성해서 반환한다. 즉 부수 효과가 없다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+x); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// &quot;1&quot;</span></span><br></pre></td></tr></table></figure>

<p>- 단항 연산자는 피연산자에 부호를 반전한 값을 반환한다.<br>+ 단항 연산자와 마찬가지로 숫자타입이 아닌 피연산자에 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다.<br>이때 피연산자를 변경하는 것은 아니고 숫자 타입으로 변환한 값을 생성해서 반환한다. 즉 부수 효과가 없다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-(-<span class="number">10</span>); <span class="comment">// 10 (부호 반전)</span></span><br><span class="line">-<span class="literal">true</span>; <span class="comment">// -1 (타입 변환)</span></span><br></pre></td></tr></table></figure>

<h3 id="문자열-연결-연산자"><a href="#문자열-연결-연산자" class="headerlink" title="문자열 연결 연산자"></a>문자열 연결 연산자</h3><p>+ 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.<br>그 외의 경우는 산술 연산자로 동작한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 문자열 연결 연산자</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="number">2</span>; <span class="comment">// &quot;12&quot;</span></span><br><span class="line"><span class="number">2</span> + <span class="string">&#x27;1&#x27;</span>; <span class="comment">// &quot;12&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 산술 연산자</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span>; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 타입 변환이 일어나는 경우</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">true</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">undefined</span>; <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>이 때 주목할 점은 개발자의 의도와는 상관 없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다는 것이다.<br>1 + true를 연산하면 자바스크립트 엔진은 암묵적으로 불리언 타입 값인 true를 숫자 탕비인 1로 강제로 변환한 후 연산을 수행한다.</p>
<p>이를 암묵적 타입 변환이라고 한다. 앞서 살펴본 +&#x2F;- 단항 연산자도 암묵적 타입 변환이 발생한 것이다</p>
<h2 id="할당-연산자"><a href="#할당-연산자" class="headerlink" title="할당 연산자"></a>할당 연산자</h2><p>할당 연산자는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다.<br>할당 연산자는 좌항의 변수에 값을 할당하므로 변수 값이 변하는 부수 효과가 존재한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"></span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">x += <span class="number">5</span>; <span class="comment">// x = x + 5;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line">x -= <span class="number">5</span>; <span class="comment">// x = x - 5;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">x *= <span class="number">5</span>; <span class="comment">// x = x * 5;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 50</span></span><br><span class="line"></span><br><span class="line">x /= <span class="number">5</span>; <span class="comment">// x = x / 5;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">x %= <span class="number">5</span>; <span class="comment">// x = x % 5;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>표현식은 값으로 평가 될 수 있는 문이고, 문에는 표현식인 문과 표현식이 아닌 문이 존재한다.<br>그렇다면 할당문은 표현식인 문일까, 표현식이 아닌 문일까?</p>
<p>할당문은 변수에 값을 할당하는 부수 효과만 있을 뿐 값으로 평가되지 않을 것처럼 보인다.<br>하지만 할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다. 즉 변수에 할당할 수 있다.<br>이러한 특징을 활용해 여러 변수에 동일한 값을 연쇄 할당할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b, c;</span><br><span class="line"></span><br><span class="line">a = b = c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c); <span class="comment">// 0 0 0</span></span><br></pre></td></tr></table></figure>

<h2 id="비교-연산자"><a href="#비교-연산자" class="headerlink" title="비교 연산자"></a>비교 연산자</h2><p>비교 연산자는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환한다.<br>비교 연산자는 if 문이나 for 문과 같은 제어문의 조건식에서 주로 사용한다.</p>
<h3 id="동등-x2F-일치-비교-연산자"><a href="#동등-x2F-일치-비교-연산자" class="headerlink" title="동등&#x2F;일치 비교 연산자"></a>동등&#x2F;일치 비교 연산자</h3><p>동등 비교 연산자와 일치 비교 연산자는 좌항과 우항의 피연산자가 같은 값으로 평가되는지 비교해 불리언 값을 반환한다.<br>하지만 비교하는 엄격성의 정도가 다르다.</p>
<p>동등 비교(&#x3D;&#x3D;) 연산자는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다.<br>다시 말해 동등 비교 연산자는 좌항과 우항의 피연산자가 타입은 다르더라도 암묵적 타입 변환 후에 같은 값일 수 있다면 true를 반환한다.</p>
<p>동등 비교 연산자는 편리한 경우도 있지만 결과를 예측하기 어렵고 실수하기 쉬우므로 사용하지 않는 편이 좋다.</p>
<p>반면 일치 비교(&#x3D;&#x3D;&#x3D;) 연산자는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다. 따라서 일치 비교 연산자는 예측하기 쉽다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> == <span class="number">5</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">5</span> == <span class="string">&#x27;5&#x27;</span>; <span class="comment">// true (암묵적 타입 변환)</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> === <span class="number">5</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">5</span> === <span class="string">&#x27;5&#x27;</span>; <span class="comment">// false (타입 변환 X)</span></span><br></pre></td></tr></table></figure>

<p>일치 비교 연산자에서 주의할 것은 NaN이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>NaN은 자신과 일치하지 않는 유일한 값이다. 숫자가 NaN인지 조사하기 위해서는 빌트인 함수 Number.isNaN을 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>); <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">10</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>ES6에서 도입된 Object.is 메서드를 이용하면 예측 가능한 정확한 비교 결과를 얻을 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-<span class="number">0</span> === +<span class="number">0</span>; <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(-<span class="number">0</span>, +<span class="number">0</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span>; <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>부동등 비교 연산자(!&#x3D;)와 불일치 비교 연산자(!&#x3D;&#x3D;)는 각각 동등 비교(&#x3D;&#x3D;) 연산자와 일치 비교(&#x3D;&#x3D;&#x3D;) 연산자의 반대 개념이다.</p>
<h3 id="대소-관계-비교-연산자"><a href="#대소-관계-비교-연산자" class="headerlink" title="대소 관계 비교 연산자"></a>대소 관계 비교 연산자</h3><p>대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> &gt; <span class="number">0</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">5</span> &gt; <span class="number">5</span>; <span class="comment">// false</span></span><br><span class="line"><span class="number">5</span> &gt;= <span class="number">5</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">5</span> &lt;= <span class="number">5</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="삼항-조건-연산자"><a href="#삼항-조건-연산자" class="headerlink" title="삼항 조건 연산자"></a>삼항 조건 연산자</h2><p>삼항 조건 연산자는 조건식의 평가 결과에 따라 반환할 값을 결정한다.<br>자바스크립트의 유일한 삼항 연산자이며, 부수 효과는 없다.</p>
<p>삼항 조건 연산자의 표현식은 다음과 같다.</p>
<blockquote>
<p>조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값</p>
</blockquote>
<p>삼항 조건 연산자는 첫 번째 피연산자가 true로 평가되면 두 번째 피연산자를 반환하고, 첫 번째 피연산자가 false로 평가되면 세 번째 피연산자를 반환한다.<br>즉 삼항 조건 연산자는 두 번째 피연산자 또는 세 번째 피연산자로 평가되는 표현식이다.</p>
<p>삼항 조건 연산자는 if…else 문을 사용해도 유사하게 처리 가능하다. 하지만 삼항 조건 연산자 표현식은 값처럼 사용할 수 있는 반면 if…else 문은 값처럼 사용할 수 없다는 차이가 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result1 = x % <span class="number">2</span> ? <span class="string">&#x27;홀수&#x27;</span> : <span class="string">&#x27;짝수&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result1); <span class="comment">// 짝수</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result2 = <span class="keyword">if</span> (x % <span class="number">2</span>) &#123; result2 = <span class="string">&#x27;홀수&#x27;</span>; &#125; <span class="keyword">else</span> &#123; result2 = <span class="string">&#x27;짝수&#x27;</span>; &#125;; <span class="comment">// SyntaxError: Unexpected token if</span></span><br></pre></td></tr></table></figure>

<p>조건에 따라 어떤 값을 결정해야 한다면 if…else 문보다 삼항 조건 연산자 표현식을 사용하는 편이 유리하다.<br>하지만 조건에 따라 수행해야 할 문이 하나가 아니리 여러 개라면 if…else 문의 가독성이 더 좋다.</p>
<h2 id="논리-연산자"><a href="#논리-연산자" class="headerlink" title="논리 연산자"></a>논리 연산자</h2><p>논리 연산자는 우항과 좌항의 피연산자(부정 논리 연산자의 경우 우항의 피연산자)를 논리 연산 한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 논리합(||) 연산자</span></span><br><span class="line"><span class="literal">true</span> || <span class="literal">true</span>; <span class="comment">// true</span></span><br><span class="line"><span class="literal">true</span> || <span class="literal">false</span>; <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> || <span class="literal">true</span>; <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> || <span class="literal">false</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 논리곱(&amp;&amp;) 연산자</span></span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="literal">true</span>; <span class="comment">// true</span></span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="literal">false</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> &amp;&amp; <span class="literal">true</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> &amp;&amp; <span class="literal">false</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 논리 부정(!) 연산자</span></span><br><span class="line">!<span class="literal">true</span>; <span class="comment">// false</span></span><br><span class="line">!<span class="literal">false</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>논리 부정(!) 연산자는 언제나 불리언 값을 반환한다. 단 피연산자가 반드시 불리언 값일 필요는 없다.<br>피연산자가 불리언 값이 아니라면 불리언 타입으로 암묵적 타입 변환된다.</p>
<h2 id="쉼표-연산자"><a href="#쉼표-연산자" class="headerlink" title="쉼표 연산자"></a>쉼표 연산자</h2><p>쉼표(,) 연산자는 왼쪽 피연산자부터 차레대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y, z;</span><br><span class="line"></span><br><span class="line">(x = <span class="number">1</span>), (y = <span class="number">2</span>), (z = <span class="number">3</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h2 id="그룹-연산자"><a href="#그룹-연산자" class="headerlink" title="그룹 연산자"></a>그룹 연산자</h2><p>소괄호(())로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가한다. 따라서 그룹 연산자를 사용하면 연산자의 우선순위를 조절할 수 있다. 그룹 연산자는 연산자 우선순위가 가장 높다.</p>
<h2 id="typeof-연산자"><a href="#typeof-연산자" class="headerlink" title="typeof 연산자"></a>typeof 연산자</h2><p>typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환한다.<br>typeof 연산자는 “number”, “bigint”, “string”, “boolean”, “undefined”, “symbol”, “object”, “function” 중 하나를 반환한다.<br>typeof 연산자가 반환하는 문자열이 데이터 타입과 정확히 일치하지는 않는다.</p>
<p>typeof 연산자로 null 값을 연산해 보면 “null”이 아닌 “object”를 반환하는데 이는 하위 호환성을 위해 수정되지 않고 있는 버그이다.<br>따라서 값이 null 타입인지 확인할 때는 typeof 연산자가 아닌 일치(&#x3D;&#x3D;&#x3D;) 연산자를 사용해야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> foo === <span class="literal">null</span>; <span class="comment">// false</span></span><br><span class="line">foo === <span class="literal">null</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>또한 선언하지 않은 식별자를 typeof 연산자로 연산해 보면 ReferenceError가 발생하지 않고 undefined를 반환하는것도 주의하자.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// undeclared 식별자를 선언하지 않았다.</span></span><br><span class="line"><span class="keyword">typeof</span> undeclared; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="지수-연산자"><a href="#지수-연산자" class="headerlink" title="지수 연산자"></a>지수 연산자</h2><p>ES7에서 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱한 숫자 값을 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">2</span>; <span class="comment">// 4</span></span><br><span class="line"><span class="number">2</span> * <span class="number">0</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="number">2</span> ** -<span class="number">2</span>; <span class="comment">// 0.25</span></span><br></pre></td></tr></table></figure>

<p>지수 연산자가 도입되기 이전에는 Math.pow 메서드를 사용했다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">0</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, -<span class="number">2</span>); <span class="comment">// 0.25</span></span><br></pre></td></tr></table></figure>

<p>음수를 거듭제곱의 밑으로 사용해 계산하려면 괄호로 묶어주어야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-<span class="number">5</span> ** <span class="number">2</span>;</span><br><span class="line"><span class="comment">// SyntaxError: Unary operator used immediately before exponentiation expression. Parenthesis must be used to disambiguate operator precedence</span></span><br><span class="line"></span><br><span class="line">(-<span class="number">5</span>) ** <span class="number">2</span>; <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>

<h2 id="연산자-우선순위"><a href="#연산자-우선순위" class="headerlink" title="연산자 우선순위"></a>연산자 우선순위</h2><p>연산자 우선순위란 여러 개의 연산자로 이뤄진 문이 실행될 때 연산자가 실행되는 순서를 말한다. 우선순위가 높을수록 먼저 실행된다.</p>
<p>연산자는 종류가 많아 연산자 우선순위를 모두 기억하기 어렵고 실수하기도 쉽다.<br>따라서 기억해 사용하기 보다는 연산자 우선순위가 높은 그룹 연산자를 사용하여 우선순위를 명시적으로 조절하는 것이 좋다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> * (<span class="number">2</span> + <span class="number">3</span>); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>자바스크립트</tag>
        <tag>모던 자바스크립트 Deep Dive</tag>
      </tags>
  </entry>
  <entry>
    <title>백준 Node.js 입출력법</title>
    <url>/2022/Node-js-input-and-output-in-Baekjoon-Online-Judge/</url>
    <content><![CDATA[<p>지금까지 leetcode와 프로그래머스를 통해 코딩테스트 공부를 하고 있었는데 leetcode는 영어 해석의, 프로그래머스는 적은 문제수의 단점을 가지고 있어 백준을 통해 코딩테스트 연습을 시작해보았다.</p>
<p>백준에서는 javascript로 코딩테스트를 준비하기 위해 node.js를 선택해야 했는데 프로그래머스에서는 함수만 작성하면 되었던 반면에 백준에서는 입출력을 직접 해주어야 했다.</p>
<p>백준에서 node.js로 입력을 받는 방법은 크게 두가지로 readline 모듈을 사용하는 것과 fs 모듈을 사용하는 것이다. fs 모듈의 경우 readline 모듈보다 코드가 간단하고 더 빠르다고 해 fs 모듈의 대해 찾아보았다.</p>
<hr>

<h1 id="fs"><a href="#fs" class="headerlink" title="fs"></a><strong>fs</strong></h1><p>FileSystem의 약자인 fs 모듈은 파일 처리와 관련된 모듈이다. <a href="https://help.acmicpc.net/">BOJ 도움말</a>에서는 다음과 같은 코드로 fs 모듈을 통한 입력을 소개하고 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> input = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;/dev/stdin&#x27;</span>).<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">parseInt</span>(input[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">parseInt</span>(input[<span class="number">1</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a + b);</span><br></pre></td></tr></table></figure>

<p>하지만 위 코드를 이용할때에도 입력되는 값에 따라 에러가 발생하는 경우가 있어 다양한 방식의 입력법에 대해 정리해 보았다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 하나의 값을 입력받을 때</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> input = fs.<span class="title function_">readFileSync</span>(<span class="string">&quot;/dev/stdin&quot;</span>).<span class="title function_">toString</span>().<span class="title function_">trim</span>();</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 공백으로 구분된 한 줄의 값들을 입력받을 때</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> input = fs.<span class="title function_">readFileSync</span>(<span class="string">&quot;/dev/stdin&quot;</span>).<span class="title function_">toString</span>().<span class="title function_">trim</span>().<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 여러 줄의 값들을 입력받을 때</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> input = fs.<span class="title function_">readFileSync</span>(<span class="string">&quot;/dev/stdin&quot;</span>).<span class="title function_">toString</span>().<span class="title function_">trim</span>().<span class="title function_">split</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 첫 번째 줄에 자연수 n을 입력받고, 그 다음줄에 공백으로 구분된 n개의 값들을 입력받을 때</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> [n, ...arr] = fs.<span class="title function_">readFileSync</span>(<span class="string">&quot;/dev/stdin&quot;</span>).<span class="title function_">toString</span>().<span class="title function_">trim</span>().<span class="title function_">split</span>(<span class="regexp">/\s/</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 첫 번째 줄에 자연수 n을 입력받고, 그 다음줄부터 n개의 줄에 걸쳐 한 줄에 하나의 값을 입력받을 때</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> [n, ...arr] = fs.<span class="title function_">readFileSync</span>(<span class="string">&quot;/dev/stdin&quot;</span>).<span class="title function_">toString</span>().<span class="title function_">trim</span>().<span class="title function_">split</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> 하나의 값 또는 공백으로 구분된 여러 값들을 여러 줄에 걸쳐 뒤죽박죽 섞여서 입력받을 때</span><br><span class="line">  ex) n 입력 - 공백으로 구분된 n개의 값 입력 - m 입력 - 여러 줄에 걸쳐 m개의 값 입력</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> input = fs.<span class="title function_">readFileSync</span>(<span class="string">&quot;/dev/stdin&quot;</span>).<span class="title function_">toString</span>().<span class="title function_">trim</span>().<span class="title function_">split</span>(<span class="regexp">/\s/</span>);</span><br><span class="line"><span class="keyword">const</span> n = input[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> n_arr = input.<span class="title function_">slice</span>(<span class="number">1</span>, n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> [m, ...m_arr] = input.<span class="title function_">slice</span>(n+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>최종 결과 확인을 위해선 <strong>console.log()</strong> 를 통해 값을 출력해주면 된다.</p>
<hr>

<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><p><a href="https://overcome-the-limits.tistory.com/25">[알고리즘] 백준 0.nodejs 입력하기</a><br><a href="https://tesseractjh.tistory.com/39">Node.js로 백준(BOJ) 문제 풀 때 유의할 점들</a></p>
]]></content>
      <tags>
        <tag>자바스크립트</tag>
        <tag>코딩테스트</tag>
      </tags>
  </entry>
  <entry>
    <title>원티드 프리온보딩 프론트엔드 인턴십 1주차 회고</title>
    <url>/2023/Retrospect-About-1st-Week-Of-Wanted-Pre-Onboarding-Frontend-InternShip/</url>
    <content><![CDATA[<p><img src="/../images/wanted-preonboarding.jpeg" alt="원티드 프리온보딩 프론트엔드 인턴십"></p>
<h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>4주동안 진행되는 원티드 프리온보딩 프론트엔드 인턴십의 1주차가 지나갔다.</p>
<p>이번 1주차의 프로젝트는 인턴십을 지원하기 위해 수행했던 사전과제를 바탕으로 진행되었기 때문에 수월하기도 했지만 또 한편으로는 처음 팀을 구성하고 조율해야하는 부분들이 있어 어려운 부분들도 존재했다. 특히 단기간 오랜 시간을 집중해야 하는 상황 + 협업을 오랜만에 겪다보니 조금 힘들기도하고 적응이 잘 안되는 부분도 존재했다.</p>
<p>언제나 그렇듯이 좋았던 부분도 있었고 아쉬운 부분도 있었는데, 앞으로 더 보람있는 3주를 위해 1주차에 대해 회고를 해보려고 한다.</p>
<h1 id="원티드-프리온보딩-프론트엔드-인턴십-1주차-과제"><a href="#원티드-프리온보딩-프론트엔드-인턴십-1주차-과제" class="headerlink" title="원티드 프리온보딩 프론트엔드 인턴십 1주차 과제"></a>원티드 프리온보딩 프론트엔드 인턴십 1주차 과제</h1><h2 id="2023-04-25-첫-회의"><a href="#2023-04-25-첫-회의" class="headerlink" title="2023.04.25 - 첫 회의"></a>2023.04.25 - 첫 회의</h2><p>이번 프로젝트는 동료학습을 통해서 팀에서 생각한 원티드 프리온보딩 프론트엔드 인턴십 <a href="https://github.com/walking-sunset/selection-task">선발 과제</a>의 Best Pratice를 만들고 제출하는 과제였다.</p>
<p>Best Practice란 모범사례라는 말로서, 특정 문제를 효과적으로 해결하기 위한 가장 성공적인 해결책 또는 방법론을 의미하는데, 사람들마다 좋은 해결책에 대한 생각이 다를 것이기에 처음 과제를 안내받았을때부터 <code>&#39;아 이거 이미 수행했던 과제를 바탕으로 진행한다고는 해도 쉽지만은 않겠다&#39;</code>라는 생각이 들었다. 특히 이번 과제를 같이 진행하게된 팀원의 수가 총 10명이기에 더욱 그랬다.</p>
<p>과제를 수행하는 기간이 2023-04-25 ~ 2023-04-28로 총 4일이였기에 아무 준비없이 첫 회의에 들어가면 시간적으로 너무 촉박할것 같아 다음처럼 간단히 첫 회의에서 진행했으면 하는 일에 대한 체크리스트를 만들어 갔다.</p>
<ul>
<li>체크리스트<ul>
<li>자기소개 및 팀장 정하기</li>
<li>Communication Tool - Discord, slack etc.</li>
<li>일정 공유 및 정규 회의시간 정하기</li>
<li>Repository 관리 및 README.md 작성법</li>
<li>각자가 생각하는 Best Practice란?</li>
<li>Best Practice 선정 단위 - Assignment, Component etc.</li>
</ul>
</li>
</ul>
<p>이런 준비덕분(<del>때문</del>)이였을까? 자기소개를 하고 팀장을 정하는 자리에서 팀원분들이 나를 팀장으로 추천해주셨다. 이번 인턴십에서 팀장이라는 역할이 기술적인 리딩을 하는 자리는 아니여서 크게 다를 것은 없었지만, 의견 조율과 같은 부분에서 중심을 잡아야 하지 않을까라는 생각에 부담이 있긴 했다. 그래도 이런 경험을 할 수 있는 기회가 많지도 않고, 또 성장하는데에 도움이 될 것 같아 팀장 자리를 맡기로 했다.</p>
<p>그 후 준비해간 체크리스트대로 Best Practice에 대해 얘기를 나누었고, 대략적인 선정 기준을 정한 후 다음 회의 일정을 잡게 되었다.</p>
<h2 id="2023-04-26-두번째-회의"><a href="#2023-04-26-두번째-회의" class="headerlink" title="2023.04.26 - 두번째 회의"></a>2023.04.26 - 두번째 회의</h2><p>두번째 회의에서는 다음과 같은 체크리스트를 만들어가서 회의를 진행했다.</p>
<ul>
<li>체크리스트<ul>
<li>팀명 정하기</li>
<li>Repository</li>
<li>프로젝트 세팅</li>
<li>컨벤션 세팅</li>
<li>사전과제 Assignment 1-4 리뷰</li>
<li>과제 진행 방향 및 수행</li>
</ul>
</li>
</ul>
<p>처음 환경설정을 위해 모두가 모여 어떤 라이브러리를 사용할지 또 팀적으로 정하고 갈 컨벤션들에 대해 논의를 나누고 실제 세팅을 진행했다. 역시나 ESLint, Prettier등의 설정이 한번에 완벽히 되지는 않았고 <code>&#39;아 역시 환경설정이 쉽진 않네&#39;</code>라고 생각이 들었고 더 경험을 쌓아야겠다고 느꼈다.</p>
<p>또한 다른 팀원분이 Craco라는 (나는 이번에 처음 알게된) 라이브러리를 사용하자고 의견을 제시해 주셨는데, Craco를 사용하는 이유를 알아보며 지금까지 무심코 사용했던 CRA(Create-React-App)의 내부 구조에 대해서도 더 알 수 있었다.</p>
<p>그 후 Assignment 별로 각자가 생각하는 Best Practice에 대해 얘기를 나누었다. <code>팀원분들마다 어떤 코드가 좋다고 생각하는 이유가 다양했고, 다른 관점들에 대해 듣다보니 코드를 바라보는 시야가 넓어지는것 같아서 좋았다.</code> 아마 이런 점이 동료학습의 가장 큰 장점이 아닐까?</p>
<p>여튼 각 Assignment마다 특별한 부분이 있기는 했지만 공통적으로 코드의 가독성, 성능 최적화, 유저 편의성이 Best Practice로 선정하는데에 가장 중요하다고 정해졌고 이 세가지 항목을 신경쓰면서 기능을 구현하기로 했다.</p>
<h2 id="그-후"><a href="#그-후" class="headerlink" title="그 후"></a>그 후</h2><p>두번째 회의 이후로는 회의를 통해 선정한 Best Practice에 따라 Assignment별 담당자가 기능을 구현했고 이를 PR한 내용을 같이 확인하며 코드 리뷰를 진행했다. 더 자세한 내용은 <a href="https://github.com/WANTED-TEAM03/pre-onboarding-10th-1-3#readme">README.md</a>를 통해 확인 가능하다.</p>
<h2 id="KPT"><a href="#KPT" class="headerlink" title="KPT"></a>KPT</h2><p>과제를 진행하면서 많은 부분들에 대해 생각해 볼 수 있었고, 알게 된 점들도 많아서 좋았다. 하지만 아쉬운 부분도 존재했는데 각 부분을 정리해보고자 한다.</p>
<h3 id="Keep"><a href="#Keep" class="headerlink" title="Keep"></a>Keep</h3><ul>
<li>몇번의 프로젝트를 진행하면서 기록의 중요성에 대해 많이 느끼게 되었다. 이번 인턴십에서는 꼭 문서화를 잘 해보자고 생각했는데 뛰어난 팀원분들 덕분에 만족스러운 README.md 및 기록을 남길 수 있었다!</li>
</ul>
<h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><ul>
<li><p>Github을 통해 코드를 관리할 때, <code>Issue를 발행하고 그 Issue 번호에 따라 새로운 branch를 생성한 후 코드를 작성하고 develop branch에 병합한 후 마지막에 develop branch를 main branch에 병합하는 전략</code>을 택했다. 그런데 중간에 develop branch에 PR을 날려야 하는데 main branch PR을 날린 것을 제대로 확인하지 못하고 병합을 하는 실수를 2번이나 반복했다. 리뷰 과정의 체크리스트를 만드는등의 실수를 최소화하는 방법을 생각해 봐야 할 것 같다.</p>
</li>
<li><p>확실히 10명이나 되는 사람들의 일정이 조율되기는 어려웠다. 의견 공유에는 화상회의와 같은 실시간 소통이 가장 효율적이라고 생각하는데 이게 쉽지만은 않을 것 같다. 이번에는 수행했던 사전과제를 바탕으로 해서 수월했지만 다음부터는 새로운 과제를 수행하고 이를 바탕으로 의견을 나누어야 하는데 <code>Issues, Pull requests</code>등을 조금 더 잘 활용할 방안에 대해 생각해 봐야 할 것 같다.</p>
</li>
</ul>
<h3 id="Try"><a href="#Try" class="headerlink" title="Try"></a>Try</h3><ul>
<li>더 많은 의견을 공유하자 ! - 이번 인턴십에 참여하면서 가장 중요하게 여겼던 점은 (물론 취업에 도움이 되기에 선택한 것이지만) 성장이다. 특히 평상시에 가지기 어려운 다른 개발자와의 소통을 통해 내가 생각하지 못했던 관점을 알아 가고 싶다고 생각했다. <code>인턴십 기간동안 보람찬 3조가 되자!</code>라는 의미에서 보람삼조라는 팀명을 정했는데, 정말 보람찬 기간으로 만들기 위해 더 많은 의견을 공유하고 배워가야겠다.</li>
</ul>
]]></content>
      <tags>
        <tag>회고</tag>
      </tags>
  </entry>
  <entry>
    <title>[Deep Dive] 표현식과 문</title>
    <url>/2022/Modern-Javascript-Deep-Dive-Chapter-5-Summary/</url>
    <content><![CDATA[<p>변수에 대해 살펴보면서 지속적으로 값이라는 용어가 등장했다. 표현식과 문에 대해 알아보기 이전에 값이란 무엇인지 알아보자.</p>
<hr>

<h1 id="값"><a href="#값" class="headerlink" title="값"></a>값</h1><p>값이란 (표현)식이 평가되어 생성된 결과를 말한다.<br>평가란 식을 해석해서 값을 생성하거나 참조하는 것을 의미한다.</p>
<p>변수란 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이였다. 즉 변수에 할당되는 것은 값이다.</p>
<p>값이란 어떻게 생성할 수 있을까? 가장 기본적인 방법은 리터럴을 사용하는 것이다.</p>
<hr>

<h1 id="리터럴"><a href="#리터럴" class="headerlink" title="리터럴"></a>리터럴</h1><p>리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법이다.</p>
<p>리터럴은 문자 또는 미리 약속된 기호로 표기한 코드이며 자바스크립트 엔진은 코드가 실행되는 시점인 런타임에 리터럴을 평가해 값을 생성한다.</p>
<p>리터럴을 사용해 다양한 종류의 값을 생성할 수 있다.</p>
<h2 id="엔진은-어떻게-리터럴을-구별할까"><a href="#엔진은-어떻게-리터럴을-구별할까" class="headerlink" title="엔진은 어떻게 리터럴을 구별할까?"></a>엔진은 어떻게 리터럴을 구별할까?</h2><p>리터럴은 값을 생성하기 위해 미리 약속한 표기법으로 자바스크립트 엔진 내부에 리터럴을 구분해 값을 생성 할 수 있도록 하드코딩 되어있다.</p>
<hr>

<p>리터럴 이외에 값을 생성하는 또 다른 방법에는 무엇이 있을까? 값에 대해 살펴보면서 언급했듯이 표현식이 존재한다.</p>
<h1 id="표현식"><a href="#표현식" class="headerlink" title="표현식"></a>표현식</h1><p>표현식은 값으로 평가될 수 있는 문이다. 즉 표현식이 평가되면 새로운 값을 생성하거나 값을 참조한다.</p>
<p>앞서 살펴본 리터럴은 값으로 평가된다. 그러므로 리터럴도 사실 표현식이다.</p>
<p>표현식은 값으로 평가되는데, 이때 표현식과 표현식이 평가된 값은 동등한 관계이다.</p>
<p>다음 예시를 살펴보자. 예를들어, 산술 연산자 + 의 좌항과 우항에는 숫자 값이 위치해야 한다. 이 때 표현식이 숫자 값으로 평가될 수 있다면 숫자 값 대신 사용할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">x + <span class="number">3</span>; <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>위 코드의 x + 3에서 + 연산자의 좌항과 우항에는 숫자 값이 위치해야 한다. 이 때 좌항 x 는 식별자 표현식이다. 즉 x는 할당되어 있는 숫자 값 3 으로 평가된다. 즉 표현식과 표현식이 평가된 값은 동치이며 이처럼 표현식은 다른 표현식의 일부가 되어 새로운 값을 만들어 낼 수 있다.</p>
<hr>

<p>앞서 표현식은 값으로 평가될 수 있는 문이라고 했다. 그럼 문이란 무엇일까?</p>
<h1 id="문"><a href="#문" class="headerlink" title="문"></a>문</h1><p>문은 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다. 문은 여러 토큰으로 구성되는데, 토큰이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.</p>
<p>문을 명령문이라고도 부른다. 문이 실행되면 명령이 실행되고 무슨 일인가가 일어나게 된다.</p>
<p>문은 선언문, 할당문, 조건문, 반복문등 다양한 종류로 나누어진다.</p>
<p>세미콜론을 통해 문의 종료를 나타낼 수 있다. 즉 자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행한다. 단 중괄호로 묶은 코드 블록은 자체 종결성을 가지므로 세미콜론을 붙이지 않는다.</p>
<p>문의 끝에 붙이는 세미콜론은 옵션이다. 이는 자바스크립트 엔진이 소스코드를 해석하며 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 삽입하는 ASI를 수행하기 때문이다.</p>
<hr>

<p>그렇다면 표현식과 문은 어떻게 구별 할 수 있을까? 표현식도 문의 일부니 정확히 말하자면 표현식인 문과 표현식이 아닌 문을 어떻게 구별 할 수 있을까?</p>
<h1 id="표현식인-문과-표현식이-아닌-문"><a href="#표현식인-문과-표현식이-아닌-문" class="headerlink" title="표현식인 문과 표현식이 아닌 문"></a>표현식인 문과 표현식이 아닌 문</h1><p>표현식인 문은 값으로 평가될 수 있는 문이며, 표현식이 아닌 문은 값으로 평가될 수 없는 문을 말한다. 예를들어, 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아닌 문이다.</p>
<p>표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단한 방법은 변수에 할당해 보는 것이다.</p>
<p>변수는 값을 저장하기 위한 메모리 공간이였으므로 변수에 할당할 수 있는 문은 즉 값으로 평가된는 표현식이라고 볼 수 있다.</p>
]]></content>
      <tags>
        <tag>자바스크립트</tag>
        <tag>모던 자바스크립트 Deep Dive</tag>
      </tags>
  </entry>
  <entry>
    <title>IR기법 (Image Replacement)</title>
    <url>/2022/Image-Replacement/</url>
    <content><![CDATA[<h1 id="👀"><a href="#👀" class="headerlink" title="👀"></a>👀</h1><p>WCAG 2.1에 웹 콘텐츠의 접근성을 향상시키기 위해 텍스트 아닌 콘텐츠에 대해 대체 텍스트를 제공해주어야 한다는 지침이 있다. 이미지 역시 텍스트가 아닌 콘텐츠이기 때문에 대체 텍스트를 제공해주어야 하는데, 이는 접근성의 향상 뿐만 아니라 SEO(검색 엔진 최적화)와도 관련이 있어 중요하다.</p>
<p>이렇게 사용자에게 대체 텍스트를 제공하는 것을 IR(Image Replacement)이라고 하는데, HTML의 요소를 사용할 경우 alt 속성을 통해 대체 텍스트를 제공하는것이 일반적이다.</p>
<p>하지만 CSS를 이용해 background-image를 넣는 경우도 많기에 어떻게 대체 텍스트를 제공하는지 정리해보자.</p>
<hr>

<h1 id="😒-visibility-hidden-display-none"><a href="#😒-visibility-hidden-display-none" class="headerlink" title="😒 visibility: hidden, display: none"></a>😒 visibility: hidden, display: none</h1><p>먼저 IR기법으로 잘못 사용되고 있는 대표적인 예가 있는데 visibility: hidden과 display: none이다.</p>
<p>이 두 방법은 모두 적용된 요소가 화면에서 보이지 않게 하기 때문에 스크린리더 사용자를 위한 텍스트를 제공하기 위해 사용되는 경우를 발견할 수 있다. 하지만 이 두 방법은 스크린리더에서도 읽지 않는것을 원칙으로 한다.</p>
<p>IR기법의 목표는 대체 텍스트를 시각적으는 숨기지만 스크린 리더 사용자는 읽을 수 있어야 하기 때문에 이 두가지 방법은 옳지 않다.</p>
<hr>

<h1 id="😊-올바른-IR-기법"><a href="#😊-올바른-IR-기법" class="headerlink" title="😊 올바른 IR 기법"></a>😊 올바른 IR 기법</h1><h2 id="Phark-Method"><a href="#Phark-Method" class="headerlink" title="Phark Method"></a>Phark Method</h2><ul>
<li><p>가장 널리 사용되는 방법으로 이미지로 대체할 엘리먼트에 배경이미지를 설정하고 글자는 text-indent를 이용하여 화면 바깥으로 빼내어 보이지 않게 하는 방법이다.</p>
</li>
<li><p>의미있는 이미지의 대체 텍스트를 제공하는 경우에 사용한다.</p>
</li>
<li><p>Text-indent 속성은 사용하기 간편하지만 단점 또한 존재한다. 만약 이미지가 제대로 로드되지 않으면 텍스트가 보이지 않기 때문에 스크린리더 사용자가 아닌 경우 이미지를 설명하는 텍스트를 보고 콘텐츠의 내용을 확인 할 수 없다. 또한, 웹페이지에 text-indent 스타일 속성이 적용된 요소가 많으면 성능 저하를 불러올 수 있다.</p>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.ir_pm</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">995px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">1441px</span>;</span><br><span class="line">	<span class="attribute">text-indent</span>: -<span class="number">9999px</span>;</span><br><span class="line">	<span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&#x27;rocketgril_poster.jpg&#x27;</span>) no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dwyer-Method"><a href="#Dwyer-Method" class="headerlink" title="Dwyer Method"></a>Dwyer Method</h2><ul>
<li><p>이미지로 대체할 엘리먼트에 배경이미지를 설정하고 글자는 span태그로 감싼 후 width와 height를 각각 0으로 하여 넘치는 글자를 숨기는 방법이다.</p>
</li>
<li><p>추가적인 tag를 사용하고, Phark Method와 마찬가지로 이미지가 제대로 로드되지 않으면 텍스트가 보이지 않아 콘텐츠 내용 확인이 어렵다는 단점이 존재한다.</p>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.ir_dm</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">995px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">1441px</span>;</span><br><span class="line">	<span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&#x27;rocketgril_poster.jpg&#x27;</span>) no-repeat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.ir_dm</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: block;</span><br><span class="line">	<span class="attribute">overflow</span>: hidden;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WA-IR"><a href="#WA-IR" class="headerlink" title="WA IR"></a>WA IR</h2><ul>
<li><p>접근성 및 UX(User Experience) 향상을 위한 화면읽기프로그램 활용 기법으로 권장되는 방법이다.</p>
</li>
<li><p>의미있는 이미지의 대체 텍스트로 이미지가 없어도 대체 텍스트를 보여주고자 할 때 사용한다.</p>
</li>
<li><p>이미지로 대체할 엘리먼트에 배경이미지를 설정하고 글자는 span 태그로 감싼 후 z-index:-1을 이용하여 배치순서를 뒤로 보내어 화면에 안보이게 처리한다.</p>
</li>
<li><p>만약 브라우저에서 CSS를 끄거나, 웹 페이지에 적용된 CSS가 정상적으로 로드되지 않을 때 숨겨진 텍스트가 화면에 출력된다. 또한, position 속성을 사용하기 때문에 성능에 영향을 줄 수 있다.</p>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.ir_wa</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">995px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">1441px</span>;</span><br><span class="line">	<span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&#x27;rockegril_poster.jpg&#x27;</span>) no-repeat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.ir_wa</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: block;</span><br><span class="line">	<span class="attribute">position</span>: relative;</span><br><span class="line">	<span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이 외에도 CSS의 위치 속성과 overflow: hidden을 사용하는 방법, 자바스크립트를 이용하여 이미지로 대체할 엘리먼트의 텍스트를 img태그로 교체하는 방법등 다양한 방법이 존재한다.</p>
<hr>

<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li><a href="https://m.blog.naver.com/eirene100999/221686480420">https://m.blog.naver.com/eirene100999/221686480420</a></li>
<li><a href="https://nuli.navercorp.com/community/article/1132804?email=true">https://nuli.navercorp.com/community/article/1132804?email=true</a></li>
<li><a href="https://alonehistory.tistory.com/14">https://alonehistory.tistory.com/14</a></li>
</ul>
]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>IR</tag>
      </tags>
  </entry>
  <entry>
    <title>원티드 프리온보딩 프론트엔드 인턴십 2주차 회고</title>
    <url>/2023/Retrospect-About-2nd-Week-Of-Wanted-Pre-Onboarding-Frontend-InternShip/</url>
    <content><![CDATA[<p><img src="/../images/wanted-preonboarding.jpeg" alt="원티드 프리온보딩 프론트엔드 인턴십"></p>
<h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>원티드 프리온보딩 프론트엔드 인턴십의 2주차가 지나갔다. 저번주도 마찬가지였지만 이번주도 너무 빠르게 지나가 버렸다.</p>
<p>저번주에는 인턴십 기간 동안의 협업 과정에 대한 틀을 만들어야 해서 힘들었다면, 이번 주에는 새로 주어진 과제를 수행하는 것 부터 시작해야 했기 때문에 고민해 볼 부분도 더 많았고 어려웠다.특히 이번 주에는 커리어코칭도 같이 시작되어 이에대한 과제도 추가되어 더 바쁘게 흘러간 것 같다.</p>
<p>이번 주는 개인적으로 아쉬운 점 보다 좋았던 점이 많았던 일주일이였던것 같아 만족스럽다. 그렇다고 해도 아쉬운 점이 없던 것은 아니니 이 부분들에 대해 얘기해보고자 한다.</p>
<h1 id="원티드-프리온보딩-프론트엔드-인턴십-2주차-과제"><a href="#원티드-프리온보딩-프론트엔드-인턴십-2주차-과제" class="headerlink" title="원티드 프리온보딩 프론트엔드 인턴십 2주차 과제"></a>원티드 프리온보딩 프론트엔드 인턴십 2주차 과제</h1><h2 id="2023-05-02-과제-발표"><a href="#2023-05-02-과제-발표" class="headerlink" title="2023.05.02 - 과제 발표"></a>2023.05.02 - 과제 발표</h2><p>화요일 5시 <code>React Hook의 심층 활용</code>을 주제로 한 세션이 끝나고 과제의 내용이 발표되었다. 기업과제라 자세한 내용은 서술하기 어렵지만 간단히 정리해 <code>캐싱에 중점을 둔 검색창의 검색어 추천기능 구현</code>을 각자 수행하고, 저번주처럼 팀 별 Best Pratice를 만들고 제출하는 과제였다.</p>
<p>저번주와는 다르게 일단 각자가 과제를 수행하고 그 후에 Best Pratice에 대한 의견을 나누어야 하기에 시간이 너무 촉박할 것 같았다.<br>시간을 절약하기 위해 일단은 목요일 오전까지 최대한 빠르게 각자 과제를 수행하고, 그 과정에서 중요하게 여겼던 점이나 중요할 것 같은 부분들을 적어 오기로 했다.</p>
<h2 id="2023-05-02-2023-05-04-개인-과제-수행"><a href="#2023-05-02-2023-05-04-개인-과제-수행" class="headerlink" title="2023.05.02 ~ 2023.05.04 - 개인 과제 수행"></a>2023.05.02 ~ 2023.05.04 - 개인 과제 수행</h2><p>과제를 수행하면서 가장 중요한 부분이 캐싱이었다. 캐싱이 어떤 것인지는 알고 있었지만 캐싱 기능을 제공하는 라이브러리들을(react-query, apollo-client) 사용만 해보았지, 실제로 캐싱 기능이 어떻게 구현되어 있는지 몰랐기에 먼저 캐싱에 대한 고민을 해보았다.</p>
<p>캐싱을 구현하기 위해서는 fetch해온 data를 저장할 저장소가 필요했고 사용할 수 있는 저장소에는 로컬스토리지, 세션스토리지, 캐시스토리지 등 다양한 저장소가 존재했다. 이름에서부터 캐시스토리지가 가장 적합할 것 같았고, <code>실제로도 캐싱 기능 구현에 캐시스토리지를 많이 활용한다 하니 캐시스토리지를 사용해야겠다</code> 생각했었다.</p>
<p>그런데 과제의 사용가능한 기술에 필수는 아니지만 Redux가 존재했고, 개인적으로 Redux의 멘탈 모델은 알고있지만 많이 사용해보지 못해 익숙하지 않았고 더욱이 RTK는 사용해본적이 없었기에 <code>Redux를 사용해보며 학습하는 것도 좋겠다</code>라는 생각이 들었다. 또한 아직까지도 Redux를 사용하는 기업이 많기에 Redux 코드에 대한 이해도를 높이는 부수효과를 기대하고 Redux를 사용해보기로 결심했다.</p>
<p>더 자세한 구현사항들은 <a href="https://github.com/rjsej12/wanted-2nd">github</a>를 통해 확인 가능하다.</p>
<h2 id="2023-05-04-개인-과제-수행-후-회의"><a href="#2023-05-04-개인-과제-수행-후-회의" class="headerlink" title="2023.05.04 - 개인 과제 수행 후 회의"></a>2023.05.04 - 개인 과제 수행 후 회의</h2><p>그렇게 각자가 과제를 수행한 후 목요일 낮에 모여 첫 회의를 진행했다.<br>한 사람 씩 자기가 수행한 과제의 주요 부분들에 대한 설명을 하며 왜 그런 방식을 택했는지, 어떤 방법이 더 좋은 방법인지에 대한 의견을 나누었다. (ex. 캐싱을 위한 저장소로 어떤 것을 사용했는지 - 로컬스토리지, 캐시스토리지 etc.)</p>
<p>그렇게 각 기능들에 대한 Best Practice를 정하고 난 후, 모두가 모여서 코드를 작성하기로 했다. 기능 구현의 난이도는 저번보다 높았지만, 코드의 양 자체는 그렇게 많지 않았기 때문이다. 처음에는 상의된 Best Practice에 가장 가깝게 구현한 사람이 코드를 작성하고 있었는데, 중간에 한 팀원분께서 <code>Live Share</code>를 사용해 보자고 의견을 내주셔서 같이 코드를 작성할 수 있었다.</p>
<h2 id="2023-05-04-2023-05-05-버그-픽스-및-DOCS-작업"><a href="#2023-05-04-2023-05-05-버그-픽스-및-DOCS-작업" class="headerlink" title="2023.05.04 ~ 2023.05.05 - 버그 픽스 및 DOCS 작업"></a>2023.05.04 ~ 2023.05.05 - 버그 픽스 및 DOCS 작업</h2><p>같이 모여서 Best Practice대로 코드를 작성하고 난 후, 실제로 결과물이 잘 동작하는지 확인하던 중 오류가 발생했다. 방향키를 이용해 추천 검색어를 오가는 동작에서, 처음 방향키를 눌렀을 때 포커스가 2번 움직였다… 목요일 거의 밤이 다 되어서 발견한 오류였는데, 다들 낮부터 밤까지 너무 오랜 시간을 집중했던지라 쉽게 해결하지 못했고 다음날까지 고민해보기로 했다.</p>
<p>그런데 금요일 새벽 4시경 정도 한 팀원분이 오류의 원인을 찾아 그 해결법을 공유해주셨다. 결론적으로 <code>한글의 Composition</code>이 오류의 원인이였는데 작년에 이미 같은 오류를 겪고 해결했던 적이 있음에도 불구하고 떠올리지 못했다는게 반성해야겠다고 생각했다. 또 한번 기록의 중요성에 대해 느꼈고, 새벽까지 해결하지 못한 문제에 대해 탐구하는 팀원분의 자세를 보고 나도 더 몰입하는 자세를 가져야겠다고 다짐했다.</p>
<p>그 후 금요일 인턴십 세션이 끝난 후 다시 모여 오류 수정에 대한 얘기를 나누고 README.md를 작성하는 시간을 가졌다. 이번에는 많은 팀원분들이 미리 과제를 수행하면서 고민했던 점이나 트러블 슈팅에 관한 부분들을 미리 적어오셔서 더 알찬 README.md를 완성 할 수 있었다.</p>
<p>자세한 내용에 대해서는 <a href="https://github.com/WANTED-TEAM03/pre-onboarding-10th-2-3">README.md</a>에서 살펴 볼 수 있다.</p>
<h2 id="KPT"><a href="#KPT" class="headerlink" title="KPT"></a>KPT</h2><p>이번 주 역시 많은 것을 생각해 볼 수 있어 좋았다. 특히 평소 그 원리를 알지 못하고 라이브러리를 이용해 구현하던 캐싱에 대해 자세히 알 수 있었고, 개발자로서 성장하기 위해 어떠한 자세를 가져야 할 지 다시 한 번 생각해 보았던 개인적으로 보람찬 일주일이 된 것 같다.</p>
<h3 id="Keep"><a href="#Keep" class="headerlink" title="Keep"></a>Keep</h3><ul>
<li><p>이번 주 역시 만족스러운 README.md 및 기록을 남길 수 있었다! 특히 저번주보다 팀원분들이 적극적으로 참여해 주셨는데, 조금 더 친밀해져서 였을까? 남은 기간동안 더 돈독한 사이가 되어 팀명대로 보람찬 3조가 되면 좋겠다.</p>
</li>
<li><p>Live Share 기능을 사용해 같이 코드를 작성해보니 시간을 효율적으로 사용 할 수 있었고, 화면 공유보다 더 코드를 잘 이해할 수 있었던 것 같다. 다음 협업에서도 이 기능을 잘 사용해야겠다.</p>
</li>
</ul>
<h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><ul>
<li>알고 있던 문제였음에도 스스로 해결하지 못한 점이 너무 아쉽다. 해결했다고 해서 대충 머릿속에 남기는 것이 아니라 꼭 기록을 통해 새겨놔야 겠다고 느꼈다. 기록하는것이 귀찮기는 하지만 내 스스로의 성장에 도움이 되는것이니 만큼 성실히 기록해보자!</li>
</ul>
<h3 id="Try"><a href="#Try" class="headerlink" title="Try"></a>Try</h3><ul>
<li>더 열심히 하자! - 이번 기업 과제의 경우 멘토님께서 보통 7시간 정도 기한을 주는 과제라고 하셨었는데 과연 내가 7시간안에 합격할 정도의 결과물을 만들어 낼 수 있었을까 생각해보면 아니라고 답할 수 밖에 없을 것 같다. 아직은 많이 부족한 만큼 더 열심히 생각하고 공부해 실력을 늘려봐야지!</li>
</ul>
]]></content>
      <tags>
        <tag>회고</tag>
      </tags>
  </entry>
  <entry>
    <title>정규식 Test Method에 대해 새롭게 알게된 점</title>
    <url>/2023/New-things-I-learned-about-the-regExp-test-method/</url>
    <content><![CDATA[<h1 id="😱-문제발생"><a href="#😱-문제발생" class="headerlink" title="😱 문제발생"></a>😱 문제발생</h1><p>원티드 프리온보딩 프론트엔드 인턴십에 참여하여 1주차 과제를 진행하던 중이었다.<br>1주차 과제는 인턴십에 참여하기 위해 수행했던 사전과제를 동료학습을 통해 리팩토링 하는 것이였고, 나는 팀원들과의 토의로 얻은 Best Practice의 기준을 가지고 Assignment1의 기능 구현을 맡아 코드를 작성하고 있었다.</p>
<ul>
<li>Assignment 1<ul>
<li>회원가입과 로그인 페이지에 이메일과 비밀번호의 유효성 검사기능을 구현해주세요<ul>
<li>이메일 조건: @ 포함, 비밀번호 조건: 8자 이상</li>
</ul>
</li>
<li>입력된 이메일과 비밀번호가 유효성 검사를 통과하지 못한다면 button에 disabled 속성을 부여해주세요</li>
</ul>
</li>
</ul>
<p>Assignment 1의 유효성 검증을 구현하기 위해 정규식을 이용하는게 좋을 것 같다라는 의견을 수용해, <code>password: /^.&#123;8,&#125;$/g</code>의 정규식을 통해 코드를 작성하고 정상적으로 동작하는지 확인을 하는데 갑자기 다음과 같은 문제가 발생했다.</p>
<p><img src="/../images/reg-test-problem.gif" alt="문제"></p>
<p>8자리의 비밀번호를 입력했을때 error message가 정상적으로 사라지길래 검증이 잘 되는구나 생각했는데, 추가적으로 비밀번호를 입력할때 마다 error message가 생겼다 없어졌다 하는 것이다. 즉 비밀번호를 입력할때마다 정규식으로 검증한 결과가 바뀐다는 것이였는데, 혹시나해서 정규식으로 검증한 결과를 개발자 도구를 통해 살펴보았다.</p>
<p><img src="/../images/reg-test-console.png" alt="개발자도구로 찍어본 정규식 테스트"></p>
<p>같은 정규식으로 같은 값을 검사했는데도 그 결과가 계속해서 바뀌는 현상이 일어났는데, 아무리 생각해도 이해가 되지 않아 ChatGPT를 통해 질문을 해 본 결과 다음과 같은 답을 받을 수 있었다.</p>
<p><img src="/../images/reg-test-gpt.png" alt="ChatGPT 답변"></p>
<h1 id="😊-문제해결"><a href="#😊-문제해결" class="headerlink" title="😊 문제해결"></a>😊 문제해결</h1><p>ChatGPT 답변을 바탕으로 조금 더 이해를 위해 검색을 해보니 <code>RegExp.prototype.test()</code>의 대한 MDN 문서에서 <code>전역 플래그와 test()</code>라는 항목으로 예시를 들어주며 설명을 해주고 있어 왜 이런 현상이 발생했는지 알 수 있었다.</p>
<p>정규 표현식에 전역 플래그를 설정한 경우, <code>test()</code> 메서드는 정규 표현식의 <code>lastIndex</code>를 업데이트하고 <code>test()</code>을 다시 호출하면 str 검색을 <code>lastIndex</code>부터 계속 진행하는데, <code>lastIndex</code> 속성은 <code>test()</code>가 true를 반환할 때마다 증가하고 test()가 false를 반환할 땐 0으로 초기화되어 결과가 계속해서 바뀌던 것이였다.</p>
<p><code>exec()</code> 메서드도 <code>test()</code> 메서드처럼 전역 탐색 플래그를 제공한 정규 표현식에서 여러 번 호출하면 이전 일치 이후부터 탐색한다고 하니 정규식을 사용할 때 주의해야 할 것 같다.</p>
<p>정규식이 정말 유용한것은 알지만 항상 어렵게 느껴지는 것 같다. 그래도 이렇게 정규식에 대해 알아볼 기회가 있을 때 마다 잘 정리해서 능숙해지려고 노력해야겠다!</p>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test</a></li>
</ul>
]]></content>
      <tags>
        <tag>정규식</tag>
      </tags>
  </entry>
  <entry>
    <title>원티드 프리온보딩 프론트엔드 인턴십 4주차 회고</title>
    <url>/2023/Retrospect-About-4th-Week-Of-Wanted-Pre-Onboarding-Frontend-InternShip/</url>
    <content><![CDATA[<p><img src="/../images/wanted-preonboarding.jpeg" alt="원티드 프리온보딩 프론트엔드 인턴십"></p>
<h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>원티드 프리온보딩 프론트엔드 인턴십의 4주차가 지나갔다. 정말 한달이 순식간에 지나간 것 같다.</p>
<p>저번주에는 과제가 없어 약간의 휴식과 더불어 기술면접 스터디를 준비하느라 따로 회고를 작성하지는 않았지만 이번주에는 과제, 이력서 작성등 겪은 일이 많아 회고가 필요할 것 같다.</p>
<h1 id="원티드-프리온보딩-프론트엔드-인턴십-4주차-과제"><a href="#원티드-프리온보딩-프론트엔드-인턴십-4주차-과제" class="headerlink" title="원티드 프리온보딩 프론트엔드 인턴십 4주차 과제"></a>원티드 프리온보딩 프론트엔드 인턴십 4주차 과제</h1><h2 id="2023-05-14-과제-발표"><a href="#2023-05-14-과제-발표" class="headerlink" title="2023.05.14 - 과제 발표"></a>2023.05.14 - 과제 발표</h2><p>지난번 까지는 화요일 세션이 끝난 후 과제가 발표되어 금요일 자정까지 제출해야 했다면, 이번 주는 마지막 주다 보니 과제 피드백을 위해 일요일 낮 12시에 과제가 발표되어 수요일 자정까지 제출해야 했다. 그런데 월요일에는 커리어 코칭 세션, 기술면접 스터디가 있었고 화요일에는 인턴십 세션이 있었기 때문에 과제를 수행할 시간이 너무 촉박한것 아닌가 생각했다.(사실 매번 시간이 부족하다고 느낀것 같다).</p>
<p>다행히(?) 발표된 과제 내용을 확인해 보니 2주차 과제와 구현해야 하는 기능이 겹치는 부분이 존재해 생각보다 수월하게 진행할 수 있지 않을까 생각했다. 2주차와 마찬가지로 화요일 저녁까지 각자 과제를 수행해 오기로 했다. 특히 과제 평가 요소에 문서화가 포함되어 있어 각자의 과제 수행 내용에 대해 미리미리 기록을 해두기로 했다.</p>
<h2 id="2023-05-14-2023-05-16-개인-과제-수행"><a href="#2023-05-14-2023-05-16-개인-과제-수행" class="headerlink" title="2023.05.14 ~ 2023.05.16 - 개인 과제 수행"></a>2023.05.14 ~ 2023.05.16 - 개인 과제 수행</h2><p>4주차 과제는 제공된 기존 코드의 리팩토링 + 검색어 추천 기능 + 무한스크롤을 구현해야 했다. 검색어 추천 기능은 2주차 과제에서 진행한 적이 있어 어렵지 않을거라 생각했지만, api를 통해 받아오는 데이터의 형태가 달라 필요한대로 가공하는 작업이 필요했다.</p>
<p>무한스크롤은 스크롤 이벤트 혹은 Intersection Observer API를 이용해 구현할 수 있었는데, 여러 장점이 존재하는 Intersection Observer API를 이용했다.</p>
<p>기능 구현은 생각보다 수월하게 진행했지만 코드를 볼 때마다 더 좋은 방향성이 생각나 리팩토링 하는데 시간이 오래 걸렸다. 결국 개인적으로 과제를 수행하는 시간이 다 지났음에도 원하는 만큼 리팩토링을 진행하지 못해 아쉬움이 남았다.</p>
<p>더 자세한 구현사항들은 <a href="https://github.com/rjsej12/wanted-4th">GitHub</a>의 Issue, PR을 통해 확인 가능하다.</p>
<h2 id="2023-05-16-개인-과제-수행-후-회의"><a href="#2023-05-16-개인-과제-수행-후-회의" class="headerlink" title="2023.05.16 - 개인 과제 수행 후 회의"></a>2023.05.16 - 개인 과제 수행 후 회의</h2><p>그렇게 각자가 과제를 수행한 후 화요일 저녁에 모여 첫 회의를 진행했다.<br>한 사람 씩 어떻게 기능을 구현했는지, 어떤 항목을 리팩토링 했는지 설명했다. 문서화 항목을 대비해 미리 내용들을 구체적으로 적어오셔서 수월하게 의견을 공유할 수 있었다.</p>
<p>다만 기존 코드를 리팩토링 해서 그런건지 결과물이 다양해 합치는 과정이 어렵다고 느꼈다. 그래서 Best Practice로 평가된 항목들 (Intersection Oberserver API의 사용, 검색어 구현을 custom hook으로 분리 etc)이 제일 많이 적용된 내 코드를 기준으로 추가 항목들을 합치기로 했다.</p>
<h2 id="2023-05-17-추가-리팩토링"><a href="#2023-05-17-추가-리팩토링" class="headerlink" title="2023.05.17 - 추가 리팩토링"></a>2023.05.17 - 추가 리팩토링</h2><p>그렇게 결과물을 합친 후 전체적으로 코드를 살펴보며 추가적으로 리팩토링 할 만한 부분들을 살펴보았다.</p>
<p>비슷한 로직이 중복적으로 사용되고 있어 제거했고, 사용성을 생각해 드롭다운의 구조를 변경했다. 또 디자인 시안에 맞게 디테일한 스타일링도 수정했다.</p>
<p>더 자세한 내용에 대해서는 <a href="https://github.com/WANTED-TEAM03/pre-onboarding-10th-4-3">README.md</a>에서 살펴 볼 수 있다.</p>
<h2 id="KPT"><a href="#KPT" class="headerlink" title="KPT"></a>KPT</h2><p>마지막 과제인 만큼 오랜만에 밤도 새워가면서 열심히 집중했다. 그런데도 시간이 부족해 원하는 만큼의 결과물은 얻어내지 못한 것 같다. 인턴십을 처음 시작했을 때와 비교해보면 정말 많이 늘었는데, 오히려 그럴수록 부족한 부분이 많이 보이는것 같다. 더 노력해야지!</p>
<h3 id="Keep"><a href="#Keep" class="headerlink" title="Keep"></a>Keep</h3><ul>
<li><p>이번 주 역시 만족스러운 README.md 및 기록을 남길 수 있었다! PR과 Issue 생성 시에 미리 기록을 자세하게 해두니 훨씬 수월하게 문서 작업을 할 수 있었다.</p>
</li>
<li><p>Best Practice가 많이 적용된 결과물로 나의 과제가 뽑혔다. 1주차에는 Best Practice를 만족시킨 부분이 정말 적었는데 노력한 결과가 그래도 드러나는 것 같아 뿌듯하다. 앞으로도 열심히 해야지.</p>
</li>
</ul>
<h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><ul>
<li>과제의 평가 항목에 테스트 코드 작성이 존재했다. 테스트 코드를 작성한 경험이 없기도 하고 아직 Jest의 사용법도 잘 알지 못해 테스트 코드는 다른 팀원분께서 작성하셨는데, TDD를 적용해 개발하는 회사도 많은 만큼 꼭 테스트 코드에 대한 공부가 필요할 것 같다.</li>
</ul>
<h3 id="Try"><a href="#Try" class="headerlink" title="Try"></a>Try</h3><ul>
<li>취업까지 화이팅! - 인턴십에 참가한 목적은 성장도 있지만 취업을 위해서였다. 인턴십을 잘 수료했다고 끝이 아닌만큼, 취직까지 더 노력하자. 기술면접, 이력서, 포트폴리오 아직 준비할게 많다… 그래도 화이팅!</li>
</ul>
]]></content>
      <tags>
        <tag>회고</tag>
      </tags>
  </entry>
  <entry>
    <title>새로운 컴퓨터로 Hexo 블로그 옮기기</title>
    <url>/2023/Transfer-hexo-blog-to-new-device/</url>
    <content><![CDATA[<p>나는 이 블로그를 Hexo라는 프레임워크를 이용해 작년 8월에 만들었었고 나름대로 계속해서 포스팅을 하고 있었다. 그러다 1월 말에 원래 사용하던 Windows 갤럭시북에서 MacOs의 맥북 M1으로 갈아타게 되었는데 깃허브에서 repository를 clone하고 hexo 명령어를 입력해도 작동하지 않는 문제가 생겼다.</p>
<p>처음부터 블로그를 다시 세팅해야하나 아니면 다른 플랫폼으로 이사를 갈까 고민하며 해결방법을 찾던 중 다음 글을 발견했다. <a href="https://jqxiao.tech/2020/07/17/Transfer-Hexo-Blog-to-New-Device/">Transfer Hexo Blog to New Device</a></p>
<p>위 블로그 게시글의 내용을 따라 수행하니 맥북에서도 다시 블로그 포스팅을 진행할 수 있게 되었고, 혹시라도 다음에 또 컴퓨터를 바꿀 수 있으니 방법을 정리해두어야겠다고 마음먹었다.</p>
<h1 id="새로운-branch-만들기"><a href="#새로운-branch-만들기" class="headerlink" title="새로운 branch 만들기"></a>새로운 branch 만들기</h1><ul>
<li>hexo blog repository를 git clone 한다.</li>
<li>clone한 repositroy에서 <code>git checkout -b branch명</code>로 새로운 branch를 만든다.</li>
<li>새로운 branch에서 .git 폴더를 제외한 모든 파일들을 삭제한다.</li>
<li>원래 사용하던 기기의 hexo blog 폴더를 복사해온다.</li>
<li>이전 기기의 .git 관련 폴더들은 삭제한다.</li>
<li>새로운 branch를 Github에 push한다.</li>
</ul>
<h1 id="새-기기에-Hexo-설치하기"><a href="#새-기기에-Hexo-설치하기" class="headerlink" title="새 기기에 Hexo 설치하기"></a>새 기기에 Hexo 설치하기</h1><ul>
<li><code>npm install hexo --save</code>로 Hexo를 설치한다.</li>
<li><code>npm install hexo-deployer-git --save</code>로 git deployer plugin를 설치한다.</li>
</ul>
<h1 id="블로그-Deploy하기"><a href="#블로그-Deploy하기" class="headerlink" title="블로그 Deploy하기"></a>블로그 Deploy하기</h1><ul>
<li>새로 만든 branch에 .gitigonre 파일을 추가한다.</li>
<li>.gitignore 파일에 <code>.deploy_git/*</code>과 <code>public/*</code>을 추가한다</li>
<li><code>hexo clean</code>을 통해 이전 웹페이지를 삭제한다.</li>
<li><code>hexo generate</code>와 <code>hexo deploy</code>로 새로운 웹페이지를 만들 수 있다.</li>
</ul>
<h1 id="무엇이-문제였을까"><a href="#무엇이-문제였을까" class="headerlink" title="무엇이 문제였을까?"></a>무엇이 문제였을까?</h1><p>hexo deploy시 만들어진 정적 웹페이지가 자동으로 Github의 default branch에 push되었던 것이지 hexo를 설치했던 기존 폴더 자체를 Github에 push한것은 아니었기 때문에 git clone을 해도 hexo 명령어가 작동하지 않았다.<br>따라서 새로운 branch에 원본 기기의 폴더를 복사해옴으써 문제를 해결할 수 있었다.</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>5월 4주차 회고</title>
    <url>/2023/Retrospect-About-4th-Week-Of-May/</url>
    <content><![CDATA[<p>벌써 5월이 끝나가고 있다. 작년 8월 대학교를 졸업한 후 개발 공부를 시작했으니 약 10개월 정도가 지났는데 새삼 느끼는 것이지만 시간 참 빠르다😱</p>
<p>지난 10개월간 열심히 했는지를 스스로 물어본다면 ‘물론 열심히 했지!’라고 답할 테지만 정말 그게 최선이었냐고 물어본다면 당장 올해 2~3월도 그렇고 중간중간 분명히 나태하게 보낸 시간이 있었기에 아니라고 답해야 할 것 같다. 시간이 정말 소중한데 그 시간을 낭비한 적이 있다는 게 너무 아쉽다. 특히 본격적으로 취준생활을 시작한 요새 아쉬움을 더 느끼는 중이다.</p>
<p>이번 주부터 커리어 코칭을 통해 피드백 받은 이력서, 포트폴리오를 가지고 본격적으로 구직활동을 시작했다. 주로 원티드 플랫폼을 활용해 여러 회사에 지원하고 있는데… 참 요새 ‘시장 상황이 좋지 않다, 개발자 취업난이다’라고 왜 얘기하는지 체감하고 있다. 50개의 기업에 지원했는데 (<del>물론 아직 이력서를 열람하지 않은 회사도 있지만</del>) 알림을 받을 때마다 불합격을 받으니 자존감이 깎여나간다. 이미 다른 지원자가 구해져서 일수도 있지만 서류 열람 1분 만에 불합격을 주는 회사도 있고.. 정확한 이유를 알 수 없으니 내가 많이 부족한가? 비전공자라 그런가? 자책하게 된다.</p>
<p>그래도 합격률이 10%도 안되기는 하지만 서류가 통과되어 면접 일정을 잡는 회사도 하나 둘 생기고 있다. 면접을 잘하는 것은 별개의 이야기니 만큼 열심히 준비해 봐야지! 사실 어쨌든 단 하나의 회사라도 합격하면 그만인거니까😀</p>
]]></content>
      <tags>
        <tag>회고</tag>
      </tags>
  </entry>
  <entry>
    <title>Sass Basic</title>
    <url>/2022/Sass-Basic/</url>
    <content><![CDATA[<h1 id="Sass"><a href="#Sass" class="headerlink" title="Sass?"></a>Sass?</h1><p>CSS를 사용해 웹 애플리케이션 스타일을 관리하는 것은 애플리케이션 규모가 커지고 복잡해질수록 매우 어렵다.</p>
<p>반면 Sass와 같은 프리프로세서(Pre-Processor, 전처리기)를 사용하면 매우 효과적으로 복잡한 애플리케이션 스타일을 관리할 수 있다.</p>
<p>Sass란 Syntactically Awesome Style Sheets의 준말로 CSS가 아직은 할 수 없는 다양한 기능(중첩, 함수, 믹스인, 상속 등)을 제공한다.</p>
<p>Sass말고도 Stylus, Less와 같은 전처리기가 존재하지만 현재 Sass가 통계상 가장 사용자가 많으면서 만족도가 높아 배웠을 때 가장 유용하다고 할 수 있다. (<a href="https://2021.stateofcss.com/ko-KR/technologies/#scatterplot_overview">설문결과</a>)</p>
<hr>

<h2 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h2><p>Sass를 이용하기 위해선 먼저 설치를 해야한다. <a href="https://sass-lang.com/install">공식사이트</a>를 참고해 다양한 방식으로 설치가 가능하다. 나는 Node.js를 이용하고 있기에 npm을 통해 설치해 주었다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g sass</span><br></pre></td></tr></table></figure>

<h2 id="컴파일"><a href="#컴파일" class="headerlink" title="컴파일"></a>컴파일</h2><p>Sass를 설치해 이용하고자 할 때, 웹 브라우저는 Sass파일을 해석할 수 없기에 Sass파일을 CSS파일로 변경해야 한다. 이를 컴파일이라 하는데 다음과 같이 사용 가능하다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sass input.scss output.css</span><br></pre></td></tr></table></figure>

<p>단일 파일이 아니라 폴더 단위의 변경을 처리한다면 <code>:</code>을 이용할 수 있다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sass src/scss:public/css</span><br></pre></td></tr></table></figure>

<p>더 많은 옵션은 <a href="https://sass-lang.com/documentation/cli/dart-sass">Dart Sass CLI</a>를 참고할 수 있다.</p>
<hr>

<h2 id="문법"><a href="#문법" class="headerlink" title="문법"></a>문법</h2><p>Sass파일은 사용하는 문법에 따라 <code>.scss</code>의 확장자를 가진 SCSS 구문과 <code>.sass</code>를 가진 Sass구문 2가지로 나뉜다.</p>
<h3 id="Sass-구문"><a href="#Sass-구문" class="headerlink" title="Sass 구문"></a>Sass 구문</h3><p>Sass 구문은 중괄호, 세미콜론을 생략하고 들여쓰기 문법을 사용한다. 좀 더 간결하고 작성하기 편리하며 <code>&#123;&#125;</code>나 <code>;</code>를 사용하지 않아도 되어 코드가 깔끔하다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.button</span><br><span class="line">	cursor: pointer</span><br><span class="line">	&amp;:disabled</span><br><span class="line">		cursor: not-allowed</span><br></pre></td></tr></table></figure>

<h3 id="SCSS-구문"><a href="#SCSS-구문" class="headerlink" title="SCSS 구문"></a>SCSS 구문</h3><p>SCSS 구문은 CSS와 유사한 문법을 사용한다. 인라인 코드를 작성할 수 있고, CSS와 유사한 문법을 가지기 때문에 코드 통합이 훨씬 쉽다.</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">	<span class="attribute">cursor</span>: pointer;</span><br><span class="line">	&amp;<span class="selector-pseudo">:disabled</span> &#123;</span><br><span class="line">		<span class="attribute">cursor</span>: not-allowed;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>서로 장단점이 있기 때문에 회사나 팀에서 원하는 방식 혹은 개인의 취향에 따라서 선택할 수 있다. 일반적으로 CSS 구문과 문제없이 호환되는 SCSS구문이 많이 사용된다.</p>
<hr>

<h2 id="Sass-Basics"><a href="#Sass-Basics" class="headerlink" title="Sass Basics"></a>Sass Basics</h2><p>수업을 들으면서 Sass의 두 가지 구문중 SCSS를 사용했기에 Sass Basics에 대해 SCSS를 이용한 방법으로 정리하겠다.</p>
<h3 id="변수-Variables"><a href="#변수-Variables" class="headerlink" title="변수(Variables)"></a>변수(Variables)</h3><p>CSS도 변수 사용이 가능하지만 Sass에서는 <code>$</code>를 이용해 더 쉽게 변수를 사용할 수 있다.</p>
<p><strong>CSS 변수</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">	<span class="attr">--spacing-1</span>: <span class="number">4px</span>;</span><br><span class="line">	<span class="attr">--spacing-2</span>: <span class="number">8px</span>;</span><br><span class="line">	<span class="attr">--primary-400</span>: <span class="built_in">hsl</span>(<span class="number">250</span>, <span class="number">75%</span>, <span class="number">60%</span>);</span><br><span class="line">	<span class="attr">--primary-500</span>: <span class="built_in">hsl</span>(<span class="number">250</span>, <span class="number">75%</span>, <span class="number">50%</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">	<span class="attribute">margin-top</span>: <span class="built_in">var</span>(--spacing-<span class="number">2</span>);</span><br><span class="line">	<span class="attribute">color</span>: <span class="built_in">var</span>(--primary-<span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SCSS 변수</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$spacing-1</span>: <span class="number">4px</span>;</span><br><span class="line"><span class="variable">$spacing-2</span>: <span class="number">8px</span>;</span><br><span class="line"><span class="variable">$primary-400</span>: <span class="built_in">hsl</span>(<span class="number">250</span>, <span class="number">75%</span>, <span class="number">60%</span>);</span><br><span class="line"><span class="variable">$primary-500</span>: <span class="built_in">hsl</span>(<span class="number">250</span>, <span class="number">75%</span>, <span class="number">50%</span>);</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">	<span class="attribute">margin-top</span>: <span class="variable">$spacing-2</span>;</span><br><span class="line">	<span class="attribute">color</span>: <span class="variable">$primary-500</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="중첩-Nesting"><a href="#중첩-Nesting" class="headerlink" title="중첩(Nesting)"></a>중첩(Nesting)</h3><p>CSS는 HTML과 달리 시각적인 계층 구조와 명확히 중첩된 구문을 작성할 수 없다. 하지만 Sass는 HTML과 동일하게 시각적 계층 구조를 따르는 방식으로 스타일을 작성하는 방법을 지원한다.</p>
<p><strong>CSS 구문</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: block;</span><br><span class="line">	<span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">12px</span>;</span><br><span class="line">	<span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SCSS 구문</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">	<span class="selector-tag">ul</span> &#123;</span><br><span class="line">		<span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">		<span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">		<span class="attribute">list-style</span>: none;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="selector-tag">li</span> &#123;</span><br><span class="line">		<span class="attribute">display</span>: inline-block;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="selector-tag">a</span> &#123;</span><br><span class="line">		<span class="attribute">display</span>: block;</span><br><span class="line">		<span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">12px</span>;</span><br><span class="line">		<span class="attribute">text-decoration</span>: none;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sass 중첩 구문은 시각적으로 계층 구조를 파악할 수 있어 CSS 보다 직관성이 높다. 하지만 많은 중첩은 오히려 복잡성을 증가시켜 가독성이 떨어지므로 피해야한다.</p>
<h3 id="모듈-modules"><a href="#모듈-modules" class="headerlink" title="모듈(modules)"></a>모듈(modules)</h3><p>모듈은 독립적으로 묶인 작은 코드 조각으로, Sass는 관심사에 따라 여러 조각의 코드로 묶인 파일을 관리할 수 있는 기능인 모듈화를 제공한다. 모듈은 애플리케이션 스타일을 유지 관리하기 쉽게 만들어 주는 매우 효과적인 방법이다.</p>
<p>Sass(정확히는 Dart Sass)에서는 <code>@import rule</code>대신 <code>@use</code>를 이용해 다른 스타일 모듈을 불러올 수 있다. Sass 파일 확장자와 언더스코어(_)는 생략 가능하다.</p>
<p><strong>_base.scss</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$font-stack</span>: Helvetica, sans-serif;</span><br><span class="line"><span class="variable">$primary-color</span>: <span class="number">#333</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">	<span class="attribute">font</span>: <span class="number">100%</span> <span class="variable">$font-stack</span>;</span><br><span class="line">	<span class="attribute">color</span>: <span class="variable">$primary-color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>불러온 모듈은 기본적으로 파일 이름을 네임스페이스(namespace)로 가지며 점(.) 문법을 사용해 모듈의 변수 등에 접근할 수 있다.</p>
<p><strong>styles.scss</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@use</span> <span class="string">&#x27;base&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inverse</span> &#123;</span><br><span class="line">	<span class="attribute">background-color</span>: base.<span class="variable">$primary-color</span>;</span><br><span class="line">	<span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>네임스페이스 이름을 다른 이름으로 변경해 사용하고자 할 경우 as를 사용한다. 특히 as에 별(*) 기호를 사용할 경우 네임스페이스 없이 바로 모듈에서 내보낸 변수를 사용할 수 있다.</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@use</span> <span class="string">&#x27;base&#x27;</span> as *;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inverse</span> &#123;</span><br><span class="line">	<span class="attribute">background-color</span>: <span class="variable">$primary-color</span>;</span><br><span class="line">	<span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CSS</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">	<span class="attribute">font</span>: <span class="number">100%</span> Helvetica, sans-serif;</span><br><span class="line">	<span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inverse</span> &#123;</span><br><span class="line">	<span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">	<span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="믹스인-mixins"><a href="#믹스인-mixins" class="headerlink" title="믹스인(mixins)"></a>믹스인(mixins)</h3><p>CSS는 코드를 재사용 할 수 있는 기능이 제공되지 않기 때문에 코드 중복이 잦은 언어이다. 하지만 Sass는 코드를 효율적으로 재사용할 수 있도록 믹스인 기능을 제공한다. 믹스인을 이용해 재사용할 코드 그룹을 선언할 수 있다.</p>
<p><strong>SCSS</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> theme(<span class="variable">$theme</span>: DarkGray) &#123;</span><br><span class="line">	<span class="attribute">background</span>: <span class="variable">$theme</span>;</span><br><span class="line">	<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> <span class="built_in">rgba</span>(<span class="variable">$theme</span>, <span class="number">0.25</span>);</span><br><span class="line">	<span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.info</span> &#123;</span><br><span class="line">	<span class="keyword">@include</span> theme;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.alert</span> &#123;</span><br><span class="line">	<span class="keyword">@include</span> theme(<span class="variable">$theme</span>: DarkRed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.success</span> &#123;</span><br><span class="line">	<span class="keyword">@include</span> theme(<span class="variable">$theme</span>: DarkGreen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CSS</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.info</span> &#123;</span><br><span class="line">	<span class="attribute">background</span>: DarkGray;</span><br><span class="line">	<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> <span class="built_in">rgba</span>(<span class="number">169</span>, <span class="number">169</span>, <span class="number">169</span>, <span class="number">0.25</span>);</span><br><span class="line">	<span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.alert</span> &#123;</span><br><span class="line">	<span class="attribute">background</span>: DarkRed;</span><br><span class="line">	<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> <span class="built_in">rgba</span>(<span class="number">139</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.25</span>);</span><br><span class="line">	<span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.success</span> &#123;</span><br><span class="line">	<span class="attribute">background</span>: DarkGreen;</span><br><span class="line">	<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="number">0.25</span>);</span><br><span class="line">	<span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@mixin</code>과 이름을 통해 믹스인을 만들 수 있다. 믹스인을 만든 후에는 <code>@include</code>와 이름을 선언해 믹스인을 이용 할 수 있다. 또한 믹스인은 JavaScript 함수처럼 매개변수를 설정할 수 있는데, 매개변수를 사용하면 믹스인 외부에서 사용자가 전달한 값을 믹스인 내부에서 사용해 재사용성을 더 높여줄 수 있다.</p>
<h3 id="확장-x2F-상속-extend-x2F-inheritance"><a href="#확장-x2F-상속-extend-x2F-inheritance" class="headerlink" title="확장&#x2F;상속 (extend&#x2F;inheritance)"></a>확장&#x2F;상속 (extend&#x2F;inheritance)</h3><p>선택자 이름 앞에 <code>%</code>를 사용해 선언한 플레이스홀더 클래스는 스타일을 확장할 때만 사용되는 특수한 유형의 클래스로 여러 선택자에서 공유할 수 있다. 스타일 집합을 공유할 때는 <code>@extend</code>를 사용한다.</p>
<p>이 방법은 스타일 코드를 반복 생성하는 믹스인과 달리, 스타일 코드 집합 하나를 재사용하는데 목적을 두고 있어 보다 코드를 깨끗하게 유지하는데 도움이 될 수 있다.</p>
<p><strong>SCSS</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">%message-shared &#123;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">	<span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">	<span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.message</span> &#123;</span><br><span class="line">	<span class="keyword">@extend</span> %message-shared;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.success</span> &#123;</span><br><span class="line">	<span class="keyword">@extend</span> %message-shared;</span><br><span class="line">	<span class="attribute">border-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">	<span class="keyword">@extend</span> %message-shared;</span><br><span class="line">	<span class="attribute">border-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.warning</span> &#123;</span><br><span class="line">	<span class="keyword">@extend</span> %message-shared;</span><br><span class="line">	<span class="attribute">border-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CSS</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.message</span>,</span><br><span class="line"><span class="selector-class">.success</span>,</span><br><span class="line"><span class="selector-class">.error</span>,</span><br><span class="line"><span class="selector-class">.warning</span> &#123;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">	<span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">	<span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.success</span> &#123;</span><br><span class="line">	<span class="attribute">border-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">	<span class="attribute">border-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.warning</span> &#123;</span><br><span class="line">	<span class="attribute">border-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="연산자-operators"><a href="#연산자-operators" class="headerlink" title="연산자 (operators)"></a>연산자 (operators)</h3><p>CSS에서 수학은 매우 유용하다. Sass는 산술연산자(<code>+</code>, <code>-</code>, <code>*</code>, <code>%</code>) 및 수학 함수(예: <code>math.div()</code>)를 제공한다.</p>
<p><strong>SCSS</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@use</span> <span class="string">&#x27;sass:math&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span><span class="selector-attr">[role=<span class="string">&#x27;main&#x27;</span>]</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: math.<span class="built_in">div</span>(<span class="number">600px</span>, <span class="number">960px</span>) * <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">aside</span><span class="selector-attr">[role=<span class="string">&#x27;complementary&#x27;</span>]</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: math.<span class="built_in">div</span>(<span class="number">300px</span>, <span class="number">960px</span>) * <span class="number">100%</span>;</span><br><span class="line">	<span class="attribute">margin-left</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CSS</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span><span class="selector-attr">[role=<span class="string">&#x27;main&#x27;</span>]</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">62.5%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">aside</span><span class="selector-attr">[role=<span class="string">&#x27;complementary&#x27;</span>]</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">31.25%</span>;</span><br><span class="line">	<span class="attribute">margin-left</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>특히 <code>math.div()</code>를 이용하기 위해서는 <code>@use &quot;sass:math&quot;</code>를 이용해 Sass에서 기본으로 제공하는 math 모듈을 불러와야 한다. 이때 as *를 이용해 사용한다면 div 태그와 구분이 가지 않으므로 <code>math.div()</code>의 기본 형태로 사용하는 것이 추천된다.</p>
<hr>

<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li><a href="https://sass-lang.com/guide">https://sass-lang.com/guide</a></li>
<li><a href="https://euid.notion.site/euid/Sass-04a97ad611cc4436a9f09e9ff052b183">https://euid.notion.site/euid/Sass-04a97ad611cc4436a9f09e9ff052b183</a></li>
<li><a href="https://heropy.blog/2018/01/31/sass/">https://heropy.blog/2018/01/31/sass/</a></li>
</ul>
]]></content>
      <tags>
        <tag>Sass</tag>
      </tags>
  </entry>
  <entry>
    <title>첫 프로젝트를 마치고</title>
    <url>/2022/Retrospective-about-my-first-project/</url>
    <content><![CDATA[<h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>약 2주동안 진행했던 프로젝트가 종료되었다. 개발 공부를 시작한지도 얼마 안 되었고 처음으로 해본 프로젝트인지라 2주가 정말 정신없이 지나가버렸다. 배운점도 많았고 아쉬운점도 많았는데 회고를 하며 정리해보려고 한다.</p>
<p>완성된 결과물은 <a href="https://woowahal-6go5.vercel.app/">https://woowahal-6go5.vercel.app/</a> 에서 확인 가능하다.</p>
<hr>

<h1 id="프로젝트-우아할"><a href="#프로젝트-우아할" class="headerlink" title="프로젝트 우아할"></a>프로젝트 우아할</h1><p>이전글에서 언급했듯이 우리 팀은 배달의 민족 앱을 웹 페이지로 클론하기로 했다(그래서 팀명도 <strong>우아할</strong>형제들로 정했다).</p>
<p>개발 기간은 2022-09-19 ~ 2022-09-30로 약 2주 동안 진행되었고, 팀원은 나를 포함해 총 3명이었다.</p>
<p>프로젝트 기간이나 인원에 비해 배달의 민족이 가지고 있는 콘텐츠가 너무 많아 모든 페이지를 클론 할 수는 없었고 배달의 민족에서 배달하기 까지의 주요 프로세스를 메인,카테고리, 리스트, 디테일, 오더, 장바구니, 결과의 7개 페이지로 나누어 구현해 보았다.</p>
<p>나는 그 중 메인페이지와 카테고리 페이지를 주로 담당했다.</p>
<hr>

<h2 id="기술-스택"><a href="#기술-스택" class="headerlink" title="기술 스택"></a>기술 스택</h2><p>페이지를 구현하면서 Figma, Git, npm, HTML, CSS, Sass, JS, Vercel을 이용했다.</p>
<h3 id="Figma"><a href="#Figma" class="headerlink" title="Figma"></a>Figma</h3><p>구현해야 하는 페이지들의 와이어프레임 및 컴포넌트들을 시각적으로 구성해보기 위해 Figma를 이용했다.</p>
<p>페이지에서 주사용되는 컬러를 시스템화해서 플러그인을 통해 변수로 쉽게 추출할 수 있었다.</p>
<p>아직 툴 사용이 미숙해 많은 기능을 활용하지는 못한것 같아 아쉽다</p>
<h3 id="Git-Github"><a href="#Git-Github" class="headerlink" title="Git, Github"></a>Git, Github</h3><p>프로젝트의 버전관리를 위해 Git을 이용했다. Git flow 전략을 모방해 메인을 제외한 develop, subdev, release 3개의 branch를 만들었다.</p>
<p>기본적으로 모든 변경사항을 subdev에 push하였고, merge가 잘 완료되면 log를 추가해 develop으로 옮겼다. 최종적으로 public 폴더만 build해 release에 저장했다.</p>
<h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><p>개발환경 세팅과 최종적인 프로젝트 파일의 최적화를 위해 npm을 이용했다.</p>
<p>rimraf, npm-run-all, live-server, sass는 개발환경 세팅을 위해 webpack, postcss는 최적화를 위해 사용해 보았다.</p>
<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>HTML의 경우 시맨틱 마크업을 제일 중요시 여겼는데 먼저 손으로 페이지의 구조를 설계 한 후 코드로 작성했다. 그 후 코드리뷰를 시간을 가져 팀원들끼리 왜 그렇게 코드를 작성했는지, 구조가 논리적인지 설득하는 시간을 가졌다.</p>
<h3 id="CSS-Sass"><a href="#CSS-Sass" class="headerlink" title="CSS, Sass"></a>CSS, Sass</h3><p>CSS를 효과적으로 사용하기 위해 Sass를 이용했고 이 때 가장 중요시 여긴점은 컨벤션이였다. 기본적으로 BEM 방식을 이용한 Naming과 최대한 구체적인 클래스명을 사용하기로 정했다.</p>
<hr>

<h2 id="KPT"><a href="#KPT" class="headerlink" title="KPT"></a>KPT</h2><h3 id="Keep"><a href="#Keep" class="headerlink" title="Keep"></a>Keep</h3><ul>
<li><p>프로젝트를 시작하기 전 환경설정을 중요시 여기고 이 부분에 대해 많이 논의 했는데 그 결과 git 충돌도 거의 없었고 일어난 충돌도 금방 해결 할 수 있었다.</p>
</li>
<li><p>1차적인 프로젝트 결과물을 가지고 lighthouse 검사를 통해 부족한 부분을 찾고 개선하기 위해 노력했다. 실질적인 성능 향상을 볼 수 있어서 좋았다.</p>
</li>
<li><p>의견충돌이 있을때 그냥 넘어가지 않고 서로를 설득하기 위해 노력했는데 생각에 대한 근거를 찾고 정리해보며 의견을 구체화 시킬 수 있었다.</p>
</li>
</ul>
<h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><ul>
<li><p>Sass 사용의 아쉬움 - Sass 를 사용하기 위해 폴더 구조를 잘 분리한것은 좋았으나 중첩규칙, 변수 이외에는 잘 사용하지 못했다. 특히 중복적으로 사용되는 코드들을 믹스인으로 분리했어야 했는데 그러지 못했다.</p>
</li>
<li><p>미숙했던 초반 소통</p>
</li>
</ul>
<h3 id="Try"><a href="#Try" class="headerlink" title="Try"></a>Try</h3><ul>
<li>문서화의 중요성 - 서로 상의해 결정했던 부분들이나 컴포넌트에 대한 문서들을 남겨 서로 참고할 수 있도록 하자고 말했었지만 실제 프로젝트를 진행하면서 잘 수행되지 못했다. 문서화가 잘 되어 있는 다른 프로젝트 조의 경우 전체적인 프로젝트 상황에 대한 파악이 수월해 보였다. 다음 프로젝트를 진행할 때에는 꼭 문서화에 신경써봐야겠다.</li>
</ul>
<hr>

<h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>첫 프로젝트를 진행하며 많은 것을 배울 수 있어 정말 좋았다. 하지만 역시 머리에 계속해서 남는것은 아쉬운 점들인 것 같다.</p>
<p>평소 배달의 민족을 많이 사용하면서 이런 기능이 있으면 좋겠다고 생각해 오던것이 있다. 나는 결정장애가 심한 편이라 어떤것을 먹을지, 또 메뉴를 정해도 어디서 시킬지 정말 많이 고민한다. 그래서 카테고리만 선택하면 룰렛이 돌아가듯이 랜덤으로 가게와 메뉴가 선택되면 좋겠다고 생각했다.</p>
<p>마침 배달의 민족을 웹으로 구현하기로 결정해서 이 기능도 추가해 보려고 했는데 막상 스스로의 자바스크립트 실력도 너무 부족하고 어떤 데이터베이스를 기반으로 정보를 가져와야 할지 아이디어 역시도 너무 구체적이지 않아 쉽지 않았다.</p>
<p>스스로 많이 부족하다고 느끼는 점이 가장 아쉬웠다.<br>다만 앞으로 3개월 동안 커넥to 과정을 통해 모던 자바스크립트 Deep Dive의 저자이신 이웅모 강사님에게 자바스크립트 강의를 듣게 되었는데, 정말 좋은 기회이니 만큼 열심히 배우고 또 평상시 가지고 있던 아이디어들에 대해서도 구체화해 프로젝트를 리팩토링해봐야 겠다.</p>
]]></content>
      <tags>
        <tag>회고</tag>
      </tags>
  </entry>
  <entry>
    <title>API란 무엇일까?</title>
    <url>/2022/What-is-an-API/</url>
    <content><![CDATA[<p>JavaScript 구현공부를 시작하며 API를 이용하는 일이 많아졌다. API라는 용어에 대해 많이 들어보기도 했고 API가 무엇인지에 대해 대략적으로 알고 있다고 생각했었지만 막상 API에 대해 구체적으로 설명해보려고 하니 표현하기가 어려웠다. 그래서 API에 대해 정리해보면서 정확히 무엇인지 알아보고자 했다.</p>
<hr>

<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>먼저 API의 정의를 알아보았다.</p>
<blockquote>
<p><strong>API</strong>는 Application Programming Inerface의 줄임말로 응용 프로그램에서 사용할 수 있도록 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다.</p>
</blockquote>
<p>다른 부분들은 쉽게 이해가 갔지만 인터페이스가 무엇을 말하는지 모호했다. 그럼 인터페이스는 무엇일까?</p>
<blockquote>
<p><strong>인터페이스(interface)</strong> 는 컴퓨터 시스템끼리 정보를 교환하는 공유 경계를 의미한다. 터치 스크린과 같은 일부 컴퓨터 하드웨어 장치들은 인터페이스를 통해 데이터를 송수신 할 수 있으며, 마우스나 마이크와 같은 장치들은 오직 시스템에 데이터를 전송만 하는 인터페이스를 제공한다.</p>
</blockquote>
<p>쉽게 정리해 인터페이스는 시스템끼리 데이터를 주고받도록 하는 물리적, 가상적인 매개체를 뜻한다.</p>
<p>조금 더 이해하기 쉽게 실생활에서 예를 들어보면 우리가 자판기를 통해 음료수를 사먹는다라고 할 때 실제 자판기가 어떻게 내부적으로 동작하는지는 몰라도 동전이나 지폐를 넣고 원하는 음료 버튼을 눌러 음료수가 나오게하는 과정을 쉽게 수행한다. 이때 동전과 지폐를 넣고 음료 버튼을 클릭하는등 사물과 사물 또는 사물과 인간 간의 의사소통이 가능하도록하는 물리적, 가상적인 매개체를 인터페이스라고 할 수 있다.</p>
<p>즉 API는 응용 프로그램 (우리가 만든 앱과 같은 서비스)에서 운영체제나 프로그래밍 언어가 제공하는 기능(지도, 날씨, 페이기능등)을 제어할 수 있게 만든 매개체라고 볼 수 있다.<br>API 문서에는 개발자가 이러한 요청과 응답을 구성하는 방법에 대한 정보가 들어 있어 API를 사용하기 이전에 API 문서를 통해 API의 사용법을 알 수 있다.</p>
<hr>

<h2 id="API는-어떻게-작동하는가"><a href="#API는-어떻게-작동하는가" class="headerlink" title="API는 어떻게 작동하는가?"></a>API는 어떻게 작동하는가?</h2><blockquote>
<p>API 아키텍처는 일반적으로 클라이언트와 서버 측면에서 설명된다. 요청을 보내는 애플리케이션을 클라이언트라고 하고 응답을 보내는 애플리케이션을 서버라고 한다. 따라서 날씨 예에서 기상청의 날씨 데이터베이스는 서버이고 모바일 앱은 클라이언트이다.</p>
</blockquote>
<p>API가 생성된 시기와 이유에 따라 API는 네 가지 방식으로 작동할 수 있다.</p>
<p>API라는 단어는 1964년부터 등장하기 시작했다. 이때는 하드웨어 독립성을 위해서 많이 사용되어 졌는데, 예를 들어 서로 다른 하드웨어마다 개발자가 일일이 프로그래밍을 하기보단 HAL이라는 하드웨어 추상화 계층을 통해 한번만 display라는 함수를 작성하고 이를 이용해 각기 다른 모니터에 출력을 쉽게 할수 있었고 이것이 API의 시초라고 할 수 있다.</p>
<p>1980년대 중반 Mac OS와 Windows가 등장하면서 그래픽이 좋은 컴퓨터가 등장하기 시작했다. 이런 각각의 운영체제에서 동작하는 어플리케이션을 만들기 위해서 운영체제에서 제공하는 API를 이용했다.</p>
<p>그리고 1990년도 인터넷이 보편적으로 대중화되기 시작하면서 컴퓨터와 컴퓨터 다양한 기기들이 인터넷을 통해서 의사소통을 할 수 있게 되었다. 이때 다양한 기기에서 서버에 있는 데이터를 읽고 쓰기 위해서는 서버에서 제공하는 WEB APIs를 이용해서 처리 할 수 있었다.</p>
<p>네트워크에서 기기들간에 의사소통 해나가는 규격사항을 HTTP(s)라고 부르며 이런 WEB API를 어떻게 디자인해서 만들건지 정의하는 것이 있다. 예전에는 SOAP(Simple Object Access Protocol)이라는 모든 네트워크 요청과 반응을 XML이라는 데이터 포맷에 저장해 주고 받았다면 요즘에는 REST(Representational State Transfer)이 보편적으로 많이 사용된다.</p>
<p>REST는 총 4가지로 구성되어 있는데 새로운 데이터를 만들고(POST, create), 읽고(GET, read), 업데이트하고(PUT, update), 삭제(DELETE, delete)할 수 있다. 예를 들어 GET을 이용해 유저에 대한 정보를 요청하면 서버로부터 유저에 대한 데이터를 JSON이라는 포맷을 통해 받아 올 수 있다. 이처럼 서버에서 제공하는 WEB API를 통해 서버에 있는 데이터를 읽어오거나 업데이트 할 수 있다.</p>
]]></content>
      <tags>
        <tag>용어정리</tag>
      </tags>
  </entry>
  <entry>
    <title>WCAG 2.1 정리</title>
    <url>/2022/WCAG-2-1-organization/</url>
    <content><![CDATA[<h1 id="👀-WCAG"><a href="#👀-WCAG" class="headerlink" title="👀 WCAG?"></a>👀 WCAG?</h1><blockquote>
<ul>
<li>WCAG는 Web Content Accessibility Guideline의 줄임말로 웹 콘텐츠를 접근성 있게 만들기 위한 권장 표준</li>
</ul>
</blockquote>
<ul>
<li>이 표준을 준수함을 통해 시각, 청각, 운동장애 등 광범위한 장애에 대한 접근성 있는 콘텐츠를 만들 수 있음</li>
<li>웹 접근성의 기초를 제공하는 4가지 원칙인 인식의 용이성(Perceivable), 운용의 용이성(Operable), 이해의 용이성(Understandable), 견고성(Robust)에 기반을 두고 있음</li>
<li>원칙을 기반으로 접근성을 위해 어떠한 목표를 달성해야 하는지에 대한 지침과 또 그 지침에 대한 검증가능한 성공기준을 제시하고 있음</li>
<li>성공기준은 최저수준인 level A 부터 최고수준인 level AAA까지 3단계로 나누어짐</li>
</ul>
<hr>

<h1 id="WCAG-2-0-VS-WCAG-2-1"><a href="#WCAG-2-0-VS-WCAG-2-1" class="headerlink" title="WCAG 2.0 VS WCAG 2.1"></a>WCAG 2.0 VS WCAG 2.1</h1><p>WCAG 2.0 이 만들어졌을때는 주로 데스크탑 환경만을 고려했지만 그 후 모바일 산업의 폭발적인 확장으로 모바일 환경을 필수적으로 고려해야하는 상황이 찾아왔다.</p>
<p>WCAG 2.1은 WCAG 2.0의 요구사항들을 상속하면서 추가적으로 인지나 학습장애가 있는 사용자, 저시력자, 모바일 기기를 사용하는데 장애가 있는 사용자의 접근성 지침을 개선하는 데 목표를 두고있다.</p>
<p>즉 WCAG 2.1은 새로운 성공기준, 이를 지원하기 위한 정의, 추가사항을 조직하기 위한 지침, 그리고 준수 절(section)에 대한 몇 가지 사항을 추가하여 WCAG 2.0을 확장한 것이다.</p>
<hr>

<h2 id="1-인식의-용이성-Perceivable"><a href="#1-인식의-용이성-Perceivable" class="headerlink" title="1. 인식의 용이성(Perceivable)"></a>1. 인식의 용이성(Perceivable)</h2><ul>
<li>정보와 사용자 인터페이스 요소는 사용자가 인식할 수 있는 방법으로 제시되어야 한다.</li>
<li>4가지 지침과 그에 대한 29가지 성공기준을 가지고 있다.</li>
</ul>
<h3 id="지침-1-1-대체텍스트"><a href="#지침-1-1-대체텍스트" class="headerlink" title="지침 1.1 대체텍스트"></a>지침 1.1 대체텍스트</h3><ul>
<li><p>텍스트가 아닌 콘텐츠의 경우 목적에 상응하는 대체 텍스트를 제공해야 한다. (ex - img alt속성)</p>
</li>
<li><p>단 시력검사, 받아쓰기와 같은 Test나 특정 감각을 위한 악기연주 등 텍스트만으로 그 내용을 설명하기에 애매한 경우 콘텐츠의 용도만을 기술하는 것도 괜찮다.</p>
</li>
<li><p>텍스트 아닌 콘텐츠가 순수한 장식이거나, 보이지 않는경우 대체텍스트를 제공하지 않는 편이 합리적이다</p>
</li>
</ul>
<h3 id="지침-1-2-시간기반-미디어"><a href="#지침-1-2-시간기반-미디어" class="headerlink" title="지침 1.2 시간기반 미디어"></a>지침 1.2 시간기반 미디어</h3><ul>
<li><p>시간기반 미디어에 대한 대체수단을 제공해야 한다</p>
</li>
<li><p>달성하기 비교적 쉬운 level A 부터 어려운 level AAA 까지 총 9개의 기준을 가지고 있다.</p>
</li>
<li><p>level이 올라갈수록 더 자세하고 많은 정보를 실시간으로 제공하는 것을 기준으로 삼고 있다.</p>
</li>
</ul>
<h3 id="지침-1-3-적응가능"><a href="#지침-1-3-적응가능" class="headerlink" title="지침 1.3 적응가능"></a>지침 1.3 적응가능</h3><ul>
<li><p>콘텐츠가 정보나 구조의 손실 없이 다른 방법들로 표시될 수 있도록 제작되어야 한다.</p>
</li>
<li><p>콘텐츠의 정보, 구조, 관계는 프로그래밍 방식으로 결정되어야 하고 또 콘텐츠가 표시되는 순서가 의미에 영향을 주는 경우 올바른 읽기 순서 역시 프로그래밍 방식으로 결정되어야 한다.</p>
<blockquote>
<p>프로그래밍 방식으로 결정된다는 것은 확대기, 음성 인식 소프트웨어와 같은 보조공학을 포함한 user agent(웹 브라우저)가 개발자 제공 데이터로부터 정보를 추출해 사용자에게 다른 형식으로 제공할 수 있음을 뜻한다 - 대체텍스트의 img alt 속성 처럼</p>
</blockquote>
</li>
<li><p>콘텐츠를 이해하고 작동하기 위해 제공된 지시문은 모양, 색상, 크기, 시각적 위치 등 구성요소의 감각적 특성에 전적으로 의존해서는 안 된다.</p>
</li>
</ul>
<h3 id="지침-1-4-식별-가능"><a href="#지침-1-4-식별-가능" class="headerlink" title="지침 1.4 식별 가능"></a>지침 1.4 식별 가능</h3><ul>
<li><p>색상은 시각적 요소 구별을 위한 유일한 시각적 수단으로만 사용되어서는 안된다.</p>
</li>
<li><p>웹 페이지에 있는 오디오를 컨트롤 할수 있어야 하고, 배경음이 낮거나 없어야한다 - 스크린리더 사용자를 위한 항목으로, 스크린리더 사용자는 청각을 통해 정보를 받아들이기 때문에 다른 오디오나 배경음이 지속된다면 콘텐츠를 이용하는데 불편함을 겪을 수 있음.</p>
</li>
<li><p>텍스트 이미지 보다는 텍스트를 사용해야 하고, 텍스트의 명도대비, 크기 조정등을 통해 가시성을 높여야한다.</p>
</li>
</ul>
<hr>

<p>추가중…</p>
<hr>

<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li><a href="https://www.w3.org/TR/WCAG21/">https://www.w3.org/TR/WCAG21/</a></li>
<li><a href="http://www.kwacc.or.kr/WAI/wcag21/">http://www.kwacc.or.kr/WAI/wcag21/</a></li>
<li><a href="http://www.websoul.co.kr/accessibility/WA_guide21.asp">http://www.websoul.co.kr/accessibility/WA_guide21.asp</a></li>
</ul>
]]></content>
      <tags>
        <tag>WCAG</tag>
      </tags>
  </entry>
  <entry>
    <title>정렬 알고리즘 요약정리</title>
    <url>/2023/Sorting-Algorithm-Summary/</url>
    <content><![CDATA[<h1 id="😂-들어가며"><a href="#😂-들어가며" class="headerlink" title="😂 들어가며"></a>😂 들어가며</h1><p>기술면접을 대비하기 위해 공부를 하던중, 정렬 알고리즘에 관한 질문이 있었는데 쉽게 답변하지 못했다. 분명 코딩테스트 준비를 하면서 여러가지 정렬 알고리즘에 대해 살펴보고 구현해보았었는데 기록으로 남겨두지 않으니 휘발된 것 같다. 이번 기회에 기본적인 정렬 알고리즘들에 대해 정리해보고자 한다.</p>
<h1 id="정렬-알고리즘"><a href="#정렬-알고리즘" class="headerlink" title="정렬 알고리즘?"></a>정렬 알고리즘?</h1><p>먼저 정렬 알고리즘이란 목록 안에 저장된 요소들을 특정한 순서대로 재배치하는 알고리즘을 뜻한다.<br>효율적인 정렬을 위해 정렬 알고리즘이 필요하다고 할 수 있다.<br>정렬시 고려할 사항으로는 시간 복잡도, 메모리 사용량, 안정성(safety가 아니라 stable -&gt; 데이터의 순서가 바뀌지 않느냐 여부 문제) 등이 있다.</p>
<p>모든경우에 대해 최선의 정답을 내는 알고리즘은 없으므로 정렬 알고리즘의 특성에 대해 잘 알아두고 적절한 상황에 맞는 알고리즘을 택해야한다.</p>
<p>기초적인 정렬 알고리즘 5개에 대해 살펴보자.</p>
<h2 id="버블-정렬-Bubble-Sort"><a href="#버블-정렬-Bubble-Sort" class="headerlink" title="버블 정렬(Bubble Sort)"></a>버블 정렬(Bubble Sort)</h2><p>버블정렬은 서로 인접해 있는 요소 간의 대소 비교를 통해 정렬한다.<br>버블 정렬은 정렬 알고리즘 중 가장 단순한 알고리즘으로, 단순한 만큼 비효율적이다.<br>시간 복잡도가 최고, 평균, 최악 모두<code>O(n^2)</code>이며 공간복잡도는 하나의 배열만 사용하므로 <code>O(n)</code>이다.<br>동작 방식은 인접한 두 요소간의 대소 비교를 진행한다.</p>
<center>

<p><img src="/../images/sort/bubble.gif" alt="Bubble Sort"></p>
</center>

<p>이를 코드로 구현하면 다음과 같다.</p>
<p>배열의 요소 개수만큼 반복하면서, 각 반복시 인접 요소를 비교해 바꾸어주는것이다. 반복시마다 가장 큰 요소는 마지막에 위치하게 되므로 제외하면서 반복한다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">swap</span> = (<span class="params">arr, i, j</span>) =&gt; &#123;</span><br><span class="line">	[arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">bubbleSort</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> sortedArr = [...arr];</span><br><span class="line">	<span class="keyword">const</span> len = sortedArr.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (sortedArr[j] &gt; sortedArr[j + <span class="number">1</span>]) <span class="title function_">swap</span>(sortedArr, j, j + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sortedArr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="삽입-정렬-Insertion-Sort"><a href="#삽입-정렬-Insertion-Sort" class="headerlink" title="삽입 정렬(Insertion Sort)"></a>삽입 정렬(Insertion Sort)</h2><p>삽입 정렬이란 정렬을 진행할 원소의 index보다 낮은 곳에 있는 원소들을 탐색하며 알맞은 위치에 삽입해주는 정렬 알고리즘이다.<br>알고리즘이 동작하는 동안 계속해서 정렬이 진행되므로 반드시 맨 왼쪽 index까지 탐색하지 않아도 된다는 장점이 있다.<br>모두 정렬되어 있는 Optimal한 경우 모든 원소가 한 번씩만 비교되므로 <code>O(n)</code>의 시간 복잡도를 가지며 공간복잡도는 하나의 배열만 사용하므로 <code>O(n)</code>이다.</p>
<center>

<p><img src="/../images/sort/insertion.gif" alt="Insertion Sort"></p>
</center>

<p>이를 코드로 구현하면 다음과 같다.</p>
<p>첫 번째 for문은 정렬할 원소를 차례대로 선택하는 것이며, 두 번째 for문은 정렬할 원소보다 아래 인덱스에 있는 요소와 비교하는 것이다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">swap</span> = (<span class="params">arr, i, j</span>) =&gt; &#123;</span><br><span class="line">	[arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">insertionSort</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="title class_">SortedArr</span> = [...arr];</span><br><span class="line">	<span class="keyword">const</span> len = <span class="title class_">SortedArr</span>.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="title class_">SortedArr</span>[j - <span class="number">1</span>] &gt; <span class="title class_">SortedArr</span>[j]) <span class="title function_">swap</span>(<span class="title class_">SortedArr</span>, j - <span class="number">1</span>, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="title class_">SortedArr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="선택-정렬-Selection-Sort"><a href="#선택-정렬-Selection-Sort" class="headerlink" title="선택 정렬(Selection Sort)"></a>선택 정렬(Selection Sort)</h2><p>선택 정렬이란 배열에서 최소값을 반복적으로 찾아 정렬하는 알고리즘이다.<br>시간복잡도 최선, 평균, 최악 모두 <code>O(n^2)</code>에 해당하는 비효율적인 알고리즘으로 정렬 여부와 상관없이 모든 경우의 수를 전부 확인한다.</p>
<center>

<p><img src="/../images/sort/selection.gif" alt="Selection Sort"></p>
</center>

<p>이를 코드로 구현하면 다음과 같다.<br>배열에서 최소값을 찾아 맨 앞의 값과 바꾼다. 바꿔준 맨 앞 값을 제외하고 같은 방법을 반복한다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">swap</span> = (<span class="params">arr, i, j</span>) =&gt; &#123;</span><br><span class="line">	[arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">selectionSort</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="title class_">SortedArr</span> = [...arr];</span><br><span class="line">	<span class="keyword">const</span> len = <span class="title class_">SortedArr</span>.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">let</span> min = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="title class_">SortedArr</span>[min] &gt; <span class="title class_">SortedArr</span>[j]) min = j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="title function_">swap</span>(<span class="title class_">SortedArr</span>, i, min);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="title class_">SortedArr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>덧붙여 선택 정렬은 크게 2가지로 최소 선택 정렬과, 최대 선택 정렬이 있다.<br>최소 선택 정렬은 위처럼 오름차순으로 정렬하는 것이고 최대 선택 정렬은 내림차순으로 정렬하는 것이다.</p>
<h2 id="퀵-정렬-Quick-Sort"><a href="#퀵-정렬-Quick-Sort" class="headerlink" title="퀵 정렬 (Quick Sort)"></a>퀵 정렬 (Quick Sort)</h2><p>퀵 정렬은 분할정복법과 재귀를 사용해 정렬하는 알고리즘이다. 파이썬이나 자바에서 언어에서 자체 내장되어 있는 정렬 알고리즘도 퀵 정렬을 기반으로 한다.<br>시간 복잡도의 경우 최선과 평균일 때 <code>O(nlogn)</code>이며 최악의 경우에는 <code>O(n^2)</code>이다.<br>공간 복잡도의 경우 정렬된 원소를 담을 배열이 하나 필요로 하므로 <code>O(n)</code>이다.</p>
<center>

<p><img src="/../images/sort/quick.gif" alt="Quick Sort"></p>
</center>

<p>퀵 정렬에는 피봇(Pivot)이라는 개념이 사용된다. 피봇은 한 마디로 정렬 될 기준 원소를 뜻한다.<br>피봇 선택 방법에 따라 퀵 정렬의 성능이 달라지는데 최적의 피봇 선택이 어려워 보통 배열의 첫 번째 값이나 중앙 값을 선택한다.</p>
<p>퀵 정렬의 동작방식은 다음과 같다. 가령 예를 들어 배열 [29, 10, 14, 37, 1, 40]이 있고, 피봇을 임의로 29를 선택했다 가정하자.<br>이후 4를 기준으로 작은 것은 왼쪽으로 큰 것은 오른쪽으로 보내 [10, 14, 1] &lt; 29 &lt; [37, 40]을 생성한다.<br>다시 왼쪽에서부터 임의의 피봇 10을 설정하여 [1] &lt; 10 &lt; [14]를 생성하고 오른쪽에선 임의의 피봇 37을 설정하여 37 &lt; [40]으로 나눈다.<br>만약 배열의 길이가 1이라면 정렬이 완료된 것이므로 분할된 배열을 합쳐준다.</p>
<p>이를 코드로 구현하면 다음과 같다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">quickSort</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">if</span> (arr.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> pivot = arr[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">const</span> left = [];</span><br><span class="line">	<span class="keyword">const</span> right = [];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &lt; pivot) left.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">		<span class="keyword">else</span> right.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">quickSort</span>(left).<span class="title function_">concat</span>(pivot, <span class="title function_">quickSort</span>(right));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="병합-정렬-Merge-Sort"><a href="#병합-정렬-Merge-Sort" class="headerlink" title="병합 정렬(Merge Sort)"></a>병합 정렬(Merge Sort)</h2><p>병합 정렬은 분할정복과 재귀 알고리즘을 사용하는 정렬 알고리즘이다.<br>시간 복잡도의 경우 최선, 평균, 최악 모두 <code>O(nlogn)</code>이며 공간 복잡도의 경우 정렬된 원소를 담을 배열이 하나 필요로 하므로 <code>O(n)</code>이다.<br>.</p>
<center>

<p><img src="/../images/sort/merge.gif" alt="Merge Sort"></p>
</center>

<p>퀵 정렬과 함께 두 개의 알고리즘이 사용된다는 측면에서 공통점을 가진다.<br>그러나 퀵 정렬이 피봇 선택후 피봇을 기준으로 대소를 비교하는 반면, 병합 정렬은 배열의 요소가 하나일때까지 이분할 한 다음, 대소관계에 따라 재배열 하며 원래 크기의 배열로 병합한다.<br>예를 들어 배열 [29, 10, 14, 37, 1, 40]이 있을 때, 첫 번째로 [29, 10, 14]와 [37, 1, 40]으로 분리한다.<br>두 번째로 [29, 10], [14], [37, 1], [40]으로 나눈다.<br>세 번째로 [29], [10], [14], [37], [1], [40]으로 나눈다.<br>이렇게 모든 원소가 분리되면 대소 관계를 고려하여 병합 과정을 거친다.<br>첫 번째로 [10, 29], [14], [1, 37], [40]이 되며, 두 번째는 [10, 14, 29], [1, 37, 40]이 된다.<br>마지막으로 하나의 배열로 병합되면서 [1, 10, 14, 29, 37, 40]와 같이 정렬이 완료된다.</p>
<p>이를 코드로 구현하면 다음과 같다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">merge</span> = (<span class="params">left, right</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> result = [];</span><br><span class="line">	<span class="keyword">while</span> (left.<span class="property">length</span> !== <span class="number">0</span> &amp;&amp; right.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (left[<span class="number">0</span>] &lt; right[<span class="number">0</span>]) result.<span class="title function_">push</span>(left.<span class="title function_">shift</span>());</span><br><span class="line">		<span class="keyword">else</span> result.<span class="title function_">push</span>(right.<span class="title function_">shift</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> [...result, ...left, ...right];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mergeSort</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">if</span> (arr.<span class="property">length</span> === <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> middleIndex = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(arr.<span class="property">length</span> / <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">const</span> left = arr.<span class="title function_">slice</span>(<span class="number">0</span>, middleIndex);</span><br><span class="line">	<span class="keyword">const</span> right = arr.<span class="title function_">slice</span>(middleIndex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">merge</span>(<span class="title function_">mergeSort</span>(left), <span class="title function_">mergeSort</span>(right));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>위에서 정리한 5가지의 정렬 방법 외에도 힙 정렬, 팀 정렬등 정말 많은 정렬 방법이 존재한다.<br>모든 정렬 방법을 다 탐구하고 외우기는 어렵지만 적절한 자료구조와 알고리즘을 활용해야 좋은 코드를 작성할 수 있는 만큼 꾸준히 CS 공부를 해야겠다🔥</p>
]]></content>
      <tags>
        <tag>알고리즘</tag>
      </tags>
  </entry>
  <entry>
    <title>pageYOffset vs scrollY, scroll() vs scrollTo()</title>
    <url>/2022/pageYOffset-vs-scrollY-scroll-vs-scrollTo/</url>
    <content><![CDATA[<h1 id="🤔What-is-Problem"><a href="#🤔What-is-Problem" class="headerlink" title="🤔What is Problem?"></a>🤔What is Problem?</h1><p>페어 프로그래밍을 진행하면서 수직으로 스크롤한 거리에 따라 숨겨진 버튼을 활성화 하고, 스크롤 버튼을 클릭했을 때 맨 위로 스크롤하는 예제를 해결해야했다.</p>
<p>이를 위해 수직으로 스크롤한 거리를 측정하는 방법과 스크롤을 시키는 방법이 필요해 이에 대해 알아보았는데, 같은 기능을 하는 프로퍼티와 메서드가 중복으로 존재해 어떤것을 사용해야하는지 고민이 되었다.</p>
<h2 id="Window-pageYOffset-vs-Window-scrollY"><a href="#Window-pageYOffset-vs-Window-scrollY" class="headerlink" title="Window.pageYOffset vs Window.scrollY"></a>Window.pageYOffset vs Window.scrollY</h2><p>먼저 수직으로 스크롤한 거리를 측정하는 방법에는 Window.pageYOffset와 Window.scrollY가 존재했다. MDN에서는 pageYOffset이 scrollY의 다른이름이라고 했지만, 두 프로퍼티에는 브라우저 호환성의 차이가 존재했다.</p>
<p>일부 오래된 브라우저는 scrollY 대신 pageYOffset만 지원했고 노후 환경을 신경쓰지 않아도 된다면 둘 중 아무거나 사용해도 괜찮지만, 별다른 요구조건이 없다면 하위호환성을 위해 pageYOffset을 사용하는 것이 더 좋은 코드라고 판단했다.</p>
<h2 id="Window-scroll-vs-Window-scrollTo"><a href="#Window-scroll-vs-Window-scrollTo" class="headerlink" title="Window.scroll() vs Window.scrollTo()"></a>Window.scroll() vs Window.scrollTo()</h2><p>다음으로 맨 위로 스크롤하기 위해서는 Window.scroll() 이나 Window.scrollTo() 메서드를 사용할 수 있었다. 이 두 메서드는 차이 없이 동일해 둘 중 아무거나 사용해도 괜찮았다. 다만 scroll 메서드가 더 먼저 나왔기 때문에 실제로 사용된 코드도 많고 혹여나 버그등이 발생해 검색을 해야한다면 검색 결과도 많아 scroll을 사용하는것이 더 좋을 것이라고 판단했다.</p>
<p>또 단순히 메서드의 인자로 x-좌표와 y-좌표를 주는것 이외에도 options를 통해 top, left, behavior를 줄 수 있다는 것을 알았다. 특히 behavior: smooth를 사용해 애니메이션을 따로 만들지 않더라도 부드럽게 이동할 수 있는점이 유용해 꼭 기억하자 생각했다.</p>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://developer.mozilla.org/ko/docs/Web/API/Window/pageYOffset">https://developer.mozilla.org/ko/docs/Web/API/Window/pageYOffset</a></li>
<li><a href="https://developer.mozilla.org/ko/docs/Web/API/Window/scrollY">https://developer.mozilla.org/ko/docs/Web/API/Window/scrollY</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/scroll">https://developer.mozilla.org/en-US/docs/Web/API/Window/scroll</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollTo">https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollTo</a></li>
<li><a href="https://stackoverflow.com/questions/1925671/javascript-window-scroll-vs-window-scrollto">https://stackoverflow.com/questions/1925671/javascript-window-scroll-vs-window-scrollto</a></li>
</ul>
]]></content>
      <tags>
        <tag>자바스크립트</tag>
      </tags>
  </entry>
  <entry>
    <title>데이터베이스란?</title>
    <url>/2023/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%9E%80/</url>
    <content><![CDATA[<h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>면접을 진행하면서 CS관련 질문들을 받게 되었다. 대체로 잘 대답을 했지만 자료구조와 데이터베이스의 용어를 혼용해서 설명하는 실수도 했고, 관계형 데이터베이스를 연결형이라고 말하는 실수도 있었다.</p>
<p>근본적으로 CS지식 특히 데이터베이스에 대한 지식이 부족했기에 발생한 문제여서 데이터베이스에 대해 정리해봐야겠다고 생각했다.</p>
<h1 id="데이터베이스란"><a href="#데이터베이스란" class="headerlink" title="데이터베이스란?"></a>데이터베이스란?</h1><p>데이터베이스를 한 마디로 정의하면 ‘데이터의 집합’이라고 할 수 있다.<br>데이터베이스는 중복된 데이터를 없애고, 자료를 구조화하여, 효율적인 처리를 할 수 있도록 관리된다.</p>
<h2 id="데이터베이스의-특징"><a href="#데이터베이스의-특징" class="headerlink" title="데이터베이스의 특징"></a>데이터베이스의 특징</h2><p>데이터베이스는 다음과 같은 특징을 가진다.</p>
<ol>
<li><p>사용자의 질의에 대하여 즉각적인 처리와 응답이 이루어진다.</p>
</li>
<li><p>생성, 수정, 삭제를 통하여 항상 최신의 데이터를 유지한다.</p>
</li>
<li><p>사용자들이 원하는 데이터를 동시에 공유할 수 있다.</p>
</li>
<li><p>사용자가 원하는 데이터를 주소가 아닌 내용에 따라 참조 할 수 있다.</p>
</li>
<li><p>응용프로그램과 데이터베이스는 독립되어 있으므로, 데이터의 논리적 구조와 응용프로그램은 별개로 동작된다.</p>
</li>
</ol>
<h2 id="DBMS-Database-Management-System"><a href="#DBMS-Database-Management-System" class="headerlink" title="DBMS(Database Management System)"></a>DBMS(Database Management System)</h2><p>이런 데이터베이스를 관리하고 운영하는 소프트웨어를 DBMS(Database Management System)라고 한다.</p>
<p>DBMS에는 관계형(Relational), 키-값형(KV store), 객체형(Object), 문서형(Document), 컬럼 패밀리형(Column Family) 등이 존재한다.</p>
<p>특히 관계형 DBMS가 가장 일반적으로 사용되며, 이때 사용되는 표준 언어를 SQL(Structured Query Language)이라 한다.<br>관계형 DBMS를 SQL, 비-관계형 데이터베이스는 NoSQL이라고 부르기도 한다.</p>
<p>간단하게 SQL방식과 NoSQL방식(대표적으로 문서형)에 대해 알아보자.</p>
<h3 id="SQL-방식"><a href="#SQL-방식" class="headerlink" title="SQL 방식"></a>SQL 방식</h3><p>SQL 방식은 데이터들을 엑셀과 비슷한 <strong>표에 정리</strong>해두는 방식이다.</p>
<p>SQL 방식은 NoSQL방식과달리 각각의 <strong>표 사이에 관계성을 부여</strong> 할 수 있다.<br>관계성을 부여할 수 있기 때문에 mapping해주는 툴로 **<code>ORM(Object Relation Mapping)</code>**을 사용한다.</p>
<p>이러한 SQL방식을 사용하는 데이터베이스에는 대표적으로 Oracle, MySQL, Postgres가 있다.</p>
<h3 id="NoSQL-방식-문서형"><a href="#NoSQL-방식-문서형" class="headerlink" title="NoSQL 방식(문서형)"></a>NoSQL 방식(문서형)</h3><p>NoSQL 방식은 <strong>서류 봉투</strong>에 document를 모아두는 방식이다.</p>
<p>NoSQL에서는 서류 봉투를 <strong>컬렉션</strong>이라고 부르며, 통신을 도와주는 툴로는 **<code>ODM(Object Document Mapping)</code>**을 사용한다.</p>
<p>NoSQL 방식을 사용하는 데이터베이스에는 대표적으로 MongoDB와 FireBase가 있다.</p>
<h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>정말 간단하게 데이터베이스에 대해 정리해보았다.<br>이 정도만 면접에서 대답했어도 좋았을텐데 너무 공부가 부족했던게 아닐까 싶다.<br>연차가 쌓일수록 더욱 CS지식이 중요해진다고들 하는데, 비전공자인 만큼 더 열심히 해야할 것 같다.</p>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li><a href="http://www.tcpschool.com/mysql/DB">http://www.tcpschool.com/mysql/DB</a></li>
<li><a href="https://hongong.hanbit.co.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-databasedb-dbms-sql%EC%9D%98-%EA%B0%9C%EB%85%90/">https://hongong.hanbit.co.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-databasedb-dbms-sql%EC%9D%98-%EA%B0%9C%EB%85%90/</a></li>
<li><a href="https://namu.wiki/w/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4#s-5.1">https://namu.wiki/w/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4#s-5.1</a></li>
</ul>
]]></content>
      <tags>
        <tag>용어정리</tag>
      </tags>
  </entry>
</search>
